<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>EmacsWiki: icicles-doc1.el</title><link rel="alternate" type="application/wiki" title="Edit this page" href="http://www.emacswiki.org/emacs?action=edit;id=icicles-doc1.el" /><link type="text/css" rel="stylesheet" href="/emacs/wiki.css" /><meta name="robots" content="INDEX,FOLLOW" /><link rel="alternate" type="application/rss+xml" title="EmacsWiki" href="http://www.emacswiki.org/emacs?action=rss" /><link rel="alternate" type="application/rss+xml" title="EmacsWiki: icicles-doc1.el" href="http://www.emacswiki.org/emacs?action=rss;rcidonly=icicles-doc1.el" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki with page content"
      href="http://www.emacswiki.org/emacs/full.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki with page content and diff"
      href="http://www.emacswiki.org/emacs/full-diff.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki including minor differences"
      href="http://www.emacswiki.org/emacs/minor-edits.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Changes for icicles-doc1.el only"
      href="http://www.emacswiki.org/emacs?action=rss;rcidonly=icicles-doc1.el" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body class="http://www.emacswiki.org/emacs"><div class="header"><a class="logo" href="http://www.emacswiki.org/emacs/SiteMap"><img class="logo" src="/emacs_logo.png" alt="[Home]" /></a><span class="gotobar bar"><a class="local" href="http://www.emacswiki.org/emacs/SiteMap">SiteMap</a> <a class="local" href="http://www.emacswiki.org/emacs/Search">Search</a> <a class="local" href="http://www.emacswiki.org/emacs/ElispArea">ElispArea</a> <a class="local" href="http://www.emacswiki.org/emacs/HowTo">HowTo</a> <a class="local" href="http://www.emacswiki.org/emacs/RecentChanges">RecentChanges</a> <a class="local" href="http://www.emacswiki.org/emacs/News">News</a> <a class="local" href="http://www.emacswiki.org/emacs/Problems">Problems</a> <a class="local" href="http://www.emacswiki.org/emacs/Suggestions">Suggestions</a> </span>
<!-- Google CSE Search Box Begins  -->
<form class="tiny" action="http://www.google.com/cse" id="searchbox_004774160799092323420:6-ff2s0o6yi"><p>
<input type="hidden" name="cx" value="004774160799092323420:6-ff2s0o6yi" />
<input type="text" name="q" size="25" />
<input type="submit" name="sa" value="Search" />
</p></form>
<script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=searchbox_004774160799092323420%3A6-ff2s0o6yi"></script>
<!-- Google CSE Search Box Ends -->
<h1><a title="Click to search for references to this page" rel="nofollow" href="http://www.google.com/cse?cx=004774160799092323420:6-ff2s0o6yi&amp;q=%22icicles-doc1.el%22">icicles-doc1.el</a></h1></div><div class="wrapper"><div class="content browse"><p><a href="http://www.emacswiki.org/emacs/download/icicles-doc1.el">Download</a></p><pre class="code"><span class="linecomment">;;; icicles-doc1.el --- Minibuffer input completion and cycling.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; Filename: icicles-doc1.el</span>
<span class="linecomment">;; Description: Minibuffer completion and cycling.</span>
<span class="linecomment">;; Author: Drew Adams</span>
<span class="linecomment">;; Maintainer: Drew Adams</span>
<span class="linecomment">;; Copyright (C) 1996-2009, Drew Adams, all rights reserved.</span>
<span class="linecomment">;; Created: Tue Aug  1 14:21:16 1995</span>
<span class="linecomment">;; Version: 22.0</span>
<span class="linecomment">;; Last-Updated: Sat Feb 28 12:26:31 2009 (-0800)</span>
<span class="linecomment">;;           By: dradams</span>
<span class="linecomment">;;     Update #: 24226</span>
<span class="linecomment">;; URL: http://www.emacswiki.org/cgi-bin/wiki/icicles-doc1.el</span>
<span class="linecomment">;; Keywords: internal, extensions, help, abbrev, local, minibuffer,</span>
<span class="linecomment">;;           keys, apropos, completion, matching, regexp, command</span>
<span class="linecomment">;; Compatibility: GNU Emacs 20.x, GNU Emacs 21.x, GNU Emacs 22.x</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; Features that might be required by this library:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   None</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;; Commentary:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles documentation, part 1.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Files `icicles-doc1.el' and `icicles-doc2.el' contain the doc for</span>
<span class="linecomment">;;  Icicles, including how to install and use Icicles.  You can also</span>
<span class="linecomment">;;  read the Icicles doc, in formatted form, on the Emacs-Wiki Web</span>
<span class="linecomment">;;  site: http://www.emacswiki.org/cgi-bin/wiki/Icicles.  Emacs Wiki</span>
<span class="linecomment">;;  also has a few addtional pages about Icicles.  In particular, if</span>
<span class="linecomment">;;  you are new to Emacs, as well as Icicles, see this page:</span>
<span class="linecomment">;;  http://www.emacswiki.org/cgi-bin/wiki/EmacsNewbieWithIcicles.</span>
 
<span class="linecomment">;;(@* "Installing Icicles")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To use this library:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Add this to your initialization file (~/.emacs or ~/_emacs):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;      (require 'icicles) ; Load this library.</span>
<span class="linecomment">;;      (icicle-mode 1)    ; Turn on Icicle mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    It is best to add this code *after* any code that creates or</span>
<span class="linecomment">;;    changes key bindings, so Icicles can pick up all of your key</span>
<span class="linecomment">;;    definitions (bindings).  However, if you make new bindings, you</span>
<span class="linecomment">;;    can always exit and then reenter Icicle mode to pick them up.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    You will need all of these libraries (loaded by `icicles.el'):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;      `icicles-chg.el'  (not loaded - change logs only)</span>
<span class="linecomment">;;      `icicles-cmd.el'</span>
<span class="linecomment">;;      `icicles-doc1.el' (not loaded - doc only)</span>
<span class="linecomment">;;      `icicles-doc2.el' (not loaded - doc only)</span>
<span class="linecomment">;;      `icicles-face.el'</span>
<span class="linecomment">;;      `icicles-fn.el'</span>
<span class="linecomment">;;      `icicles-mac.el'</span>
<span class="linecomment">;;      `icicles-mcmd.el'</span>
<span class="linecomment">;;      `icicles-mode.el'</span>
<span class="linecomment">;;      `icicles-opt.el'</span>
<span class="linecomment">;;      `icicles-var.el'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The following libraries are optional (loaded by `icicles.el' if</span>
<span class="linecomment">;;    in your `load-path'), but recommended.  They are all available</span>
<span class="linecomment">;;    at Emacs Wiki, http://www.emacswiki.org/cgi-bin/wiki/ElispArea.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;      `col-highlight.el' - (required by `crosshairs.el') - Emacs 22+</span>
<span class="linecomment">;;      `crosshairs.el'    - highlight target positions    - Emacs 22+</span>
<span class="linecomment">;;      `hexrgb.el'        - color manipulation</span>
<span class="linecomment">;;      `hl-line+.el'      - (required by `crosshairs.el') - Emacs 22+</span>
<span class="linecomment">;;      `icomplete+.el'    - enhancements to `icomplete.el'</span>
<span class="linecomment">;;      `lacarte.el'       - keyboard access to the menubar menus</span>
<span class="linecomment">;;      `vline.el'         - (required by `crosshairs.el') - Emacs 22+</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    However, do not try to load `hexrgb.el' if you do not have a</span>
<span class="linecomment">;;    windowing system (window manager).  It manipulates colors in</span>
<span class="linecomment">;;    ways that are not possible in a console.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    More generally, Icicles is designed for use with a windowing</span>
<span class="linecomment">;;    system; you might not want to use it without one.  In</span>
<span class="linecomment">;;    particular, by default, Icicles takes advantage of keys, such as</span>
<span class="linecomment">;;    `S-TAB', that are unavailable in a console (e.g. xterm).  If you</span>
<span class="linecomment">;;    have a windowing system, but you want to start Emacs from a</span>
<span class="linecomment">;;    console window, consider using an Emacs server and client:</span>
<span class="linecomment">;;    `emacsclient' or `gnuclient'.  If you want to use Icicles with</span>
<span class="linecomment">;;    no windowing system, then you will want to rebind several keys -</span>
<span class="linecomment">;;    see file `icicles-mode.el' for key bindings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    It is of course best to byte-compile all of the libraries</span>
<span class="linecomment">;;    (except `icicle-chg.el', `icicles-doc1.el', and</span>
<span class="linecomment">;;    `icicles-doc2.el').  You will likely get some byte-compiler</span>
<span class="linecomment">;;    warning messages.  These are probably benign - ignore them.</span>
<span class="linecomment">;;    Icicles is designed to work with multiple versions of Emacs, and</span>
<span class="linecomment">;;    that fact provokes compiler warnings.  If you get byte-compiler</span>
<span class="linecomment">;;    errors (not warnings), then please report a bug, using `M-x</span>
<span class="linecomment">;;    icicle-send-bug-report'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    After startup, you can turn Icicle mode on or off at any time</span>
<span class="linecomment">;;    interactively, using command `icy-mode' (aka `icicle-mode' -</span>
<span class="linecomment">;;    prefix `icy' is unique to this command, so it is easier to</span>
<span class="linecomment">;;    complete).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note: If you turn on Icicle mode in your init file, it's best to</span>
<span class="linecomment">;;    do so as late as possible - after you or any libraries that you</span>
<span class="linecomment">;;    load do any key binding.  This is because Icicles uses the</span>
<span class="linecomment">;;    current global key bindings to determine which keys to bind for</span>
<span class="linecomment">;;    minibuffer completion and cycling.  To pick up the latest</span>
<span class="linecomment">;;    bindings at any time, you can of course enter Icicle mode</span>
<span class="linecomment">;;    interactively using command `icy-mode' (if necessary, exit, then</span>
<span class="linecomment">;;    re-enter).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note: Icicles redefines some functions when you are in Icicle</span>
<span class="linecomment">;;    mode (it restores them when you leave Icicle mode).  It</span>
<span class="linecomment">;;    generally does not use `defadvice' to alter the functions; it</span>
<span class="linecomment">;;    redefines them instead.  Because of this, there can be</span>
<span class="linecomment">;;    incompatibilities with other libraries that also change the same</span>
<span class="linecomment">;;    functions (using `defadvice' or otherwise).  An example is Viper</span>
<span class="linecomment">;;    mode.  If you load Viper before Icicles, then you will run into</span>
<span class="linecomment">;;    problems with function `read-file-name' because it is tweaked by</span>
<span class="linecomment">;;    both Viper and Icicles.  If you load Icicles before Viper, you</span>
<span class="linecomment">;;    should not encounter this problem (but you might encounter other</span>
<span class="linecomment">;;    problems: both Icicles and Viper try to control the minibuffer).</span>
 
<span class="linecomment">;;(@* "Index")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Index</span>
<span class="linecomment">;;  -----</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you have library `linkd.el' and Emacs 22 or later, load</span>
<span class="linecomment">;;  `linkd.el' and turn on `linkd-mode' now.  It lets you easily</span>
<span class="linecomment">;;  navigate around the sections of this doc.  Linkd mode will</span>
<span class="linecomment">;;  highlight this Index and render it more readable.  Likewise, for</span>
<span class="linecomment">;;  the cross-references and section headings throughout this file.</span>
<span class="linecomment">;;  You can get `linkd.el' here:</span>
<span class="linecomment">;;  http://www.emacswiki.org/cgi-bin/wiki/linkd.el.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@* "Documentation in File `icicles-doc1.el'")</span>
<span class="linecomment">;;  ----------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Nutshell View of Icicles")</span>
<span class="linecomment">;;    (@&gt; "README for Non-Readers")</span>
<span class="linecomment">;;    (@&gt; "Toggle Options on the Fly")</span>
<span class="linecomment">;;    (@&gt; "Cycle Completion Candidates")</span>
<span class="linecomment">;;    (@&gt; "Display Completion Candidates")</span>
<span class="linecomment">;;    (@&gt; "Prefix Completion and Apropos Completion")</span>
<span class="linecomment">;;    (@&gt; "Chains of Simple Match Patterns - Progressive Completion")</span>
<span class="linecomment">;;    (@&gt; "Chip Away the Non-Elephant")</span>
<span class="linecomment">;;    (@&gt; "Choose Before You Act")</span>
<span class="linecomment">;;    (@&gt; "Help on Completion Candidates")</span>
<span class="linecomment">;;    (@&gt; "Perform Multiple Operations In One Command")</span>
<span class="linecomment">;;    (@&gt; "Completion Status Indicators")</span>
<span class="linecomment">;;    (@&gt; "Icicles Search")</span>
<span class="linecomment">;;    (@&gt; "Complete Key Sequences Too")</span>
<span class="linecomment">;;    (@&gt; "Available for Almost Any Input")</span>
<span class="linecomment">;;    (@&gt; "Component Icicles Libraries")</span>
<span class="linecomment">;;    (@&gt; "If You Are an Emacs-Lisp Programmer")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Inserting Text Found Near the Cursor")</span>
<span class="linecomment">;;  (@&gt; "Background on Vanilla Emacs Input Completion")</span>
<span class="linecomment">;;  (@&gt; "Cycling Completions")</span>
<span class="linecomment">;;  (@&gt; "Traversing Minibuffer Histories")</span>
<span class="linecomment">;;  (@&gt; "Apropos Completions")</span>
<span class="linecomment">;;  (@&gt; "Expanded-Common-Match Completion")</span>
<span class="linecomment">;;  (@&gt; "Progressive Completion")</span>
<span class="linecomment">;;    (@&gt; "`M-*': Matching Additional Regexps")</span>
<span class="linecomment">;;    (@&gt; "Successive Approximation...")</span>
<span class="linecomment">;;    (@&gt; "`M-&': Satisfying Additional Predicates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Regressive Completion")</span>
<span class="linecomment">;;  (@&gt; "Inserting a Regexp from a Variable")</span>
<span class="linecomment">;;  (@&gt; "Special Characters in Input Patterns")</span>
<span class="linecomment">;;  (@&gt; "Alternative Libraries: Other Methods of Choosing Default Values")</span>
<span class="linecomment">;;  (@&gt; "Exiting the Minibuffer Without Confirmation")</span>
<span class="linecomment">;;  (@&gt; "*Completions* Display")</span>
<span class="linecomment">;;  (@&gt; "Icompletion")</span>
<span class="linecomment">;;    (@&gt; "icomplete+.el Displays the Number of Other Prefix Candidates")</span>
<span class="linecomment">;;    (@&gt; "Icicles Highlights the Input that Won't Complete")</span>
<span class="linecomment">;;    (@&gt; "Icompletion in *Completions*: Apropos and Prefix Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Sorting Candidates and Removing Duplicates")</span>
<span class="linecomment">;;    (@&gt; "Changing the Sort Order")</span>
<span class="linecomment">;;    (@&gt; "Defining New Sort Orders")</span>
<span class="linecomment">;;    (@&gt; "Different Sorts for Different Sorts of Uses")</span>
<span class="linecomment">;;  (@&gt; "Get Help on Candidates")</span>
<span class="linecomment">;;    (@&gt; "Use Candidate Help Like You Use Emacs Command `apropos'")</span>
<span class="linecomment">;;    (@&gt; "Other Icicles Apropos Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Multi-Commands")</span>
<span class="linecomment">;;    (@&gt; "What Is a Multi-Command?")</span>
<span class="linecomment">;;    (@&gt; "How Does a Multi-Command Work?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "More about Multi-Commands")</span>
<span class="linecomment">;;    (@&gt; "Alternative Actions")</span>
<span class="linecomment">;;    (@&gt; "Deleting Objects")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Icicles Tripping")</span>
<span class="linecomment">;;    (@&gt; "Highlighting the Destination")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Key Completion")</span>
<span class="linecomment">;;    (@&gt; "Completing Keys")</span>
<span class="linecomment">;;    (@&gt; "`S-TAB' Is Everywhere - Start With It")</span>
<span class="linecomment">;;    (@&gt; "Completing Keys By Name")</span>
<span class="linecomment">;;    (@&gt; "Completing Prefix Keys")</span>
<span class="linecomment">;;    (@&gt; "Meta Key Bindings")</span>
<span class="linecomment">;;    (@&gt; "Navigate the Key-Binding Hierarchy")</span>
<span class="linecomment">;;    (@&gt; "Local Bindings Are Highlighted")</span>
<span class="linecomment">;;    (@&gt; "Completing Keys By Just Hitting Them")</span>
<span class="linecomment">;;    (@&gt; "Key and Command Help")</span>
<span class="linecomment">;;    (@&gt; "`S-TAB' Is a Multi-Command")</span>
<span class="linecomment">;;    (@&gt; "Possible Source of Confusion")</span>
<span class="linecomment">;;    (@&gt; "Three-Key Emacs")</span>
<span class="linecomment">;;    (@&gt; "Entering Special and Foreign Characters")</span>
<span class="linecomment">;;    (@&gt; "Handling Keymaps That Are Inaccessible From the Global Map")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Icicles Multi `M-x'")</span>
<span class="linecomment">;;    (@&gt; "Examples of Using Multi `M-x'")</span>
<span class="linecomment">;;      (@&gt; "What about describe-variable and describe-function?")</span>
<span class="linecomment">;;    (@&gt; "Multi `M-x' Turns Every Command into a Multi-Command")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Choose All Completion Candidates")</span>
<span class="linecomment">;;  (@&gt; "Sets of Completion Candidates")</span>
<span class="linecomment">;;    (@&gt; "Saving and Retrieving Completion Candidates")</span>
<span class="linecomment">;;    (@&gt; "Different Places for Saving and Retrieving Candidates")</span>
<span class="linecomment">;;    (@&gt; "Set Operations")</span>
<span class="linecomment">;;  (@&gt; "Google Matching")</span>
<span class="linecomment">;;    (@&gt; "Domain of Discourse")</span>
<span class="linecomment">;;    (@&gt; "Global Filtering")</span>
<span class="linecomment">;;    (@&gt; "Word Matching and String Matching")</span>
<span class="linecomment">;;    (@&gt; "AND Matching and OR Matching")</span>
<span class="linecomment">;;    (@&gt; "NOT Matching")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "File-Name Input and Locating Files Anywhere")</span>
<span class="linecomment">;;    (@&gt; "Function `read-file-name'")</span>
<span class="linecomment">;;    (@&gt; "Function `completing-read'")</span>
<span class="linecomment">;;    (@&gt; "Icicles Commands that Read File Names")</span>
<span class="linecomment">;;    (@&gt; "Absolute File Names and Different Directories")</span>
<span class="linecomment">;;  (@&gt; "Persistent Sets of Completion Candidates")</span>
<span class="linecomment">;;    (@&gt; "Saving Candidates in Cache Files")</span>
<span class="linecomment">;;    (@&gt; "Filesets and Icicles Saved Completion Sets")</span>
<span class="linecomment">;;    (@&gt; "Improving Performance with Persistent Sets")</span>
<span class="linecomment">;;      (@&gt; "Avoid Remote File-Name Completion")</span>
<span class="linecomment">;;      (@&gt; "Avoid Generating A Large Completion Set")</span>
<span class="linecomment">;;  (@&gt; "Dealing With Large Candidate Sets")</span>
<span class="linecomment">;;  (@&gt; "History Enhancements")</span>
<span class="linecomment">;;    (@&gt; "What Input, What History?")</span>
<span class="linecomment">;;    (@&gt; "Overview of Minibuffer History Enhancements")</span>
<span class="linecomment">;;    (@&gt; "Using Completion to Insert Previous Inputs: `M-o'")</span>
<span class="linecomment">;;    (@&gt; "Putting Previous Candidates First: `C-M-,'")</span>
<span class="linecomment">;;    (@&gt; "Matching Only Historical Candidates: `M-h' and `M-pause'")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Isearch Enhancements")</span>
<span class="linecomment">;;    (@&gt; "Launch Occur using the Isearch Search String")</span>
<span class="linecomment">;;    (@&gt; "Launch Icicles Search using the Isearch Search String")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Documentation in File `icicles-doc2.el'")</span>
<span class="linecomment">;;  -----------------------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Introduction: On Beyond Occur...")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "How Icicles Search Works")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Why Use 2 Search Patterns?")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Search Multiple Buffers, Files, and Saved Regions")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "User Options for Icicles Searching")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Using Regexps With Icicles Search")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Search and Replace")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Other Icicles Search Commands")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles Imenu")</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc2.el" :to "`icicle-imenu' Combines Benefits of Imenu and Emacs Tags")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Compile/Grep Search")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Input Reuse in Interactive Interpreter Modes")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Define Your Own Icicles Search Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Multiple Regions")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Tags Enhancements")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "`icicle-find-tag': Find Tags in All Tags Tables")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "`icicle-find-first-tag': Find First Tag in Current Table")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "`icicle-tags-search': Search and Replace Using Tags")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Shell-Command Enhancements")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Dired Enhancements")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Shell Commands on Marked Files")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Search-and-Replace Marked Files")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Save Marked Files as Completion Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Open Dired for a Set of File Names")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Marked Files as a Project")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Info Enhancements")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles Completion for Info")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Using Icicle-Search With Info")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Support for Projects")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Defining and Saving Sets of Files, Buffers, Regions")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Navigating Among Code Definitions")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Searching Project Files")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Retrieving and Reusing a Saved Project")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Semantics? Roll Your Own?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Using Complex Completion Candidates")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles OO: Object-Action Interaction")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Apropos Completion as OO")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "M-RET")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "`icicle-object-action' and `icicle-anything'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles with Anything")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Multi-Completions")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles Multi-Completion Commands")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "How Multi-Completions Work")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Multi-Completions vs `completing-read-multiple'")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Fuzzy Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Scatter-Match Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Fuzzy-Match Completion")</span>
''
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Completion in Other Buffers")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Dynamic Abbreviation")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "BBDB Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Thesaurus Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Completion in Comint Modes")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Customization and General Tips")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Using Icicles with Delete Selection Mode")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles User Options and Faces")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "File-Name and Directory-Name Completion Tips")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Key Bindings")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Global Bindings")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles-Mode Bindings")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Minibuffer Bindings")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Customizing Key Bindings")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Customizing Global Bindings")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Customizing Icicle Mode Bindings")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Customizing Minibuffer Bindings")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Redefines Some Standard Commands")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Programming with Fancy Candidates")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Programming Multi-Completions")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Variable icicle-list-use-nth-parts")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Variable icicle-candidate-properties-alist")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "What You See Is Not What You Get")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Candidates with Text Properties")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Using Property icicle-special-candidate")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Applying Text Properties to a Candidate String")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Defining Icicles Commands (Including Multi-Commands)")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Nothing To It!")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Multi-Commands Are Easy To Define Too")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Are Users Dependent on Icicles To Use Multi-Commands?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Defining Icicles Tripping Commands")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Defining Multiple-Choice Menus")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Defining Icicles Multi `M-x'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "How Multi `M-x' is Defined")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Defining Multi-Commands the Hard Way")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Global Filters")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Specifying Match Functions for Commands")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Defining Buffer-Text Completion for Comint Modes")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Note to Programmers")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "La Petite Histoire")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Note on Non-nil `pop-up-frames' on MS Windows")</span>
 
<span class="linecomment">;;(@* "Nutshell View of Icicles")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Nutshell View of Icicles</span>
<span class="linecomment">;;  ------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "README for Non-Readers")</span>
<span class="linecomment">;;  ** README for Non-Readers **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Load library `icicles.el', turn on Icicle mode, and you're good to</span>
<span class="linecomment">;;  go.  You can turn Icicle mode off or on at any time with command</span>
<span class="linecomment">;;  `icy-mode'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Beyond that, the most important thing to know about Icicles is</span>
<span class="linecomment">;;  that you can get help on Icicle mode during minibuffer input.  You</span>
<span class="linecomment">;;  do that either by using item Help of the menu-bar Icicles menu or</span>
<span class="linecomment">;;  Minibuf menu, or by hitting `C-?' (`icicle-minibuffer-help').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You now know enough to use Icicles.  If you have doc-phobia or are</span>
<span class="linecomment">;;  easily overwhelmed by explanations, then *read no more* - just try</span>
<span class="linecomment">;;  it!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you want a little more explanation than the help page (`C-?'),</span>
<span class="linecomment">;;  then read the rest of section (@&gt; "Nutshell View of Icicles"), but</span>
<span class="linecomment">;;  no more.  It shows a sample of what you can do in Icicle mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you want to know more about Icicles by reading instead of just</span>
<span class="linecomment">;;  trying, then read beyond section (@&gt; "Nutshell View of Icicles").</span>
<span class="linecomment">;;  There is a lot you can learn, but there is not much that you need</span>
<span class="linecomment">;;  to learn, to use Icicles usefully.  Don't be afraid to get in and</span>
<span class="linecomment">;;  get wet.  Above all, don't be overwhelmed by the doc - if it</span>
<span class="linecomment">;;  helps, fine.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One good way to start is to explore menus Icicles and Minibuf; you</span>
<span class="linecomment">;;  can access most Icicles features using these menus, without at the</span>
<span class="linecomment">;;  same time struggling to learn new key bindings.  The Icicles menu</span>
<span class="linecomment">;;  is available all of the time (that is, whenever you are in Icicle</span>
<span class="linecomment">;;  mode), and the Minibuf menu is available whenever the minibuffer</span>
<span class="linecomment">;;  is active.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During minibuffer input completion, you can also press Control and</span>
<span class="linecomment">;;  right-click (`C-mouse-3') on a completion candidate in buffer</span>
<span class="linecomment">;;  `*Completions*', and choose from a contextual menu, Completion</span>
<span class="linecomment">;;  Candidate.  Some of its menu items apply to the clicked candidate;</span>
<span class="linecomment">;;  others apply to all candidates.  This is a long menu!  Think of it</span>
<span class="linecomment">;;  as a learning device and a way to remind you of operations on</span>
<span class="linecomment">;;  individual candidates and their key bindings .  In this it is</span>
<span class="linecomment">;;  similar to the help you get when you use `C-?' in the minibuffer,</span>
<span class="linecomment">;;  but with the menu you can also act, not just be reminded.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Toggle Options on the Fly")</span>
<span class="linecomment">;;  ** Toggle Options on the Fly **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are many user options that affect the behavior of Icicles</span>
<span class="linecomment">;;  features.  Some of these are Boolean (on/off) or allow for simple</span>
<span class="linecomment">;;  alternation or cycling of the possible values.  Many of those</span>
<span class="linecomment">;;  options are associated with toggle commands that are bound to keys</span>
<span class="linecomment">;;  whenever the minibuffer is active, or at least active for</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Throughout this doc you will see references to such options and</span>
<span class="linecomment">;;  their toggles.  For example: "You can toggle case-sensitivity at</span>
<span class="linecomment">;;  any time using `C-A' (that is, `C-S-a') in the minibuffer."</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The reason for making it so easy to change the values of these</span>
<span class="linecomment">;;  options on the fly is that different kinds of completion, in</span>
<span class="linecomment">;;  different contexts, can take advantage of different option values.</span>
<span class="linecomment">;;  Icicles completion is very general, and a single option value is</span>
<span class="linecomment">;;  not always optimal for all contexts.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You will become acquainted with a few of these toggle keys and</span>
<span class="linecomment">;;  remember them, but you will forget others.  What is important to</span>
<span class="linecomment">;;  point out here is that `C-?'  (`icicle-minibuffer-help') is your</span>
<span class="linecomment">;;  friend in the minibuffer.  During completion, the help it displays</span>
<span class="linecomment">;;  includes, near the top, a list of the toggle keys and the</span>
<span class="linecomment">;;  corresponding current values of their options.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whenever you use an Icicles toggle command, a momentary message</span>
<span class="linecomment">;;  shows you the new option value.  So as an alternative to using</span>
<span class="linecomment">;;  `C-?' to see the current value of an option, you can just toggle</span>
<span class="linecomment">;;  it twice.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Cycle Completion Candidates")</span>
<span class="linecomment">;;  ** Cycle Completion Candidates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   M-x  t o o l  next</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That is, type "tool" and then hit the `next' key, which is often</span>
<span class="linecomment">;;  labeled "Page Down".  Each time you hit `next', another match for</span>
<span class="linecomment">;;  your input (`tool') replaces it in the minibuffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   M-x ediff-toggle-use-toolbar  next</span>
<span class="linecomment">;;   M-x scroll-bar-toolkit-scroll next</span>
<span class="linecomment">;;   M-x tool-bar-mode             next</span>
<span class="linecomment">;;   M-x tooltip-mode              next</span>
<span class="linecomment">;;   M-x ediff-toggle-use-toolbar ; Back to the beginning</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Keys `next' and `prior' ("Page Up") cycle among all of the</span>
<span class="linecomment">;;  commands that contain (match) the minibuffer input - `tool', in</span>
<span class="linecomment">;;  this case.  Just hit `RET' (Return) when you get to the command</span>
<span class="linecomment">;;  you want.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use a regular expression, to narrow the field of matching</span>
<span class="linecomment">;;  inputs:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   M-x  i s e . + c h a r   next</span>
<span class="linecomment">;;   M-x isearch-*-char       next</span>
<span class="linecomment">;;   M-x isearch-delete-char  next</span>
<span class="linecomment">;;   ...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Cycling Completions") for more about cycling completion</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Display Completion Candidates")</span>
<span class="linecomment">;;  ** Display Completion Candidates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can display all of the matches for the current minibuffer</span>
<span class="linecomment">;;  input, in the `*Completions*' buffer, with `S-TAB' (Shift TAB).</span>
<span class="linecomment">;;  So, for instance, `S-TAB' with `M-x ise.+char' in the minibuffer</span>
<span class="linecomment">;;  displays all commands whose names contain `ise' followed</span>
<span class="linecomment">;;  (somewhere) by `char'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (The documentation always refers to the key that does this as</span>
<span class="linecomment">;;  `S-TAB'.  Actually, it is `S-TAB' only by default.  You can</span>
<span class="linecomment">;;  customize it, using option `icicle-apropos-complete-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "*Completions* Display") for more about using the</span>
<span class="linecomment">;;  `*Completions*' window.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Prefix Completion and Apropos Completion")</span>
<span class="linecomment">;;  ** Prefix Completion and Apropos Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can get the standard Emacs "prefix" completion, instead of</span>
<span class="linecomment">;;  this "apropos completion", by using `TAB' instead of `S-TAB'.  You</span>
<span class="linecomment">;;  can cycle prefix-completion candidates by using the `down' and</span>
<span class="linecomment">;;  `up' arrow keys instead of `next' and `prior'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Some people prefer to always cycle with the same keys, for</span>
<span class="linecomment">;;  example, `down' and `up', regardless of the completion mode</span>
<span class="linecomment">;;  (prefix or apropos).  You can get that behavior by customizing</span>
<span class="linecomment">;;  user option `icicle-cycling-respects-completion-mode'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Instead of using `down' or `next', as an alternative you can cycle</span>
<span class="linecomment">;;  candidates downward (forward) by just repeating the same</span>
<span class="linecomment">;;  completion key: `TAB' or `S-TAB'.  For example:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   M-x tool           TAB ; Display candidates with prefix `tool'</span>
<span class="linecomment">;;   M-x tool-bar-mode  TAB</span>
<span class="linecomment">;;   M-x tooltip-mode   TAB</span>
<span class="linecomment">;;   M-x tool-bar-mode      ; Back to the beginning</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Or:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   M-x tool                      S-TAB ; Display matching candidates</span>
<span class="linecomment">;;   M-x ediff-toggle-use-toolbar  S-TAB</span>
<span class="linecomment">;;   M-x scroll-bar-toolkit-scroll S-TAB</span>
<span class="linecomment">;;   M-x tool-bar-mode             S-TAB</span>
<span class="linecomment">;;   M-x tooltip-mode              S-TAB</span>
<span class="linecomment">;;   M-x ediff-toggle-use-toolbar        ; Back to the beginning</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Changing to a different completion key (`TAB' to `S-TAB' or vice</span>
<span class="linecomment">;;  versa) always switches completion type and completes, but you can</span>
<span class="linecomment">;;  then repeat that new completion key to cycle among the candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: In vanilla Emacs, repeating `TAB' scrolls the</span>
<span class="linecomment">;;  `*Completions*' window.  In Icicles, you can use `C-v' to scroll</span>
<span class="linecomment">;;  `*Completions*' down and `M-v' to scroll up.  You can also use the</span>
<span class="linecomment">;;  mouse wheel to scroll.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Apropos Completions") for more about apropos and prefix</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Chains of Simple Match Patterns - Progressive Completion")</span>
<span class="linecomment">;;  ** Chains of Simple Match Patterns - Progressive Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To see which functions contain `char', `delete', and `back' in</span>
<span class="linecomment">;;  their names, in any order:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   C-h f  c h a r  S-TAB - Display all function names that contain</span>
<span class="linecomment">;;   `char'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   M-*  d e l e t e  - Narrow that set of names to those that also</span>
<span class="linecomment">;;   contain `delete'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   M-*  b a c k  - Narrow the set of matching names further, to</span>
<span class="linecomment">;;   those that also contain `back'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This displays a list of functions like this in buffer</span>
<span class="linecomment">;;  `*Completions*' (your list might be somewhat different):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    backward-delete-char        backward-delete-char-untabify</span>
<span class="linecomment">;;    delete-backward-char        icicle-backward-delete-char-untabify</span>
<span class="linecomment">;;    icicle-delete-backward-char</span>
<span class="linecomment">;;    quail-conversion-backward-delete-char</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Since you are completing input to `C-h f', you can then cycle to a</span>
<span class="linecomment">;;  name using `next' and hit `RET', or click `mouse-2', to see the</span>
<span class="linecomment">;;  doc for that function.  If, instead, you were completing input to</span>
<span class="linecomment">;;  `M-x', you could choose a command to execute.  And so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The thing to notice here is that you can use `M-*' to input chains</span>
<span class="linecomment">;;  of multiple simple regexps, to narrow down the set of completion</span>
<span class="linecomment">;;  candidates progressively.  This is analogous to piping the result</span>
<span class="linecomment">;;  of `grep' to another `grep', and piping that result to another</span>
<span class="linecomment">;;  `grep'...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here are a couple others to try (I'm always forgetting the order</span>
<span class="linecomment">;;  in these compound names):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   C-h f  w i n d o w  S-TAB M-*  f r a m e</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   C-h f  w i n d o w  S-TAB M-*  b u f f e r</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a shortcut, you can use just `S-SPC' instead of `S-TAB M-*'.</span>
<span class="linecomment">;;  See (@&gt; "Progressive Completion") for more about progressive</span>
<span class="linecomment">;;  completion with `M-*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Chip Away the Non-Elephant")</span>
<span class="linecomment">;;  ** Chip Away the Non-Elephant **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There's a joke about a sculptor who, when asked how he created</span>
<span class="linecomment">;;  such a life-like statue of an elephant, said that he just chipped</span>
<span class="linecomment">;;  steadily away, removing marble that didn't resemble an elephant.</span>
<span class="linecomment">;;  (Actually, Michelangelo supposedly said something similar.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles lets you sculpt this way too - it is in fact a common</span>
<span class="linecomment">;;  Icicles usage idiom.  There are two ways to say, "I don't want</span>
<span class="linecomment">;;  that" when it comes to possible completions:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The `delete' key or `S-mouse-2' says, "Get rid of this</span>
<span class="linecomment">;;    completion candidate."</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-~' says "I want all possible completions *except* those that</span>
<span class="linecomment">;;    are the current matches."  That is, "Remove all of this, and let</span>
<span class="linecomment">;;    me see what's left."  `C-~' takes the complement of the current</span>
<span class="linecomment">;;    set of matches, using the initial set of possible candidates as</span>
<span class="linecomment">;;    the universe of discourse.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In other words, instead of coming up with input that you want a</span>
<span class="linecomment">;;  completion to match, get rid of one or all of the candidates that</span>
<span class="linecomment">;;  do match.  You can keep clicking `mouse-2' while holding Shift, or</span>
<span class="linecomment">;;  keep hitting `delete' (without Shift), to chip away at the set of</span>
<span class="linecomment">;;  possible completions.  If there are several candidates in a row</span>
<span class="linecomment">;;  that you want to eliminate, just hold down the `delete' key until</span>
<span class="linecomment">;;  they're gone.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So that you can use `delete' this way to delete candidates one</span>
<span class="linecomment">;;  after the other, in order, the next candidate is chosen each time</span>
<span class="linecomment">;;  you delete one.  This means that it becomes the current candidate</span>
<span class="linecomment">;;  in the minibuffer.  You can, however, use `M-k' to clear the</span>
<span class="linecomment">;;  minibuffer or use `C-l' (bound to command</span>
<span class="linecomment">;;  `icicle-retrieve-previous-input') to clear the minibuffer and</span>
<span class="linecomment">;;  retrieve your last real input - see (@&gt; "History Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `delete' works well to delete isolated candidates or groups of</span>
<span class="linecomment">;;  candidates that are in order, one right after the other, and you</span>
<span class="linecomment">;;  can of course combine it with positive matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: In Emacs releases prior to Emacs 22, `delete' has no real</span>
<span class="linecomment">;;  effect on file-name completion candidates (but it works fine on</span>
<span class="linecomment">;;  non file-name candidates).  It removes them temporarily, but they</span>
<span class="linecomment">;;  are not really removed as possible candidates, so `TAB' and</span>
<span class="linecomment">;;  `S-TAB' will still show them as candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-~' is particularly handy in combination with progressive</span>
<span class="linecomment">;;  completion (`M-*') to narrow down a set of candidates, especially</span>
<span class="linecomment">;;  when you are not exactly sure what you are looking for.  You can</span>
<span class="linecomment">;;  repeat `C-~' with different inputs to eliminate everything matched</span>
<span class="linecomment">;;  by each of them.  In other words, this is a variable-size chisel,</span>
<span class="linecomment">;;  and you can use it to remove very large chips.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For instance, suppose you are looking for a standard Emacs command</span>
<span class="linecomment">;;  involving buffers.  You try `M-x buff S-TAB', but that shows</span>
<span class="linecomment">;;  zillions of matches.  Suppose that you know you don't want a</span>
<span class="linecomment">;;  command in some 3rd-party package.  You proceed to eliminate</span>
<span class="linecomment">;;  those, progressively, using something like this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-* ediff C-~ ibuffer C-~ icicle C-~ Buffer-menu C-~ ps- C-~</span>
<span class="linecomment">;;        ido C-~ search-buffers C-~ moccur C-~ swbuff C-~</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And so on.  That is, instead of using `M-*' repeatedly to specify</span>
<span class="linecomment">;;  multiple patterns that candidates must match, you use `C-~'</span>
<span class="linecomment">;;  repeatedly (after an initial `M-*'), to chip away candidates you</span>
<span class="linecomment">;;  don't want.  You could, alternatively, hold down the `delete' key</span>
<span class="linecomment">;;  to eliminate each of these groups of command names.  There are</span>
<span class="linecomment">;;  over 100 commands whose names begin with `ediff', however, so `M-*</span>
<span class="linecomment">;;  C-~' can be quicker in that case.  It can definitely be quicker</span>
<span class="linecomment">;;  when apropos matching is involved.  And you can of course combine</span>
<span class="linecomment">;;  the fine chiseling of `delete' with the variable-size chiseling of</span>
<span class="linecomment">;;  `C-~'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Sets of Completion Candidates") for more about `C-~'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Choose Before You Act")</span>
<span class="linecomment">;;  ** Choose Before You Act **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The opposite operation from chipping away at a set of candidates</span>
<span class="linecomment">;;  to refine it is to build up a set of candidates that you want to</span>
<span class="linecomment">;;  act on.  This too is easy with Icicles.  In some user interfaces,</span>
<span class="linecomment">;;  including Dired in Emacs, you can mark items in a checklist and</span>
<span class="linecomment">;;  then, when you've selected the items you want and verified the</span>
<span class="linecomment">;;  list, act on those that are selected.  You might do this, for</span>
<span class="linecomment">;;  instance, if you were deleting some files.  Icicles lets you</span>
<span class="linecomment">;;  interact with completion candidates this same way.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You do this by building up a saved set of candidates, and then</span>
<span class="linecomment">;;  retrieving these saved candidates later.  You can use the</span>
<span class="linecomment">;;  retrieved candidates just as you would any current set of</span>
<span class="linecomment">;;  candidates.  One of the things you can do is act on all of them,</span>
<span class="linecomment">;;  that is, act on each, in turn.  You do that with `C-!'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Of course, if you can use a regexp to match exactly the candidates</span>
<span class="linecomment">;;  you want to act on, then you need not bother to save and retrieve</span>
<span class="linecomment">;;  them, before acting on them: you can see them all alone in buffer</span>
<span class="linecomment">;;  `*Completions*'.  Here's an exercise in choosing candidates to</span>
<span class="linecomment">;;  save with the mouse in `*Completions*':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  C-x C-f  i c i  TAB - Match all file names that begin with `ici'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Click `mouse-1' inside (or to the left of) `icicles-face.el'.</span>
<span class="linecomment">;;  Click `mouse-3' inside (or to the right of) `icicles-mode.el'.</span>
<span class="linecomment">;;  Click `mouse-3' again, in the same place.</span>
<span class="linecomment">;;  Click `M-S-mouse-2' on each of `icicles.el' and `icicles-cmd.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The candidates that you selected - those between `icicles-face.el'</span>
<span class="linecomment">;;  and `icicles-mode.el', inclusive, plus `icicles.el' and</span>
<span class="linecomment">;;  `icicles-cmd.el', are highlighted specially in buffer</span>
<span class="linecomment">;;  `*Completions*', and feedback in the minibuffer tells you that</span>
<span class="linecomment">;;  they were "saved", which you can also think of as "marked".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Next, use `C-M-&lt;'.  This retrieves the set of saved candidates;</span>
<span class="linecomment">;;  that is, it replaces the current set of candidates with the saved</span>
<span class="linecomment">;;  candidates.  If you now use `C-!', it applies the action to each</span>
<span class="linecomment">;;  candidate.  In this case, the action is to visit the file (`C-x</span>
<span class="linecomment">;;  C-f').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The combination of saving (marking) candidates and then retrieving</span>
<span class="linecomment">;;  only those you have saved is like progressive completion or</span>
<span class="linecomment">;;  chipping away: it is another way of progressively narrowing the</span>
<span class="linecomment">;;  set of candidates that you act on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Choose All Completion Candidates") for more about `C-!'.</span>
<span class="linecomment">;;  See (@&gt; "Sets of Completion Candidates") for more about saving and</span>
<span class="linecomment">;;  retrieving sets of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Help on Completion Candidates")</span>
<span class="linecomment">;;  ** Help on Completion Candidates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sometimes, you'd like to be able to ask for help about individual</span>
<span class="linecomment">;;  completion candidates while you're in the process of choosing one.</span>
<span class="linecomment">;;  That's the purpose of the Icicles `C-M-' key bindings available</span>
<span class="linecomment">;;  during completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The simplest such bindings are `C-M-RET' and `C-M-mouse2'.  They</span>
<span class="linecomment">;;  each do the same thing: provide help on the current candidate.</span>
<span class="linecomment">;;  You can use them during cycling or whenever you've narrowed the</span>
<span class="linecomment">;;  choice down to a single candidate.  You can check this way, before</span>
<span class="linecomment">;;  you execute a command you're unsure of.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During completion, you can also cycle among the doc strings for</span>
<span class="linecomment">;;  the candidates that match your input, using `C-M-down' and</span>
<span class="linecomment">;;  `C-M-up' (for prefix matching), `C-M-next' and `C-M-prior' (for</span>
<span class="linecomment">;;  apropos matching).  This gives you a very useful on-the-fly</span>
<span class="linecomment">;;  apropos feature - use it while you're completing a command, to</span>
<span class="linecomment">;;  check the difference between several possible commands.  Or just</span>
<span class="linecomment">;;  use it to browse doc strings, to learn more about Emacs.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Get Help on Candidates") for more about this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Perform Multiple Operations In One Command")</span>
<span class="linecomment">;;  ** Perform Multiple Operations In One Command **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-x C-f  i c i  TAB - Find a file whose name starts with `ici'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    down (that is, down arrow) ... until you get to icicles-cmd.el</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    RET - Open file icicles-cmd.el.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Nothing new here.  Now try the same thing, but use `C-RET' instead</span>
<span class="linecomment">;;  of `RET'.  The command is not ended, and you can continue to</span>
<span class="linecomment">;;  choose files to open:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-x C-f  i c i  TAB - Find a file whose name starts with `ici'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    down ... until you get to icicles-cmd.el</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-RET - Open file icicles-cmd.el.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    down ... until you get to icicles-opt.el</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-RET - Open file icicles-opt.el.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    down ... until you get to icicles.el</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    RET - Open file icicles.el (end).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You just opened three files in a single command.  Command</span>
<span class="linecomment">;;  `icicle-file' (`C-x C-f') is an Icicles multi-command.  You can</span>
<span class="linecomment">;;  tell if a command is a multi-command when you execute it - if so,</span>
<span class="linecomment">;;  the input prompt is prefixed by `+'.  So, for example, when you</span>
<span class="linecomment">;;  used `C-x C-f', the prompt was "+ File or directory:".  Icicles</span>
<span class="linecomment">;;  menu items that are multi-commands are also prefixed by `+'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to using `down' (or `next') and choosing (acting on)</span>
<span class="linecomment">;;  candidates with `C-RET', you can combine these operations by using</span>
<span class="linecomment">;;  `C-down' (or `C-next'): act on candidates in succession.  And, as</span>
<span class="linecomment">;;  mentioned, you can use `C-!'  to act on all candidates at once.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are many possible uses of multi-commands.  They all make use</span>
<span class="linecomment">;;  of the same key bindings, which begin with `C-'.  These keys are</span>
<span class="linecomment">;;  analogous to the `C-M-' keys that provide help on completion</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Multi-Commands") for more information about Icicles</span>
<span class="linecomment">;;  multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Completion Status Indicators")</span>
<span class="linecomment">;;  ** Completion Status Indicators **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can always know whether completion is possible when you are</span>
<span class="linecomment">;;  inputting text in the minibuffer and, if so, what kind of</span>
<span class="linecomment">;;  completion.  Completion status is indicated in two places: (1) at</span>
<span class="linecomment">;;  the beginning of the minibuffer prompt and (2) in the `Icy'</span>
<span class="linecomment">;;  minor-mode lighter in the mode line.  The second is optional,</span>
<span class="linecomment">;;  controlled by option `icicle-highlight-lighter-flag'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whenever input completion is available, the prompt is prefixed by</span>
<span class="linecomment">;;  `.' or `+', indicating simple or multi-command completion,</span>
<span class="linecomment">;;  respectively.  If completion is strict (your input must match one</span>
<span class="linecomment">;;  of the candidates), then this character is enclosed in a box.  If</span>
<span class="linecomment">;;  completion is lax (permissive), there is no box.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The `Icy' minor-mode lighter text is highlighted red during</span>
<span class="linecomment">;;  completion.  `+' is added to the lighter (`Icy+') for</span>
<span class="linecomment">;;  multi-command completion, and the lighter is boxed for strict</span>
<span class="linecomment">;;  completion.  When minibuffer input is read without completion, the</span>
<span class="linecomment">;;  lighter is not highlighted in any way.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, the lighter text (with or without `+') is `Icy' if</span>
<span class="linecomment">;;  completion is case-sensitive and `ICY' if not.  You can toggle</span>
<span class="linecomment">;;  case-sensitivity at any time using `C-A' (that is, `C-S-a') in the</span>
<span class="linecomment">;;  minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The faces used for this highlighting in the minibuffer and the</span>
<span class="linecomment">;;  mode line are `icicle-completion',</span>
<span class="linecomment">;;  `icicle-multi-command-completion', and</span>
<span class="linecomment">;;  `icicle-mustmatch-completion'.  Consult their doc strings for more</span>
<span class="linecomment">;;  information.  These faces are combined to produce the various</span>
<span class="linecomment">;;  highlighting effects - keep that in mind if you customize them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you are inputting, keep an eye out for this highlighting.  If</span>
<span class="linecomment">;;  you don't see it when you are prompted for input, it means that</span>
<span class="linecomment">;;  input completion is not available.  This in turn means that</span>
<span class="linecomment">;;  `S-TAB' is available, not for input completion, but for key</span>
<span class="linecomment">;;  completion - see (@&gt; "Key Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicles Search")</span>
<span class="linecomment">;;  ** Icicles Search **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles provides a unique way of searching incrementally.  Command</span>
<span class="linecomment">;;  `icicle-search' (`C-c `') is a multi-command.  In this case, the</span>
<span class="linecomment">;;  completion candidates are the buffer occurrences that match a</span>
<span class="linecomment">;;  regexp that you input.  `C-RET' visits a search-hit candidate, and</span>
<span class="linecomment">;;  `C-next' visits a candidate and prepares to visit the next in</span>
<span class="linecomment">;;  succession.  If you visit file `icicles-doc1.el', which contains</span>
<span class="linecomment">;;  the text you are reading now, do this in that buffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-c `</span>
<span class="linecomment">;;    Find (regexp): . * r e c u r s i v e . *  RET - Search for the</span>
<span class="linecomment">;;    regexp `.*recursive.*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Choose an occurrence: S-TAB - Show the search hits, in buffer</span>
<span class="linecomment">;;    `*Completions*' (optional).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-next ... - Cycle among the search hits, navigating to them in</span>
<span class="linecomment">;;    turn.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    S-TAB next ... - Cycle among the search hits without navigating.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    next ... C-RET next ... C-RET - Cycle to particular hits and</span>
<span class="linecomment">;;    visit (only) those hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    next ... RET - Cycle to a hit and stay there (end).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-c `</span>
<span class="linecomment">;;    Find (regexp): M-p RET - Search again for `.*recursive.*'</span>
<span class="linecomment">;;    (input history).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    S-TAB e d i t C-next ... - Search for the substring `edit'</span>
<span class="linecomment">;;    within all search hits for `.*recursive.*'.  Cycle among the</span>
<span class="linecomment">;;    matches.  The substring `edit' is highlighted inside the</span>
<span class="linecomment">;;    (differently) highlighted `.*recursive.*' hits.  Whatever you</span>
<span class="linecomment">;;    type filters the initial set of hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-k - Empty the minibuffer, then S-TAB.  All `.*recursive.*'</span>
<span class="linecomment">;;    hits are restored as candidates.  Again, whatever your input is</span>
<span class="linecomment">;;    (nothing, now), the set of candidates is dynamically updated to</span>
<span class="linecomment">;;    match it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    t \ w + n S-TAB C-next ... - Search for matches of the regexp</span>
<span class="linecomment">;;    `t\w+n' within all search hits for `.*recursive.*' - that is,</span>
<span class="linecomment">;;    `t' followed by at least one other word character, followed by</span>
<span class="linecomment">;;    `n'.  Whatever the regexp `t\w+n' matches (`thin', `then',</span>
<span class="linecomment">;;    `traighten', `tion') is highlighted inside each candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    RET - Stop searching at the current candidate (end).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Now try the same thing, but first use `C-^' in the minibuffer</span>
<span class="linecomment">;;  (e.g. after you enter `.*recursive.*').  That toggles an Icicles</span>
<span class="linecomment">;;  search option for highlighting your input matches.  The behavior</span>
<span class="linecomment">;;  is the same as before, except that all matches to your input are</span>
<span class="linecomment">;;  highlighted at once, not just the current match.  And not only the</span>
<span class="linecomment">;;  exact match is highlighted, but the longest common match among all</span>
<span class="linecomment">;;  input matches is highlighted: If your input is `edi', then `edi'</span>
<span class="linecomment">;;  is highlighted (there is no longer common match), but if you input</span>
<span class="linecomment">;;  the four characters `e d i t', then ``abort-recursive-edit'' is</span>
<span class="linecomment">;;  highlighted.  You can use `C-^' at any time during searching to</span>
<span class="linecomment">;;  change the highlighting behavior.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Now try the same thing, but first select some text.  The search is</span>
<span class="linecomment">;;  confined to the active region (selection) instead of the entire</span>
<span class="linecomment">;;  buffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Now try the same thing (without a region), but use a negative</span>
<span class="linecomment">;;  prefix argument such as `C--' with `C-c `'.  This time, after you</span>
<span class="linecomment">;;  input the regexp to search for, you are prompted for one or more</span>
<span class="linecomment">;;  files to search.  This too is multi-command input: you can input</span>
<span class="linecomment">;;  any number of file names, using completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-- C-c `</span>
<span class="linecomment">;;    Find (regexp): . * r e c u r s i v e . *  RET - Search for the</span>
<span class="linecomment">;;    regexp `.*recursive.*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Choose file (`RET' when done): i c i TAB - Choose among file</span>
<span class="linecomment">;;    candidates that begin with `ici' (shown in `*Completions*').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-! - Choose all matching file names: icicles-cmd.el,</span>
<span class="linecomment">;;    icicles-doc1.el, icicles-doc2.el, icicles-face.el,</span>
<span class="linecomment">;;    icicles-fn.el, icicles-mac.el, icicles-mcmd.el, icicles-mode.el,</span>
<span class="linecomment">;;    icicles-opt.el, icicles-var.el, and icicles.el.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Choose an occurrence: S-TAB - Show the hits in buffer</span>
<span class="linecomment">;;    `*Completions*' (optional).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-next ... - Cycle among the search hits in all chosen</span>
<span class="linecomment">;;    files...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just as you can choose particular search hits to visit, using</span>
<span class="linecomment">;;  `C-RET', so you can use `C-RET' to choose particular files (whose</span>
<span class="linecomment">;;  names match the input, e.g. ici) to search.  Just as you can visit</span>
<span class="linecomment">;;  search hits in order, using `C-next' (or `C-down'), so you can use</span>
<span class="linecomment">;;  `C-next' (or `C-down') to choose files to visit, one after the</span>
<span class="linecomment">;;  other.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you input the initial regexp (`.*recursive.*' in the example</span>
<span class="linecomment">;;  above) to `icicle-search', you can use completion to retrieve a</span>
<span class="linecomment">;;  regexp that you entered previously.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `C-`' in the minibuffer to toggle escaping of regexp</span>
<span class="linecomment">;;  special characters.  Use that if you want to find a literal string</span>
<span class="linecomment">;;  - for example, if you want to search for the string `form.' and</span>
<span class="linecomment">;;  not text that matches the regexp `form.' (`for' followed by any</span>
<span class="linecomment">;;  character except newline).  If you use `C-`' during Icicles</span>
<span class="linecomment">;;  search, start the search over again for the toggle to take effect.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to Icicles search (which is also incremental), Icicles</span>
<span class="linecomment">;;  offers some enhancements to the standard Emacs incremental search,</span>
<span class="linecomment">;;  Isearch:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can reuse a previous Isearch search string, choosing it</span>
<span class="linecomment">;;    using Icicles completion.  Hit `M-o' during Isearch, type some</span>
<span class="linecomment">;;    input to complete against the search history, and hit `RET' or</span>
<span class="linecomment">;;    click `mouse-2' to choose a string and continue Isearch with it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can start Icicles search from Isearch.  The current Isearch</span>
<span class="linecomment">;;    search string becomes the starting point for the Icicles search</span>
<span class="linecomment">;;    regexp.  You can edit it or type something different.  And you</span>
<span class="linecomment">;;    can complete what you type against the Isearch regexp history.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;    for more about searching with Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Expanded-Common-Match Completion") for more about Icicles</span>
<span class="linecomment">;;    expansion of your input to a common match among all candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Isearch Enhancements")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@* "Using Completion to Insert Previous Inputs: `M-o'") for</span>
<span class="linecomment">;;    more about `M-o' - you can use it anywhere to complete against</span>
<span class="linecomment">;;    previous inputs.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Complete Key Sequences Too")</span>
<span class="linecomment">;;  ** Complete Key Sequences Too **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Try `S-TAB' at the top level (without first invoking a command</span>
<span class="linecomment">;;  that reads input).  Icicles presents all of the possible keys and</span>
<span class="linecomment">;;  their bindings in the current context - for completion.  For</span>
<span class="linecomment">;;  example, if you are in Dired mode, the completion candidates</span>
<span class="linecomment">;;  include all key sequences in the global map and the Dired-mode map</span>
<span class="linecomment">;;  (and any current minor-mode maps, such as Icicle mode).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (The documentation always refers to the key that performs key</span>
<span class="linecomment">;;  completion as `S-TAB'.  Actually, it is `S-TAB' only by default.</span>
<span class="linecomment">;;  You can customize it, using option `icicle-key-complete-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can then type part of a key name or a command name, and hit</span>
<span class="linecomment">;;  `S-TAB' again to apropos-complete your input.  You can navigate</span>
<span class="linecomment">;;  down the key-sequence hierarchy by completing a key sequence piece</span>
<span class="linecomment">;;  by piece:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    S-TAB to see the available keys at top level</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Click (using `mouse-2') candidate `C-x  =  ...', to see the keys</span>
<span class="linecomment">;;    that start with `C-x'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Click `r  =  ...', to see the keys that start with `C-x r'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Click `b  =  bookmark-jump', to invoke that command and visit a</span>
<span class="linecomment">;;    bookmark</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whenever you're completing a prefix key, such as `C-x', you can</span>
<span class="linecomment">;;  click `..' to navigate back up the key-sequence hierarchy.  For</span>
<span class="linecomment">;;  instance, if you are completing `C-x p', click `..' to go back to</span>
<span class="linecomment">;;  completing `C-x', and then click `..' to go back to the top level.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The available keys at any level include the following important</span>
<span class="linecomment">;;  keys, which means that you can use Icicles key completion to do</span>
<span class="linecomment">;;  almost anything in Emacs:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `M-x' - Execute an arbitrary command.</span>
<span class="linecomment">;;    `M-x' is treated as `ESC-x', so complete first `ESC  =  ...',</span>
<span class="linecomment">;;    then `x = icicle-execute-extended-command'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `M-:' - Evaluate any Emacs-Lisp expression.</span>
<span class="linecomment">;;    If command remapping is available (Emacs 22 or later), and if</span>
<span class="linecomment">;;    option `icicle-top-level-key-bindings' remaps `eval-expression'</span>
<span class="linecomment">;;    to `icicle-pp-eval-expression' (which it does, by default), then</span>
<span class="linecomment">;;    complete first `remapped  =  ...', then `eval-expression  =</span>
<span class="linecomment">;;    icicle-pp-eval-expression'.  Otherwise, complete first `ESC  =</span>
<span class="linecomment">;;    ...', then `:  =  eval-expression'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    In Icicles, `M-:' gives you a quick pop-up mode for evaluating a</span>
<span class="linecomment">;;    Lisp sexp.  Most of the normal Emacs-Lisp mode bindings are in</span>
<span class="linecomment">;;    effect, except that `RET' evaluates the minibuffer contents and</span>
<span class="linecomment">;;    pretty-prints the result.  You can also use it with a prefix arg</span>
<span class="linecomment">;;    (`C-u M-:') to insert the result of such an on-the-fly Lisp</span>
<span class="linecomment">;;    evaluation into the current buffer (including the minibuffer).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `menu-bar  =  ...' - Invoke any menu-bar menu.</span>
<span class="linecomment">;;    Continue completing, to navigate the entire menu hierarchy.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can start directly with a key prefix, and then hit `S-TAB' to</span>
<span class="linecomment">;;  complete it - you need not start with `S-TAB'.  You can use</span>
<span class="linecomment">;;  Icicles key completion to learn key bindings - `C-M-mouse-2'</span>
<span class="linecomment">;;  displays help on any key.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Instead of clicking a completion candidate with `mouse-2', you can</span>
<span class="linecomment">;;  of course type part of the key name or command name, and then</span>
<span class="linecomment">;;  complete the name and enter it.  Gotcha: `S-TAB' uses apropos</span>
<span class="linecomment">;;  completion, by default, so remember that typing `.' matches any</span>
<span class="linecomment">;;  character (except a newline).  To match only `..', either use</span>
<span class="linecomment">;;  prefix completion (`TAB') or escape the regexp special character:</span>
<span class="linecomment">;;  `\.\.' (or use `^\.').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Key Completion") for more about Icicles key completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Available for Almost Any Input")</span>
<span class="linecomment">;;  ** Available for Almost Any Input **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  All of this works not only for the input of commands, with `M-x',</span>
<span class="linecomment">;;  but for the input of nearly anything.  For instance, you can use</span>
<span class="linecomment">;;  `C-x b' (`switch-to-buffer') and cycle among buffer names.  Or use</span>
<span class="linecomment">;;  `C-h v' (`describe-variable') and cycle among variable names.  It</span>
<span class="linecomment">;;  works whenever a command reads input with completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whenever you're in Icicle mode, you see "Icy" in the mode-line.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Component Icicles Libraries")</span>
<span class="linecomment">;;  ** Component Icicles Libraries **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles is composed of the following libraries.  When you load the</span>
<span class="linecomment">;;  driver library, `icicles.el', the others are all loaded</span>
<span class="linecomment">;;  automatically .</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `icicles.el'      - driver library</span>
<span class="linecomment">;;    `icicles-doc1.el' - first part of the doc (this!)</span>
<span class="linecomment">;;    `icicles-doc2.el' - second part of the doc</span>
<span class="linecomment">;;    `icicles-cmd.el'  - top-level commands</span>
<span class="linecomment">;;    `icicles-face.el' - faces</span>
<span class="linecomment">;;    `icicles-fn.el'   - non-interactive functions</span>
<span class="linecomment">;;    `icicles-mac.el'  - macros</span>
<span class="linecomment">;;    `icicles-mcmd.el' - minibuffer commands</span>
<span class="linecomment">;;    `icicles-mode.el' - Icicle mode definition</span>
<span class="linecomment">;;    `icicles-opt.el'  - user options (variables)</span>
<span class="linecomment">;;    `icicles-var.el'  - internal variables</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Libraries `icicles-doc1.el' and `icicles-doc2.el' are not really</span>
<span class="linecomment">;;  libraries.  They contain only comments, with the Icicles doc.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Library `lacarte.el' is not part of Icicles, but it is especially</span>
<span class="linecomment">;;  useful when used with Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "If You Are an Emacs-Lisp Programmer")</span>
<span class="linecomment">;;  ** If You Are an Emacs-Lisp Programmer **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you are an Emacs-Lisp programmer, this is the no-brainer,</span>
<span class="linecomment">;;  nutshell view of how to take advantage of Icicles in your own code</span>
<span class="linecomment">;;  that calls `completing-read' or `read-file-name':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Add this line to your library: (require 'icicles nil t)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That's really all you need to do.  And there is no consequence if</span>
<span class="linecomment">;;  users don't have Icicles (no load error is raised, because of the</span>
<span class="linecomment">;;  non-nil third argument).  In other words, there is no reason not</span>
<span class="linecomment">;;  to add this soft `require', unless your library somehow conflicts</span>
<span class="linecomment">;;  with Icicles features.  (Even then, users will not be affected</span>
<span class="linecomment">;;  unless they turn on Icicle mode.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For more (and there is a lot more), read on...</span>
 
<span class="linecomment">;;(@* "Inserting Text Found Near the Cursor")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Inserting Text Found Near the Cursor</span>
<span class="linecomment">;;  ------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Most of Icicles is about completing text that you type in the</span>
<span class="linecomment">;;  minibuffer against some set of possible completion candidates.</span>
<span class="linecomment">;;  This feature is not.  It is related only in the sense that it is</span>
<span class="linecomment">;;  also about inputting text that is already available elsewhere.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Some Emacs commands provide, as the default value for minibuffer</span>
<span class="linecomment">;;  input, a word or other text at the cursor position (aka "point").</span>
<span class="linecomment">;;  You can insert this default value in the minibuffer with `M-n'.</span>
<span class="linecomment">;;  Icicles option `icicle-default-value' can be used to automatically</span>
<span class="linecomment">;;  insert the default value into the minibuffer as an initial value,</span>
<span class="linecomment">;;  if you prefer that optional behavior (I do; many people do not).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sometimes you would like to use the text at the cursor, but the</span>
<span class="linecomment">;;  command asking for input does not let you retrieve that text as</span>
<span class="linecomment">;;  the default value.  For example, if the text at point is a file</span>
<span class="linecomment">;;  name, you might like to use it with `C-x C-f' to open that file.</span>
<span class="linecomment">;;  Or, if the text is a URL, you might want to visit it using a Web</span>
<span class="linecomment">;;  browser.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Some Emacs-Lisp libraries, such as `ffap.el', have as their</span>
<span class="linecomment">;;  specific purpose to help you do this.  "Ffap" stands for</span>
<span class="linecomment">;;  `find-file-at-point', the main command in that library.  It tries</span>
<span class="linecomment">;;  to interpret the text at point and "do the right thing" with it:</span>
<span class="linecomment">;;  visit a file, open a URL in a Web browser, and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you like, you can use library `ffap.el' with Icicles.  All</span>
<span class="linecomment">;;  Icicles features are then available during file-name and URL</span>
<span class="linecomment">;;  completion.  And if you like `ffap.el', you might also like to try</span>
<span class="linecomment">;;  my extension library `ffap-.el'.  However, if you use ffap with</span>
<span class="linecomment">;;  Icicles, you might not want to use the ffap key bindings,</span>
<span class="linecomment">;;  preferring the Icicles bindings or the standard Emacs bindings for</span>
<span class="linecomment">;;  keys such as `C-x C-f'.  (In that case, do not call function</span>
<span class="linecomment">;;  `ffap-bindings'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles provides a couple of simple ways to take advantage of</span>
<span class="linecomment">;;  `ffap-guesser', which is the ffap function that guesses which</span>
<span class="linecomment">;;  string at the cursor position you want to grab, without</span>
<span class="linecomment">;;  sacrificing any key bindings to ffap.  One way is to use `M-.'</span>
<span class="linecomment">;;  (command `icicle-insert-string-at-point') at any time in the</span>
<span class="linecomment">;;  minibuffer.  It grabs text at or near the cursor and yanks it into</span>
<span class="linecomment">;;  the minibuffer.  By default, the text it grabs is whatever</span>
<span class="linecomment">;;  `ffap-guesser' guesses.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another way is to use one of the proxy completion candidates</span>
<span class="linecomment">;;  `*point file name*' or `*mouse-2 file name*' whenever Emacs asks</span>
<span class="linecomment">;;  you to input a file name (provided option</span>
<span class="linecomment">;;  `icicle-add-proxy-candidates-flag' is non-nil - toggle with</span>
<span class="linecomment">;;  `C-M-_').  The former picks up the file name at point, just like</span>
<span class="linecomment">;;  `M-.'.  The latter lets you click a file name anywhere with</span>
<span class="linecomment">;;  `mouse-2' to pick up the name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Using `M-.' or a proxy candidate on demand, instead of binding</span>
<span class="linecomment">;;  keys to ffap commands, lets you control which buffer text you use</span>
<span class="linecomment">;;  as minibuffer input and how that text should be interpreted (file</span>
<span class="linecomment">;;  name, URL, and so on).  By default, `M-.' uses `ffap-guesser', but</span>
<span class="linecomment">;;  you can change this by customizing user option</span>
<span class="linecomment">;;  `icicle-thing-at-point-functions'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Actually, `M-.' acts differently if you use it successively.</span>
<span class="linecomment">;;  Successive uses of `M-.' grab and insert either 1) alternative</span>
<span class="linecomment">;;  bits of text (different text "things") or 2) successive bits of</span>
<span class="linecomment">;;  text.  The default behavior is #1, but you can change this choice</span>
<span class="linecomment">;;  by customizing option `icicle-default-thing-insertion' (setting it</span>
<span class="linecomment">;;  to `more-of-the-same', instead of `alternatives').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an example of grabbing successive bits of text (#2), suppose</span>
<span class="linecomment">;;  that the cursor is at the beginning of the word "use" in the</span>
<span class="linecomment">;;  previous paragraph.  Then, during minibuffer input, suppose that</span>
<span class="linecomment">;;  you use `M-. M-. M-.'.  Each time you hit `M-.', another word is</span>
<span class="linecomment">;;  inserted in the minibuffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    use</span>
<span class="linecomment">;;    use it</span>
<span class="linecomment">;;    use it successively</span>
<span class="linecomment">;;    ...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The rest of this section is a bit technical, so you might want to</span>
<span class="linecomment">;;  skip it if you are reading the Icicles doc for the first time.  It</span>
<span class="linecomment">;;  details the behavior and definitions of options</span>
<span class="linecomment">;;  `icicle-default-thing-insertion' and</span>
<span class="linecomment">;;  `icicle-thing-at-point-functions', and how to temporarily override</span>
<span class="linecomment">;;  those settings interactively.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Option `icicle-thing-at-point-functions' controls which text at or</span>
<span class="linecomment">;;  near the cursor `M-.' inserts into the minibuffer.  It is a cons</span>
<span class="linecomment">;;  cell, that is, an ordered pair:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The car (first part) is a list of functions that grab different</span>
<span class="linecomment">;;    kinds of strings at or near point (#1, above).  Any number of</span>
<span class="linecomment">;;    functions can be used.  They are used in sequence by `M-.'.  By</span>
<span class="linecomment">;;    default, there are four functions, which alternately grab:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    1) whatever `ffap-guesser' returns (e.g. file name at point)</span>
<span class="linecomment">;;    2) the symbol or file name at point</span>
<span class="linecomment">;;    3) the word at point</span>
<span class="linecomment">;;    4) the URL at point</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The cdr (second part) is a function that advances point one text</span>
<span class="linecomment">;;    thing (#2, above).  Each time command `M-.' is used</span>
<span class="linecomment">;;    successively, this is called to grab more things of text (of the</span>
<span class="linecomment">;;    same kind).  The default function grabs successive words.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If either the car or cdr is empty, then the other alone determines</span>
<span class="linecomment">;;  the behavior of `M-.'.  Otherwise, option</span>
<span class="linecomment">;;  `icicle-default-thing-insertion' determines whether the car or the</span>
<span class="linecomment">;;  cdr is used by `M-.'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, if the value of `icicle-default-thing-insertion' is</span>
<span class="linecomment">;;  `alternatives' (the default value), then repeated use of `M-.'</span>
<span class="linecomment">;;  inserts a different kind of thing at point: ffap guess, file name,</span>
<span class="linecomment">;;  word, or URL.  If you set `icicle-default-thing-insertion' to</span>
<span class="linecomment">;;  `more-of-the-same', then repeated use of `M-.' inserts successive</span>
<span class="linecomment">;;  words into the minibuffer, as shown in the example above.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You need not make a final choice once and for all between</span>
<span class="linecomment">;;  `alternatives' and `more-of-the-same'.  You can also make an</span>
<span class="linecomment">;;  interactive choice by using a prefix argument (`C-u') at any time</span>
<span class="linecomment">;;  to override the value of `icicle-default-thing-insertion'.  If you</span>
<span class="linecomment">;;  use plain `C-u', then `M-.' inserts alternative strings.  If you</span>
<span class="linecomment">;;  use a numeric prefix argument N (not just plain `C-u'), then it is</span>
<span class="linecomment">;;  the same as using `M-.' N times with `more-of-the-same' as the</span>
<span class="linecomment">;;  value of `icicle-default-thing-insertion'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And, if the numeric argument is negative, then text is grabbed to</span>
<span class="linecomment">;;  the left of the cursor, instead of to the right.  In the example</span>
<span class="linecomment">;;  above, if you used `M-- M-. M-. M-.', then the successive</span>
<span class="linecomment">;;  insertions would be as follows:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  differently</span>
<span class="linecomment">;;  differently if</span>
<span class="linecomment">;;  differently if you</span>
<span class="linecomment">;;  ...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you used `M--3 M-.', then you would immediately insert</span>
<span class="linecomment">;;  `differently if you'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In the case of `alternatives', there are four possibilities, by</span>
<span class="linecomment">;;  default.  The first function in the list is `ffap-guesser'.  The</span>
<span class="linecomment">;;  second function grabs text that has the syntax of an Emacs-Lisp</span>
<span class="linecomment">;;  symbol name, which in practice can also be a file name or a URL -</span>
<span class="linecomment">;;  it can include characters such as -, /, +, ., :, @, and _.  The</span>
<span class="linecomment">;;  third function grabs a word, which includes letters, ' and -.  The</span>
<span class="linecomment">;;  fourth function grabs a URL, adding prefix "http://" if needed.</span>
<span class="linecomment">;;  These are the functions used by default, but you can add to them</span>
<span class="linecomment">;;  or replace them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use my library `thingatpt+.el', then the cursor need not be</span>
<span class="linecomment">;;  exactly on the text for the second and third alternatives - the</span>
<span class="linecomment">;;  symbol or word *nearest* the cursor is grabbed.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Inserting a Regexp from a Variable") for information on</span>
<span class="linecomment">;;    inserting a variable's string value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Moving Between the Minibuffer and Other Buffers") for</span>
<span class="linecomment">;;    another way to insert buffer text in the minibuffer.</span>
 
<span class="linecomment">;;(@* "Background on Vanilla Emacs Input Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Background on Vanilla Emacs Input Completion</span>
<span class="linecomment">;;  --------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section reviews standard Emacs behavior regarding input</span>
<span class="linecomment">;;  completion.  It does not describe any Icicles completion features.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you are prompted in the minibuffer to enter something, you</span>
<span class="linecomment">;;  are sometimes presented with a default value.  This might be</span>
<span class="linecomment">;;  automatically inserted after the prompt, initially.  If not, you</span>
<span class="linecomment">;;  can retrieve the default value yourself, using `M-n' (Emacs 21 or</span>
<span class="linecomment">;;  later).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Often, there is more than one reasonable default value that might</span>
<span class="linecomment">;;  make sense.  Depending on what you're being asked to enter, these</span>
<span class="linecomment">;;  "candidate default values" might be command names, buffer names,</span>
<span class="linecomment">;;  existing file names, variable names, and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For most Emacs functions that prompt you for input, the person who</span>
<span class="linecomment">;;  wrote the function decided on the reasonable set of default</span>
<span class="linecomment">;;  values, and passed these to an "input-completing function" such as</span>
<span class="linecomment">;;  `completing-read' or `read-file-name', which prompts you and reads</span>
<span class="linecomment">;;  your input.  The programmer also decided whether you will be</span>
<span class="linecomment">;;  *required* to pick one of the default values or you will be free</span>
<span class="linecomment">;;  to enter something else.  The programmer might also have told the</span>
<span class="linecomment">;;  input-completing function to require that your input pass some</span>
<span class="linecomment">;;  special test (predicate).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Be aware that standard Emacs terminology does not refer to such a</span>
<span class="linecomment">;;  set of default values as "default values"; they are called</span>
<span class="linecomment">;;  "completions".  By "default value", standard Emacs terminology</span>
<span class="linecomment">;;  means only the single value that you can access via `M-n'.</span>
<span class="linecomment">;;  Icicles refers to all such potential inputs indifferently as</span>
<span class="linecomment">;;  "default values", "completions", "completion candidates", and</span>
<span class="linecomment">;;  "candidates".  Whenever completion is not requiring you to pick</span>
<span class="linecomment">;;  one of the available candidates, they are effectively only default</span>
<span class="linecomment">;;  choices.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So, how do you get access to the default values that the</span>
<span class="linecomment">;;  programmer has made available to you, in order to choose one?  You</span>
<span class="linecomment">;;  hit certain keys to complete the current contents of the</span>
<span class="linecomment">;;  minibuffer (excluding the prompt).  This current, partial input is</span>
<span class="linecomment">;;  considered as a prefix of one of the default values, and it is</span>
<span class="linecomment">;;  completed in the minibuffer to the entire default value</span>
<span class="linecomment">;;  (completion).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Keys `TAB', `RET' (Return), and `SPC' (Space) perform different</span>
<span class="linecomment">;;  degrees of this "prefix completion" in standard Emacs.  If you</span>
<span class="linecomment">;;  type a prefix of one of the available default values, you can</span>
<span class="linecomment">;;  complete the value this way in the minibuffer, and then enter</span>
<span class="linecomment">;;  (commit) it, using `RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But if your partial input matches the prefix of more than one</span>
<span class="linecomment">;;  default value, then completion pops up the list of all matching</span>
<span class="linecomment">;;  completions for you to choose from (in buffer `*Completions*').</span>
<span class="linecomment">;;  You choose a candidate by clicking it with `mouse-2' or placing</span>
<span class="linecomment">;;  the cursor on it and hitting `RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because this is the way you access the default values supplied to</span>
<span class="linecomment">;;  an input-completing function, I call those values</span>
<span class="linecomment">;;  "prefix-completion candidates".  If there is no partial input yet</span>
<span class="linecomment">;;  (empty minibuffer), then the entire list of default values</span>
<span class="linecomment">;;  supplied to the input-completing function appears in the pop-up</span>
<span class="linecomment">;;  `*Completions*' buffer.  See the Emacs manual (`C-h i') for more</span>
<span class="linecomment">;;  on this general mechanism of prefix completion (called simply</span>
<span class="linecomment">;;  "completion" there).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Calls to `completing-read' and `read-file-name' are not the only</span>
<span class="linecomment">;;  places where input completion is used.  When you use `M-x'</span>
<span class="linecomment">;;  (command `execute-extended-command'), completion is also</span>
<span class="linecomment">;;  available.</span>
 
<span class="linecomment">;;(@* "Cycling Completions")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Cycling Completions</span>
<span class="linecomment">;;  -------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles lets you use the `up' and `down' arrow keys to cycle</span>
<span class="linecomment">;;  through the list of candidate prefix completions that match</span>
<span class="linecomment">;;  whatever input is present in the minibuffer (or all candidate</span>
<span class="linecomment">;;  completions, if there is no input in the minibuffer).  In the</span>
<span class="linecomment">;;  minibuffer, each candidate replaces your partial input, in turn,</span>
<span class="linecomment">;;  when you cycle.  The prefix (root) that was completed is</span>
<span class="linecomment">;;  underlined in the minibuffer completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an alternative to using `down' to cycle forward, you can hit</span>
<span class="linecomment">;;  `TAB' repeatedly.</span>
<span class="linecomment">;;  See (@&gt; "Prefix Completion and Apropos Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Suppose you use `C-x b' (command `switch-to-buffer').  You can</span>
<span class="linecomment">;;  then use `down' until the right buffer name appears in the</span>
<span class="linecomment">;;  minibuffer, then hit `RET'.  Or you can type some text that begins</span>
<span class="linecomment">;;  one or more of the buffer names, and then use `down' to cycle</span>
<span class="linecomment">;;  among those names that match that prefix.  If there are many</span>
<span class="linecomment">;;  candidates, typing part of the name to narrow the field can save</span>
<span class="linecomment">;;  time.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another example: Suppose you use `C-h v' (`describe-variable') and</span>
<span class="linecomment">;;  type `cal'.  Use `down' to cycle among all variables that start</span>
<span class="linecomment">;;  with `cal', until you find the one you want (then hit `RET').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In other words, the current partial input in the minibuffer</span>
<span class="linecomment">;;  determines a matching set of default values, and those are the</span>
<span class="linecomment">;;  values that you can cycle through.  You can at any time erase or</span>
<span class="linecomment">;;  change the partial input - the list of matching candidates</span>
<span class="linecomment">;;  automatically reflects the change.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This also means that it's good to have a quick way to clear the</span>
<span class="linecomment">;;  minibuffer of any input, so Icicles also provides minibuffer key</span>
<span class="linecomment">;;  binding `M-k' to do that.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A visible and audible signal lets you know when you have reached</span>
<span class="linecomment">;;  one end of the list of completion candidates, but you can of</span>
<span class="linecomment">;;  course continue to cycle, wrapping around.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If the completion candidates are already displayed in buffer</span>
<span class="linecomment">;;  `*Completions*' when you try to cycle among them (because you hit</span>
<span class="linecomment">;;  `TAB'), then the current candidate is highlighted in</span>
<span class="linecomment">;;  `*Completions*' as you access it in the minibuffer with the `up'</span>
<span class="linecomment">;;  and `down' arrow keys.  If you change the minibuffer input, then</span>
<span class="linecomment">;;  the `*Completions*' list is updated accordingly, to reflect the</span>
<span class="linecomment">;;  new set of matching candidates.  The root that was completed (the</span>
<span class="linecomment">;;  minibuffer input) is highlighted in each candidate of the</span>
<span class="linecomment">;;  `*Completions*' display.  The `*Completions*' window is</span>
<span class="linecomment">;;  automatically scrolled as needed, to show the current candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Don't become a cycling drone!  Input some text to narrow the set</span>
<span class="linecomment">;;  of candidates, before cycling among them to choose one.  This is a</span>
<span class="linecomment">;;  good habit to adopt, generally, in Icicles.  Most of the power of</span>
<span class="linecomment">;;  Icicles comes in your ability to filter a set of candidates.  This</span>
<span class="linecomment">;;  is especially true when it comes to regexp filtering (see</span>
<span class="linecomment">;;  (@&gt; "Apropos Completions")).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Cycling and filtering work hand in hand.  If the set of candidates</span>
<span class="linecomment">;;  is small to begin with, then just cycling might be quick enough -</span>
<span class="linecomment">;;  that is the case if you move among a small set of buffers, for</span>
<span class="linecomment">;;  instance.  But with Icicles you can profitably use cycling on even</span>
<span class="linecomment">;;  a very large set of candidates - by filtering the set first.  The</span>
<span class="linecomment">;;  reason this is not very practical with vanilla Emacs is that</span>
<span class="linecomment">;;  filtering by a prefix only is not very potent.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Tip: Whenever you type or delete text in the minibuffer, your</span>
<span class="linecomment">;;  partial input is remembered.  When you cycle completion</span>
<span class="linecomment">;;  candidates, your input is replaced by each candidate, but you can</span>
<span class="linecomment">;;  at any time refresh the minibuffer to retrieve what you last</span>
<span class="linecomment">;;  typed.  You do this with `C-l', which is bound in the minibuffer</span>
<span class="linecomment">;;  to command `icicle-retrieve-previous-input'.  Editing a completion</span>
<span class="linecomment">;;  candidate that you have cycled into the minibuffer counts as</span>
<span class="linecomment">;;  input.  Editing tells Icicles to remember what is in the</span>
<span class="linecomment">;;  minibuffer as your last real input.  If you want to replace the</span>
<span class="linecomment">;;  candidate and go back to editing the input you had already typed</span>
<span class="linecomment">;;  before cycling, then use `C-l' - don't just delete characters from</span>
<span class="linecomment">;;  the candidate.  See (@&gt; "History Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can change the keys that are bound to completion-candidate</span>
<span class="linecomment">;;  cycling.  And if you prefer to use the same key for cycling both</span>
<span class="linecomment">;;  apropos matches and prefix matches, then you can customize option</span>
<span class="linecomment">;;  `icicle-cycling-respects-completion-mode'.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc2.el" :to "Customizing Key Bindings").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you are an Emacs-Lisp programmer, then you can use</span>
<span class="linecomment">;;  `completing-read' and `read-file-name' to define your own</span>
<span class="linecomment">;;  commands, enabling them to take advantage of Icicles completion</span>
<span class="linecomment">;;  and cycling.  The definition of command `icicle-recent-file' is a</span>
<span class="linecomment">;;  good model to follow.  Emacs has a `recentf-mode' that lets you</span>
<span class="linecomment">;;  open recently accessed files.  But this mode makes you open a file</span>
<span class="linecomment">;;  using a menu interface.  Command `icicle-recent-file' lets you use</span>
<span class="linecomment">;;  the usual `find-file' minibuffer interface, with completion and</span>
<span class="linecomment">;;  cycling among your recent files.  See sections</span>
<span class="linecomment">;;  (@&gt; "Defining Icicles Commands") and</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Note to Programmers")</span>
<span class="linecomment">;;  for more on defining your own commands with `completing-read' and</span>
<span class="linecomment">;; `read-file-name'.</span>
 
<span class="linecomment">;;(@* "Traversing Minibuffer Histories")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Traversing Minibuffer Histories</span>
<span class="linecomment">;;  -------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Perhaps you are already used to accessing past inputs using the</span>
<span class="linecomment">;;  `up' and `down' arrow keys (or `M-n', `M-p', and `next').  If not,</span>
<span class="linecomment">;;  try it.  You can go backward and forward in the minibuffer</span>
<span class="linecomment">;;  histories (there are different history lists for different kinds</span>
<span class="linecomment">;;  of input).  You can't really cycle them (with wraparound), but</span>
<span class="linecomment">;;  when you get to one end you can reverse the direction.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Anyway, the input-cycling behavior that Icicles offers is in</span>
<span class="linecomment">;;  addition to this standard traversal of histories.  Since there</span>
<span class="linecomment">;;  are, by default, several extra pairs of keys used for history</span>
<span class="linecomment">;;  traversal, rebinding some of them to use for Icicles completion is</span>
<span class="linecomment">;;  no real loss.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, Icicles rebinds the arrow keys `up' and `down' for</span>
<span class="linecomment">;;  prefix-completion cycling.  Icicles also rebinds `next' and</span>
<span class="linecomment">;;  `prior' for apropos-completion cycling.  You still have `M-n' and</span>
<span class="linecomment">;;  `M-p' available to access past inputs (history).  And the</span>
<span class="linecomment">;;  rebindings are only for minibuffer input; global bindings are not</span>
<span class="linecomment">;;  affected.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can at any time switch back and forth between input-history</span>
<span class="linecomment">;;  traversal (`M-n', `M-p') and completion cycling (`down', `up',</span>
<span class="linecomment">;;  `next', `prior').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "History Enhancements") for new ways to use Emacs history</span>
<span class="linecomment">;;    lists with Icicles</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Customizing Key Bindings")</span>
<span class="linecomment">;;    for how to change the default Icicles key bindings, including</span>
<span class="linecomment">;;    the keys used for candidate cycling</span>
 
<span class="linecomment">;;(@* "Apropos Completions")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Apropos Completions</span>
<span class="linecomment">;;  -------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles offers a new way to complete your partial input in the</span>
<span class="linecomment">;;  minibuffer.  Instead of considering the string of input characters</span>
<span class="linecomment">;;  to be the prefix of various complete names, you can look for names</span>
<span class="linecomment">;;  that match that string anywhere.  This is the single most</span>
<span class="linecomment">;;  important feature that Icicles offers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is similar in effect to using command `apropos' to find</span>
<span class="linecomment">;;  "apropos completions" of a string (except it works also for file</span>
<span class="linecomment">;;  and buffer names), so that's the term I use for this: apropos</span>
<span class="linecomment">;;  completion.  The more correct characterization of this is that of</span>
<span class="linecomment">;;  the previous paragraph, however: names that match the given</span>
<span class="linecomment">;;  string.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just as with prefix completion, Icicles lets you cycle among the</span>
<span class="linecomment">;;  apropos candidates.  To do this, you use keys `next' and `prior'.</span>
<span class="linecomment">;;  The root that was completed is underlined in the minibuffer</span>
<span class="linecomment">;;  completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, suppose you use `M-x' to enter a command.  You don't</span>
<span class="linecomment">;;  remember the exact command name, but it has something to do with</span>
<span class="linecomment">;;  lines, so you type `M-x line', then hit `next' repeatedly, until</span>
<span class="linecomment">;;  you see the right "line" command - `transpose-lines', perhaps.</span>
<span class="linecomment">;;  Prefix completion cannot find this command, because "line" is not</span>
<span class="linecomment">;;  a prefix of "transpose-lines".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because `M-x' expects a command name, only command names are</span>
<span class="linecomment">;;  inserted into the minibuffer as the apropos-completion candidates</span>
<span class="linecomment">;;  for `M-x'.  Likewise, in other contexts, where names of other</span>
<span class="linecomment">;;  kinds of object are expected, apropos completion inserts only</span>
<span class="linecomment">;;  names of objects of the appropriate type.  Prefix completion works</span>
<span class="linecomment">;;  the same way.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, using `next' and `prior' with `C-x b at' lets you</span>
<span class="linecomment">;;  cycle through all buffers (such as `*scratch*') that have "at" in</span>
<span class="linecomment">;;  their name - only buffer names appear as candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an alternative to using `next' to cycle forward, you can hit</span>
<span class="linecomment">;;  `S-TAB' repeatedly.  Similarly, for prefix completion you can</span>
<span class="linecomment">;;  repeat `TAB' to cycle forward.  See</span>
<span class="linecomment">;;  (@&gt; "Prefix Completion and Apropos Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Apropos completion uses a regular expression (regexp) as its input</span>
<span class="linecomment">;;  string.  You can type `M-x \bes', for instance, to find commands</span>
<span class="linecomment">;;  with "es" at the start of a word within the command name (`\b'</span>
<span class="linecomment">;;  matches the start of a word).  It will find `eshell-test' and</span>
<span class="linecomment">;;  `color-theme-blue-eshell', but not `count-lines' - "es" does not</span>
<span class="linecomment">;;  start a word in `count-lines'.  Similarly, for file names, buffer</span>
<span class="linecomment">;;  names, and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Prefix completion is actually a special case of apropos</span>
<span class="linecomment">;;  completion, where the regexp starts with "^".  (That is not how it</span>
<span class="linecomment">;;  is implemented, however.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What if you want to see the list of all completion candidates that</span>
<span class="linecomment">;;  match the minibuffer input?  Instead of cycling candidates</span>
<span class="linecomment">;;  blindly, just hit `S-TAB' (Shift TAB) at any time to display the</span>
<span class="linecomment">;;  matching candidates in pop-up buffer `*Completions*'.  This is</span>
<span class="linecomment">;;  analogous to `TAB' for prefix completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (The documentation always refers to the key that performs apropos</span>
<span class="linecomment">;;  completion as `S-TAB'.  Actually, it is `S-TAB' only by default.</span>
<span class="linecomment">;;  You can customize it, using option</span>
<span class="linecomment">;;  `icicle-apropos-complete-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Everything said in section (@&gt; "Cycling Completions") about the</span>
<span class="linecomment">;;  `*Completions*' buffer for prefix completion is also true for</span>
<span class="linecomment">;;  apropos completion.  It is updated to reflect the current set of</span>
<span class="linecomment">;;  matching candidates, and the current completion is highlighted.</span>
<span class="linecomment">;;  The root that was completed is highlighted within each candidate</span>
<span class="linecomment">;;  (first occurrence only).  Root highlighting is more important in</span>
<span class="linecomment">;;  the case of apropos completion, because the match position is</span>
<span class="linecomment">;;  different in different candidates.  In the case of apropos</span>
<span class="linecomment">;;  completion, the root is not the input string, taken literally, but</span>
<span class="linecomment">;;  the part of a candidate that the input matches.  See</span>
<span class="linecomment">;;  (@&gt; "*Completions* Display") for additional ways to use the</span>
<span class="linecomment">;;  minibuffer with `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Regexp matching is perhaps the most powerful feature of Icicles.</span>
<span class="linecomment">;;  Enjoy!  Explore!  You can at any time switch back and forth</span>
<span class="linecomment">;;  between prefix completion (`down', `up'), apropos completion</span>
<span class="linecomment">;;  (`next', `prior'), and input history traversal (`M-n', `M-p').</span>
 
<span class="linecomment">;;(@* "Expanded-Common-Match Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Expanded-Common-Match Completion</span>
<span class="linecomment">;;  --------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Apropos (regexp) matching and prefix completion each match a</span>
<span class="linecomment">;;  pattern against a completion candidate.  This operation concerns</span>
<span class="linecomment">;;  only a single candidate; it does not take into account the fact</span>
<span class="linecomment">;;  that there are others.  Since the matching operation is repeated</span>
<span class="linecomment">;;  anyway for each candidate, however, we can also find an expanded</span>
<span class="linecomment">;;  string that includes the same match (apropos or prefix) for all</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For prefix completion, Emacs completes your input to the longest</span>
<span class="linecomment">;;  common prefix match.  Icicles uses a similar notion for apropos</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, if you enter `M-x minib' and hit `TAB', Emacs</span>
<span class="linecomment">;;  completes your input to `minibuffer', which is the longest prefix</span>
<span class="linecomment">;;  match for `minib' among all command names.  The actual string that</span>
<span class="linecomment">;;  matches prefix `minib' among all candidates is, itself, `minib'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you hit `S-TAB', then each matching candidate contains a</span>
<span class="linecomment">;;  substring that matches your regexp input `minib'.  In this case,</span>
<span class="linecomment">;;  that substring is `minib', just as in the prefix-matching case.</span>
<span class="linecomment">;;  And, as in the prefix case, each matching candidate also includes</span>
<span class="linecomment">;;  a longer substring, `minibuffer', which includes what your input</span>
<span class="linecomment">;;  matches for each candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles replaces your regexp input in the minibuffer by a common</span>
<span class="linecomment">;;  substring.  Icicles highlights this expanded common match in</span>
<span class="linecomment">;;  buffer `*Completions*' using face</span>
<span class="linecomment">;;  `icicle-common-match-highlight-Completions' (magenta foreground,</span>
<span class="linecomment">;;  by default).  What your input matches directly is highlighted in</span>
<span class="linecomment">;;  `*Completions*' using face `icicle-match-highlight-Completions'</span>
<span class="linecomment">;;  (red foreground, by default).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is of course possible that a given regexp match different</span>
<span class="linecomment">;;  candidates differently, so that there is no common match.  In that</span>
<span class="linecomment">;;  case, only the individual matches are highlighted in</span>
<span class="linecomment">;;  `*Completions*' - you will see only red, no magenta, highlighting.</span>
<span class="linecomment">;;  For example, if your regexp input is `min.*buf' then various</span>
<span class="linecomment">;;  different substrings (such as `minibuf' from `minibuffer-complete'</span>
<span class="linecomment">;;  and `mint-truncate-buf' from `comint-truncate-buffer') are</span>
<span class="linecomment">;;  highlighted in red, but these share no common substring.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You will also see only red highlighting if what your input matches</span>
<span class="linecomment">;;  directly is the same as the expanded common match.  For example,</span>
<span class="linecomment">;;  if a function `moccur-regexp-read-from-minibuf' is defined (it is</span>
<span class="linecomment">;;  in library `color-moccur.el'), and your input to `C-h f' is</span>
<span class="linecomment">;;  `min[^-]*buf', then only `minibuf' is highlighted in red.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Expanded-common-match completion is convenient, but when</span>
<span class="linecomment">;;  apropos-completing you often need to try variants of a regexp,</span>
<span class="linecomment">;;  editing it and observing which candidates match in</span>
<span class="linecomment">;;  `*Completions*', until you get the regexp right.</span>
<span class="linecomment">;;  Longest-common-match completion has the disadvantage that you lose</span>
<span class="linecomment">;;  your regexp as input, which makes it hard to edit it!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To retrieve it, use `C-l' (`icicle-retrieve-previous-input')</span>
<span class="linecomment">;;  during completion.  You can repeat `C-l' to retrieve older</span>
<span class="linecomment">;;  completion inputs, cycling among them, and you can use `C-S-l'</span>
<span class="linecomment">;;  (that is, `C-L') to cycle previous inputs in the other direction -</span>
<span class="linecomment">;;  see (@&gt; "History Enhancements").  You can set option</span>
<span class="linecomment">;;  `icicle-expand-input-to-common-match-flag' to nil to turn off</span>
<span class="linecomment">;;  longest-common-match completion altogether, if you prefer.  You</span>
<span class="linecomment">;;  can also toggle it from the minibuffer at any time, using `C-;'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just what is meant by the "expanded common match" that Icicles</span>
<span class="linecomment">;;  finds?  It is the longest match that is common to all candidates</span>
<span class="linecomment">;;  and also contains the first input match in the first or second</span>
<span class="linecomment">;;  candidate, whichever is longer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For apropos completion, this is not always the longest common</span>
<span class="linecomment">;;  match, but in most cases it is, and it is quicker to compute.  In</span>
<span class="linecomment">;;  general, the longest common match does not necessarily contain the</span>
<span class="linecomment">;;  first match of your input with either the first candidate or the</span>
<span class="linecomment">;;  second candidate.  It might contain a different input match from</span>
<span class="linecomment">;;  the first in both the first and second candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, with input `a' and candidates `abacb', `abbac', and</span>
<span class="linecomment">;;  `bacba' (in that order), `bac' is the longest common match.  But</span>
<span class="linecomment">;;  `a' is the longest common match that contains the first match in</span>
<span class="linecomment">;;  the first candidate.  It is the second match of `a' against</span>
<span class="linecomment">;;  `abacb' that yields `bac'.  Likewise for the second candidate: it</span>
<span class="linecomment">;;  is the second match of `a' against `abbac' that yields `bac'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So in this case Icicles will use `a' as the expanded input and</span>
<span class="linecomment">;;  miss the longest common match.  If the candidate order is</span>
<span class="linecomment">;;  different, so that `bacba' is either the first or the second</span>
<span class="linecomment">;;  candidate, then Icicles finds the longest common match, because</span>
<span class="linecomment">;;  the first match of `a' against `bacba' yields `bac'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The reason that Icicles common-match expansion typically finds the</span>
<span class="linecomment">;;  longest common match is that your input typically matches the</span>
<span class="linecomment">;;  first or the second candidate in only one place.  And the longer</span>
<span class="linecomment">;;  the input you type, the more likely this is.  In practice, it is</span>
<span class="linecomment">;;  only with very short input such as `a' that Icicles expansion</span>
<span class="linecomment">;;  sometimes misses the longest common match.  Icicles independently</span>
<span class="linecomment">;;  tries two candidates (first and second) as its starting point, to</span>
<span class="linecomment">;;  increase the probability of finding the longest common match.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is also technically incorrect to speak of "the" longest common</span>
<span class="linecomment">;;  match: in general, there can be more than one.  For example, if</span>
<span class="linecomment">;;  the input is `a' and the candidates are `abab', `abba', and</span>
<span class="linecomment">;;  `baba', then both `ab' and `ba' are longest common substrings.</span>
<span class="linecomment">;;  Again, however, for typical input and typical candidates there is</span>
<span class="linecomment">;;  a single longest common match, and Icicles finds it.</span>
 
<span class="linecomment">;;(@* "Progressive Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Progressive Completion</span>
<span class="linecomment">;;  ----------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Perhaps the best way to explain this feature is to use a familiar</span>
<span class="linecomment">;;  analogy.  Unix or GNU/Linux command `grep' takes a</span>
<span class="linecomment">;;  regular-expression argument, and matches it against lines in</span>
<span class="linecomment">;;  files.  A common idiom that people use is to chain, or cascade,</span>
<span class="linecomment">;;  multiple calls to `grep', using the output of one as the input to</span>
<span class="linecomment">;;  the next.  For example:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    grep plant *.txt | grep food | grep mineral</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The output of the search for "plant" is used as the input for the</span>
<span class="linecomment">;;  search for "food", and the output of that search serves as the</span>
<span class="linecomment">;;  input for the search for "mineral".  The order of the three</span>
<span class="linecomment">;;  component searches can make a difference in terms of performance,</span>
<span class="linecomment">;;  but not in terms of the result, which is always the set of lines</span>
<span class="linecomment">;;  in files *.txt that match "plant" AND "food" AND "mineral", in any</span>
<span class="linecomment">;;  order.  Each of the `grep' operations defines a set of matches,</span>
<span class="linecomment">;;  and the chain of `grep' operations effects the intersection of</span>
<span class="linecomment">;;  those sets.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Of course, you could try to accomplish the same thing with a</span>
<span class="linecomment">;;  single call to `grep' using a complex regexp.  But why would you?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Moreover, it is in fact impossible to express such an unordered</span>
<span class="linecomment">;;  set intersection using a single regexp.  On their own, regular</span>
<span class="linecomment">;;  expressions cannot express set intersection (conjunction) or</span>
<span class="linecomment">;;  complementing (negation).  (However, most `grep' programs provide</span>
<span class="linecomment">;;  a way to obtain the lines that do not match a regexp.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The same idea of combining multiple regexp matches is behind the</span>
<span class="linecomment">;;  Icicles feature of progressive completion: instead of trying to</span>
<span class="linecomment">;;  come up with a single complex regexp that does what you want, try</span>
<span class="linecomment">;;  getting there a step at a time:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   1. Match an input regexp against the set of all possible</span>
<span class="linecomment">;;      completions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   2. Narrow the set of matched candidates by matching them against</span>
<span class="linecomment">;;      another input regexp (or by filtering them with a predicate).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   3. Narrow those results down by matching them against a third</span>
<span class="linecomment">;;      input regexp (or by filtering them with another predicate).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   4... And so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`M-*': Matching Additional Regexps")</span>
<span class="linecomment">;;  ** `M-*': Matching Additional Regexps **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During completion, `M-*' is bound in the minibuffer to command</span>
<span class="linecomment">;;  `icicle-narrow-candidates', which prompts for a new regexp and</span>
<span class="linecomment">;;  matches it against the current set of completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, suppose that you want to know about an Emacs function</span>
<span class="linecomment">;;  that deletes the character to the left of point (that is,</span>
<span class="linecomment">;;  backward).  You don't recall if it's `delete-character-back',</span>
<span class="linecomment">;;  `delete-backward-char', `character-delete-backward', or whatever.</span>
<span class="linecomment">;;  You take a guess that the name contains `delete', `char', and</span>
<span class="linecomment">;;  `back'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   1. `C-h f char S-TAB' displays function names that contain</span>
<span class="linecomment">;;      `char'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   2. `M-* delete' narrows that set of function names to those that</span>
<span class="linecomment">;;      also contain `delete'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   3. `M-* back' narrows the set of matching names further, to those</span>
<span class="linecomment">;;      that also contain `back'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This displays a list of functions like this in `*Completions*'</span>
<span class="linecomment">;;  (your list might be somewhat different):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    backward-delete-char        backward-delete-char-untabify</span>
<span class="linecomment">;;    delete-backward-char        icicle-backward-delete-char-untabify</span>
<span class="linecomment">;;    icicle-delete-backward-char</span>
<span class="linecomment">;;    quail-conversion-backward-delete-char</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Then, of course, you can pick one (or you can use `C-M-next'</span>
<span class="linecomment">;;  repeatedly to view the doc of each of these functions in turn -</span>
<span class="linecomment">;;  see (@&gt; "Get Help on Candidates")).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You get the idea.  This feature is both very simple to use and</span>
<span class="linecomment">;;  very useful.  It's easy to appreciate using multiple simple</span>
<span class="linecomment">;;  matching steps (regexp or not) instead of a single regexp.  Try it</span>
<span class="linecomment">;;  once, and you'll be hooked.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Successive Approximation...")</span>
<span class="linecomment">;;  ** Successive Approximation... **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use as many invocations of `M-*' (and of `M-&', described</span>
<span class="linecomment">;;  in the next section) as you like, in any order.  It works with</span>
<span class="linecomment">;;  both prefix completion and apropos completion.  You can, for</span>
<span class="linecomment">;;  instance, first use `TAB' to require the target to start with some</span>
<span class="linecomment">;;  string, and then use `M-*' to specify other patterns that parts of</span>
<span class="linecomment">;;  it must also match.  However, it of course makes no sense to use</span>
<span class="linecomment">;;  `TAB' instead of `S-TAB' after you use `M-*': once you've said</span>
<span class="linecomment">;;  that the target must start with "fo" there is no sense saying that</span>
<span class="linecomment">;;  it also starts with "ti"!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a shortcut, instead of using `S-TAB' followed by `M-*', you can</span>
<span class="linecomment">;;  use `S-SPC' (command `icicle-apropos-complete-and-narrow') to do</span>
<span class="linecomment">;;  the same thing.  You can thus use only `S-SPC', any number of</span>
<span class="linecomment">;;  times, to choose a candidate by narrowing down the matches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I call this process of completion by successive approximation, or</span>
<span class="linecomment">;;  progressively narrowing the candidate set, "progressive</span>
<span class="linecomment">;;  completion".  If the name "incremental completion" (= icompletion)</span>
<span class="linecomment">;;  were not already taken to mean incremental completion *help*</span>
<span class="linecomment">;;  (which performs no completion), then that might be a good name for</span>
<span class="linecomment">;;  this.  This might also be called "stepped", "cascaded", or</span>
<span class="linecomment">;;  "piecewise" completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another possible name for it would be "multiple completion", but I</span>
<span class="linecomment">;;  use that to stand for simultaneous (parallel) completion of</span>
<span class="linecomment">;;  multiple parts of a compound target, which is something different</span>
<span class="linecomment">;;  (see (@file :file-name "icicles-doc2.el" :to "Multi-Completions")).</span>
<span class="linecomment">;;  Progressive completion is a set of mini-completions that are wired</span>
<span class="linecomment">;;  in series, not in parallel.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that when you use `M-*' (or `S-SPC') in the minibuffer, it</span>
<span class="linecomment">;;  calls `completing-read' or `read-file-name', which creates a</span>
<span class="linecomment">;;  recursive minibuffer.  That is, the minibuffer depth is increased.</span>
<span class="linecomment">;;  (This is not the case for `M-&', however.)  In vanilla Emacs,</span>
<span class="linecomment">;;  there is no indicator of the current minibuffer depth, and this</span>
<span class="linecomment">;;  can sometimes be disorienting.  Each time you use `M-*' you push</span>
<span class="linecomment">;;  down one level of minibuffer recursion (that is, minibuffer depth</span>
<span class="linecomment">;;  is incremented).  Each time you use, say, `C-g', you pop up one</span>
<span class="linecomment">;;  level of minibuffer recursion (that is, minibuffer depth is</span>
<span class="linecomment">;;  decremented).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use library `mb-depth.el', which is included with Emacs 23</span>
<span class="linecomment">;;  and which also works with Emacs 22, Icicle mode takes advantage of</span>
<span class="linecomment">;;  this library by indicating the current depth in the minibuffer.  I</span>
<span class="linecomment">;;  recommend you also use my library `mb-depth+.el', which lets you</span>
<span class="linecomment">;;  customize the form and face of the depth indicator.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use my library `oneonone.el', then you get visual feedback</span>
<span class="linecomment">;;  on the current minibuffer depth.  One-On-One Emacs gives you a</span>
<span class="linecomment">;;  standalone minibuffer frame, and it changes the background hue</span>
<span class="linecomment">;;  (color) of that frame slightly with each change in minibuffer</span>
<span class="linecomment">;;  depth.  This is especially helpful with Icicles, where use of</span>
<span class="linecomment">;;  `M-*' (or `S-SPC') is common.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There is a slight difference in behavior between Icicles commands</span>
<span class="linecomment">;;  and some other Emacs commands when you accept input after `M-*'.</span>
<span class="linecomment">;;  When possible, Icicles accepts your input and passes it</span>
<span class="linecomment">;;  immediately to the top level, bypassing any intermediate recursive</span>
<span class="linecomment">;;  minibuffer levels that are waiting for inupt.  However, Emacs</span>
<span class="linecomment">;;  commands that are defined with literal-string `interactive' specs,</span>
<span class="linecomment">;;  such as (interactive "fFile: "), do not use `completing-read' or</span>
<span class="linecomment">;;  `read-file-name', so there is no way for Icicles to take this</span>
<span class="linecomment">;;  shortcut with them.  In that case, you will simply need to hit</span>
<span class="linecomment">;;  `RET' again to accept your input at each recursive minibuffer</span>
<span class="linecomment">;;  level, until you get back to the top level.  Sorry for this</span>
<span class="linecomment">;;  inconvenience!  If you are an Emacs-Lisp programmer, note that</span>
<span class="linecomment">;;  this is one reason to use `completing-read' and `read-file-name'</span>
<span class="linecomment">;;  when you write commands that use completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: If you use progressive completion with file names in Emacs</span>
<span class="linecomment">;;  20 or 21, `M-*' calls `completing-read', not `read-file-name'.</span>
<span class="linecomment">;;  This is because `read-file-name' does not accept a PREDICATE</span>
<span class="linecomment">;;  argument before Emacs 22.  The effect is that instead of there</span>
<span class="linecomment">;;  being a default directory for completion, the current directory at</span>
<span class="linecomment">;;  the time you hit `M-*' is tacked onto each file name, to become</span>
<span class="linecomment">;;  part of the completion candidates themselves.  Yes, this is a</span>
<span class="linecomment">;;  hack.  It works, but be aware of the behavior.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Progressive completion lets you match multiple regexps, some of</span>
<span class="linecomment">;;  which could of course be literal substrings, with their regexp</span>
<span class="linecomment">;;  special characters, if any, escaped.  If you need to match such</span>
<span class="linecomment">;;  substrings at particular locations in the target completion</span>
<span class="linecomment">;;  candidate, then progressive completion won't do the job - it</span>
<span class="linecomment">;;  matches its component regexps independently.  You can regexp-quote</span>
<span class="linecomment">;;  (escape) parts or all of your input using `C-M-;'</span>
<span class="linecomment">;;  (`icicle-regexp-quote-input').</span>
<span class="linecomment">;;  See (@&gt; "Quoting (Escaping) Special Characters")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`M-&': Satisfying Additional Predicates")</span>
<span class="linecomment">;;  ** `M-&': Satisfying Additional Predicates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use Icicles, then you will use `M-*' very often.  This</span>
<span class="linecomment">;;  section describes a seldom-used feature that can be useful in</span>
<span class="linecomment">;;  certain contexts.  If you are new to Icicles or you are unfamiliar</span>
<span class="linecomment">;;  with Emacs Lisp, then you might want to just skim this section or</span>
<span class="linecomment">;;  skip it and come back to it later.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just as you can use `M-*' to narrow the set of candidates by</span>
<span class="linecomment">;;  matching an additional regexp, so you can use `M-&' (bound to</span>
<span class="linecomment">;;  `icicle-narrow-candidates-with-predicate') to narrow by satisfying</span>
<span class="linecomment">;;  an additional predicate.  The idea is the same; the only</span>
<span class="linecomment">;;  difference is that, instead of typing a regexp to match, you type</span>
<span class="linecomment">;;  a predicate to satisfy.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The predicate is a Boolean function of a single completion</span>
<span class="linecomment">;;  candidate.  At the prompt, you enter its name or its lambda-form</span>
<span class="linecomment">;;  definition (anonymous function).  The predicate is used the same</span>
<span class="linecomment">;;  way as the PREDICATE argument to `completing-read' and</span>
<span class="linecomment">;;  `read-file-name'.  This means that the candidate argument to the</span>
<span class="linecomment">;;  predicate is whatever is used in the original call to</span>
<span class="linecomment">;;  `completing-read' or `read-file-name'; it is not just a string</span>
<span class="linecomment">;;  such as you see in buffer `*Completions*'.  To provide an</span>
<span class="linecomment">;;  appropriate predicate, you must be familiar with the kind of</span>
<span class="linecomment">;;  candidate expected by the command you invoked before just before</span>
<span class="linecomment">;;  `M-&'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Command `describe-function' (`C-h f') uses candidates that are</span>
<span class="linecomment">;;    symbols.  An appropriate predicate would accept a symbol as</span>
<span class="linecomment">;;    argument.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Command `icicle-search' (`C-c `') uses candidates that have this</span>
<span class="linecomment">;;    form: (CONTEXT . MARKER), where CONTEXT is a string, the search</span>
<span class="linecomment">;;    hit (search context), and MARKER is a buffer marker that locates</span>
<span class="linecomment">;;    the CONTEXT.  An appropriate predicate would accept such a</span>
<span class="linecomment">;;    candidate as argument.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Although entering a lambda expression at a prompt might not seem</span>
<span class="linecomment">;;  too convenient, you can at least retrieve previously entered</span>
<span class="linecomment">;;  predicates (using `M-p' and so on).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also use `C-M-&' (bound to</span>
<span class="linecomment">;;  `icicle-save-predicate-to-variable') at any time during completion</span>
<span class="linecomment">;;  to save the current predicate as a string-valued variable.  By</span>
<span class="linecomment">;;  default, the variable is `icicle-input-string'.  You can then</span>
<span class="linecomment">;;  retrieve the saved string later, using `C-=' at the prompt for</span>
<span class="linecomment">;;  `M-&'.  The current predicate is what is saved.  You can build up</span>
<span class="linecomment">;;  a complex predicate, and then save it for later use.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The inconvenience of typing an Emacs-Lisp sexp must be balanced</span>
<span class="linecomment">;;  against the power of applying predicates on the fly.  Whereas</span>
<span class="linecomment">;;  regexp matching is purely syntactic, with a predicate you can</span>
<span class="linecomment">;;  perform semantic tests.  During search, for instance, you can look</span>
<span class="linecomment">;;  not only for a syntax match; you can look for matching search</span>
<span class="linecomment">;;  candidates that also belong to a particular class of objects</span>
<span class="linecomment">;;  (e.g. function, variable, type) or that satisfy some other</span>
<span class="linecomment">;;  semantic property.</span>
<span class="linecomment">;;  See also (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Sets of Completion Candidates") for another way to perform</span>
<span class="linecomment">;;    a set intersection on sets of candidate completions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;    for a way to search using two regexps - command `icicle-search'</span>
<span class="linecomment">;;    uses the same idea as that behind progressive completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Compile/Grep Search")</span>
<span class="linecomment">;;    for a way to grep files using multiple levels of regexps, and</span>
<span class="linecomment">;;    performing selected replacements.</span>
 
<span class="linecomment">;;(@* "Regressive Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Regressive Completion</span>
<span class="linecomment">;;  ---------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Though generally less useful than progressive completion, you can</span>
<span class="linecomment">;;  also widen, instead of narrow, the current set of completion</span>
<span class="linecomment">;;  candidates, by providing an alternative pattern (regexp) to match.</span>
<span class="linecomment">;;  By analogy, I call this "regressive completion".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The analogy is not exact, because of the nature of completion:</span>
<span class="linecomment">;;  your current input always matches all candidates, by definition.</span>
<span class="linecomment">;;  With progressive completion, a recursive minibuffer is entered for</span>
<span class="linecomment">;;  each new pattern to match.  The candidates that matched the</span>
<span class="linecomment">;;  previous input of the progression become the domain of discourse</span>
<span class="linecomment">;;  for the current completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That same technique is not applicable for widening.  Instead, you</span>
<span class="linecomment">;;  enter, using `RET', a new pattern to match as an alternative, and</span>
<span class="linecomment">;;  Icicles changes the current input to a regexp that matches either</span>
<span class="linecomment">;;  what the previous input matched or the alternative pattern.  In</span>
<span class="linecomment">;;  other words, it is just a short cut for typing a regexp that</span>
<span class="linecomment">;;  matches a choice: \(...\|...\).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You use `M-+' (`icicle-widen-candidates') for regressive</span>
<span class="linecomment">;;  completion - think of the `+' as set union (OR), just as you think</span>
<span class="linecomment">;;  of the `*' in `M-*' as set intersection (AND).  And, just as for</span>
<span class="linecomment">;;  progressive completion, there is a shortcut, `S-backspace', for</span>
<span class="linecomment">;;  `S-TAB' followed by `M-+'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, if you want to see all of the candidates that contain</span>
<span class="linecomment">;;  either `for' or `back', you could type `\(for\|back\)' in the</span>
<span class="linecomment">;;  minibuffer, or you could just type `for', then `S-backspace' (or</span>
<span class="linecomment">;;  `S-TAB' followed by `M-+'), then `back'.  Icicles replaces your</span>
<span class="linecomment">;;  input by `\(for\|back\)'.  You can continue with additional</span>
<span class="linecomment">;;  alternative match patterns.  And you can combine narrowing with</span>
<span class="linecomment">;;  widening, that is, progressive with regressive completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can of course cycle among all matching candidates, regardless</span>
<span class="linecomment">;;  of which alternative they match.  One use of regressive completion</span>
<span class="linecomment">;;  is with Icicles search - it corresponds to the OR searching of</span>
<span class="linecomment">;;  common search engines.</span>
 
<span class="linecomment">;;(@* "Moving Between the Minibuffer and Other Buffers")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Moving Between the Minibuffer and Other Buffers</span>
<span class="linecomment">;;  -----------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sometimes, when the minibuffer is active, you might want to move</span>
<span class="linecomment">;;  the cursor and focus from the minibuffer back to the original</span>
<span class="linecomment">;;  buffer from which you activated the minibuffer.  When you are in</span>
<span class="linecomment">;;  Icicle mode, the `pause' key is bound (by default) to command</span>
<span class="linecomment">;;  `icicle-switch-to/from-minibuffer', which does that.  This lets</span>
<span class="linecomment">;;  you start minibuffer input (with or without completion), and then</span>
<span class="linecomment">;;  interrupt it to search, edit, and so on, in the original buffer.</span>
<span class="linecomment">;;  This same command (bound to `pause') then lets you switch back to</span>
<span class="linecomment">;;  the minibuffer - it acts as a toggle for the input focus; go back</span>
<span class="linecomment">;;  and forth as much as you like.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This can be especially useful when you use multi-commands (see</span>
<span class="linecomment">;;  (@&gt; "Multi-Commands")).  In that case, you often keep the</span>
<span class="linecomment">;;  minibuffer active for completion while performing multiple</span>
<span class="linecomment">;;  completion actions.  It can be handy to interrupt this to perform</span>
<span class="linecomment">;;  some normal editing or search, and then resume multi-command</span>
<span class="linecomment">;;  actions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another use for this feature is to select text in the original</span>
<span class="linecomment">;;  buffer and then insert it in the minibuffer.  See also</span>
<span class="linecomment">;;  (@&gt; "Inserting Text Found Near the Cursor") for another way to do</span>
<span class="linecomment">;;  that.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A somewhat related toggle is available using `C-insert'.  This</span>
<span class="linecomment">;;  lets you switch the focus between the minibuffer and buffer</span>
<span class="linecomment">;;  `*Completions*'.  See (@&gt; "*Completions* Display") for more</span>
<span class="linecomment">;;  information.</span>
 
<span class="linecomment">;;(@* "Inserting a Regexp from a Variable")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Inserting a Regexp from a Variable</span>
<span class="linecomment">;;  ----------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Regexps are powerful, but they can sometimes be complex to compose</span>
<span class="linecomment">;;  and hard to remember once composed.  A shortcut is to compose a</span>
<span class="linecomment">;;  regexp that you want to use and assign it to an Emacs variable.</span>
<span class="linecomment">;;  Then, whenever you are typing input in the minibuffer, you can use</span>
<span class="linecomment">;;  `C-=' (bound to command `icicle-insert-string-from-variable') to</span>
<span class="linecomment">;;  insert the regexp.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `C-u C-=' (provide a prefix argument) then you are</span>
<span class="linecomment">;;  prompted for the variable to use.  You can use any variable.</span>
<span class="linecomment">;;  Without `C-u', the default variable is used (no prompting),</span>
<span class="linecomment">;;  `icicle-input-string'.  So, for example, if `icicle-input-string'</span>
<span class="linecomment">;;  had value "[a-zA-Z]+" then it would match any completion candidate</span>
<span class="linecomment">;;  composed only of letters.  You can customize</span>
<span class="linecomment">;;  `icicle-input-string'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For convenience, instead of using Lisp evaluation of a sexp such</span>
<span class="linecomment">;;  as (setq icicle-input-string "[a-zA-Z]+") or (setq my-var ".*"),</span>
<span class="linecomment">;;  you can use Icicles command `icicle-save-string-to-variable' to</span>
<span class="linecomment">;;  save a regexp to a variable.  You are prompted for the regexp to</span>
<span class="linecomment">;;  save.  Just as for `icicle-insert-string-from-variable', with a</span>
<span class="linecomment">;;  prefix argument you are prompted for the variable to use; with no</span>
<span class="linecomment">;;  prefix argument the regexp is saved to variable</span>
<span class="linecomment">;;  `icicle-input-string'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another way of inserting a string into the minibuffer is to use a</span>
<span class="linecomment">;;  negative prefix arg with `M-:' (e.g. `M-- M-:') during minibuffer</span>
<span class="linecomment">;;  input.  With this method, you can type not only a string-valued</span>
<span class="linecomment">;;  variable name but any Emacs-Lisp expression that evaluates to a</span>
<span class="linecomment">;;  string.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These shortcut features are especially convenient for use with</span>
<span class="linecomment">;;  command `icicle-search' - you can use it to search text for</span>
<span class="linecomment">;;  sentences, paragraphs, file names, URLs, dates, times, function</span>
<span class="linecomment">;;  definitions, and any other text entities that you can specify by</span>
<span class="linecomment">;;  regexp.  Create a library of regexp-valued variables that are</span>
<span class="linecomment">;;  useful to you, and use `C-=' to quickly access them in</span>
<span class="linecomment">;;  `icicle-search'.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;  for more information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: (@&gt; "Inserting Text Found Near the Cursor").</span>
 
<span class="linecomment">;;(@* "Special Characters in Input Patterns")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Special Characters in Input Patterns</span>
<span class="linecomment">;;  ------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Regular-expression syntax treats some characters specially, but</span>
<span class="linecomment">;;  some of these special characters have another special meaning in</span>
<span class="linecomment">;;  Emacs when used with file-name inputs.  What about the conflict</span>
<span class="linecomment">;;  between interpreting characters such as `$', `\', `.', `?', and</span>
<span class="linecomment">;;  `*' as 1) regexp special characters and 2) special characters for</span>
<span class="linecomment">;;  file-name input?  For example, when inputting a file name, should</span>
<span class="linecomment">;;  `*' be treated as a regexp multiple-occurrences operator or as a</span>
<span class="linecomment">;;  file-name wildcard?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Emacs file-name input:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - `$' can be used to prefix environment variables.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - `*' and `?' can be used as wildcards, effectively inputting</span>
<span class="linecomment">;;    multiple file names at once.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - `.' and `..' can be used to navigate a directory hierarchy.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - `\' is a directory separator, like `/', on MS Windows, at least.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles handles the conflict by interpreting such characters as</span>
<span class="linecomment">;;  regexp special characters only during input completion and cycling</span>
<span class="linecomment">;;  - and then only if you do not escape them (with `\').  If present</span>
<span class="linecomment">;;  in the input when you finally accept it (using `RET'), they take</span>
<span class="linecomment">;;  on their normal Emacs meanings for file-name input:</span>
<span class="linecomment">;;  environment-variable prefix, wildcard, directory abbreviation, or</span>
<span class="linecomment">;;  directory separator.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That is, whenever there is a potential conflict of interpretation,</span>
<span class="linecomment">;;  the regexp meaning is used for completion and cycling, and the</span>
<span class="linecomment">;;  standard interpretation for file-name input is used for accepting</span>
<span class="linecomment">;;  the input.  So, for example, to get the wildcard interpretation of</span>
<span class="linecomment">;;  `*', just forego regexp completion and cycling.  And vice versa:</span>
<span class="linecomment">;;  forego the wildcard interpretation to use regexp completion and</span>
<span class="linecomment">;;  cycling.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is in any case the behavior of vanilla Emacs as well.  If, in</span>
<span class="linecomment">;;  vanilla Emacs, you use `ici*' or `ici*.el' as input to `find-file'</span>
<span class="linecomment">;;  and hit `TAB', there is no completion available.  File-name</span>
<span class="linecomment">;;  globbing and completion are independent.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Because `?' is useful in regexp syntax, the standard Emacs</span>
<span class="linecomment">;;        minibuffer binding of `?', which just displays the</span>
<span class="linecomment">;;        completion-candidates list, is not used in Icicles.  In</span>
<span class="linecomment">;;        Icicles, `?' self-inserts in the minibuffer, like any other</span>
<span class="linecomment">;;        printable character.  (Use `TAB' or `S-TAB' to display the</span>
<span class="linecomment">;;        list.)  In standard Emacs, you must quote `?' or</span>
<span class="linecomment">;;        copy-and-paste it, to insert it in the minibuffer for use as</span>
<span class="linecomment">;;        a file-name wildcard.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The interpretation conflict for `\' (on MS Windows) is not really</span>
<span class="linecomment">;;  a problem, anyway.  Although you cannot use a backslash (`\') as a</span>
<span class="linecomment">;;  directory separator during apropos completion and cycling, you can</span>
<span class="linecomment">;;  always use a slash (`/') instead - even on MS Windows.  The best</span>
<span class="linecomment">;;  practice is to just break with MS-Windows syntax, and get in the</span>
<span class="linecomment">;;  habit of always using `/' as the directory-separator character.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But what if you copy an absolute filename from some MS Windows</span>
<span class="linecomment">;;  application, so it has backslashes, and you want to use it in</span>
<span class="linecomment">;;  Emacs?  You can go ahead and paste it in the minibuffer for</span>
<span class="linecomment">;;  filename completion, as long as you are not doing regexp</span>
<span class="linecomment">;;  completion.  You can (a) use prefix completion with it, (b) use</span>
<span class="linecomment">;;  `C-`' to turn on regexp quoting for apropos completion (so you can</span>
<span class="linecomment">;;  complete a substring), or (c) change the backslashes to slashes.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Even if you always use only slash, not backslash, as a directory</span>
<span class="linecomment">;;  separator when inputting, however, it is possible that you could</span>
<span class="linecomment">;;  run into some trouble on MS Windows.  You might (knowingly or not)</span>
<span class="linecomment">;;  use `\' as a directory separator in the values of environment</span>
<span class="linecomment">;;  variables that you use as part of file-name input.  If you are</span>
<span class="linecomment">;;  regexp completing, then those backslashes will be treated as</span>
<span class="linecomment">;;  regexp escapes.  So you should use only non-regexp completion with</span>
<span class="linecomment">;;  input that includes environment variables whose expansions might</span>
<span class="linecomment">;;  include backslashes.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The interpretation conflict for `$' is also not a real problem.</span>
<span class="linecomment">;;  You can get the effect of both interpretations of `$' at the same</span>
<span class="linecomment">;;  time, because Icicles recognizes that `$' at the end of input</span>
<span class="linecomment">;;  cannot be an environment-variable prefix.  This means, for</span>
<span class="linecomment">;;  example, that you can use a pattern such as `$HOME.*t$' to match</span>
<span class="linecomment">;;  the files in your home directory whose names end in `t'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The first `$' here is not treated specially during regexp matching</span>
<span class="linecomment">;;  and cycling; the environment variable `$HOME' is expanded by the</span>
<span class="linecomment">;;  shell to a directory name.  The second `$' is treated as the</span>
<span class="linecomment">;;  regexp special character that matches at the end of a line.  When</span>
<span class="linecomment">;;  using environment variables, you can also enclose them in braces:</span>
<span class="linecomment">;;  `${HOME}', for example.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Tip: Because slash (`/') is about the only non-word syntax</span>
<span class="linecomment">;;       character that is likely to appear in file-name completions,</span>
<span class="linecomment">;;       you can usually use `\W$' to match only directories (by</span>
<span class="linecomment">;;       matching the `/' at the end of their names).  `\W' is the</span>
<span class="linecomment">;;       regexp pattern that matches any character that does not</span>
<span class="linecomment">;;       appear in words.  For example, you can use `${HOME}\W$' to</span>
<span class="linecomment">;;       match all direct subdirectories in your home directory.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Quoting (Escaping) Special Characters")</span>
<span class="linecomment">;;  ** Quoting (Escaping) Special Characters **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can toggle interpretation vs escaping of regexp special</span>
<span class="linecomment">;;  characters at any time, using `C-`' in the minibuffer (command</span>
<span class="linecomment">;;  `icicle-toggle-regexp-quote').  Escaping special characters this</span>
<span class="linecomment">;;  way means they are no longer special; they simply match</span>
<span class="linecomment">;;  themselves.  This has the effect of reducing apropos completion to</span>
<span class="linecomment">;;  simple substring completion.  If you never want to use regexp</span>
<span class="linecomment">;;  matching (*not* recommended!), you can customize user option</span>
<span class="linecomment">;;  `icicle-regexp-quote-flag', setting it to non-nil.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Apropos (regexp) completion contains literal substring completion</span>
<span class="linecomment">;;  as a (common) special case.  Sometimes you want to use regexp</span>
<span class="linecomment">;;  completion, but you also want to match a literal substring that</span>
<span class="linecomment">;;  contains special characters.  You can of course quote (escape)</span>
<span class="linecomment">;;  each of these characters by hand.  Alternatively, you can use</span>
<span class="linecomment">;;  `C-M-;' (`icicle-regexp-quote-input') to quote the text that you</span>
<span class="linecomment">;;  want to match literally.  If the region is active, then it is</span>
<span class="linecomment">;;  quoted; otherwise, your entire minibuffer input is quoted.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that if a substring that you want to match literally can</span>
<span class="linecomment">;;  occur anywhere in the target completion candidate, then it is</span>
<span class="linecomment">;;  simpler to just use progressive completion.  Quoting a literal</span>
<span class="linecomment">;;  substring is useful when the overall regexp requires it to be at a</span>
<span class="linecomment">;;  certain location in the target.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Dired Enhancements")</span>
<span class="linecomment">;;    for how to use Icicles regexp-matching to open Dired on sets of</span>
<span class="linecomment">;;    files that you might not be able to specify using file-name</span>
<span class="linecomment">;;    wildcards.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Multi-Commands") for a way to open multiple files whose</span>
<span class="linecomment">;;    names match a regular expression.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "File-Name and Directory-Name Completion Tips")</span>
<span class="linecomment">;;    for:</span>
<span class="linecomment">;;    - Information about abbreviating your home directory as `~' or</span>
<span class="linecomment">;;      expanding it.</span>
<span class="linecomment">;;    - A way to locate and open files by regexp anywhere in your file</span>
<span class="linecomment">;;      system - that is, match against directory-name as well as</span>
<span class="linecomment">;;      file-name components.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Progressive Completion")</span>
 
<span class="linecomment">;;(@* "Alternative Libraries: Other Methods of Choosing Default Values")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Alternative Libraries: Other Methods of Choosing Default Values</span>
<span class="linecomment">;;  ---------------------------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are other libraries, besides Icicles, that give you</span>
<span class="linecomment">;;  alternative ways to pick a candidate default value.  There are,</span>
<span class="linecomment">;;  for instance, many libraries that provide ways to switch buffers.</span>
<span class="linecomment">;;  Some of these present candidates in the minibuffer and choose one</span>
<span class="linecomment">;;  as soon as you type enough of its name to select it unambiguously</span>
<span class="linecomment">;;  - without your needing to confirm your choice (with `RET', for</span>
<span class="linecomment">;;  example).  Library `ido.el' is an example of such a library.</span>
<span class="linecomment">;;  Library `iswitchb.el' is another such library; it is specialized</span>
<span class="linecomment">;;  for choosing a buffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Choosing without confirming can be very quick, but I prefer to</span>
<span class="linecomment">;;  confirm a choice.  In any case, you can also use Icicles to choose</span>
<span class="linecomment">;;  without confirming, if you wish - see (@&gt; "Multi-Commands").  See</span>
<span class="linecomment">;;  also (@&gt; "Exiting the Minibuffer Without Confirmation") for how to</span>
<span class="linecomment">;;  obtain the complete-and-exit behavior of library `iswitchb.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The main reason I prefer Icicles is because of its generality.</span>
<span class="linecomment">;;  You use the same input, cycling, and completion method for</span>
<span class="linecomment">;;  everything.  There is no need to be familiar with one method for</span>
<span class="linecomment">;;  switching buffers, another method for choosing a command, another</span>
<span class="linecomment">;;  for choosing a variable, and so on.  Library `ido.el' is quite</span>
<span class="linecomment">;;  general too, but perhaps a little less so.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Also, I like to be able to edit the value in the minibuffer.  For</span>
<span class="linecomment">;;  instance, for lax (permissive) completion, where you are not</span>
<span class="linecomment">;;  required to enter one of the proposed candidates, you can use</span>
<span class="linecomment">;;  completion to retrieve a candidate that is similar to what you</span>
<span class="linecomment">;;  want to enter, then edit it and hit `RET' to submit the actual</span>
<span class="linecomment">;;  value you want.  Library `ido.el' does have an "edit" command or</span>
<span class="linecomment">;;  mode, but I find Icicles better for letting me edit input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles has many additional features that are not available in</span>
<span class="linecomment">;;  other libraries, but its main advantage is its generality: you use</span>
<span class="linecomment">;;  the same user interface for input of any kind.</span>
 
<span class="linecomment">;;(@* "Exiting the Minibuffer Without Confirmation")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Exiting the Minibuffer Without Confirmation</span>
<span class="linecomment">;;  -------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Normally, if you exit the minibuffer with input that only</span>
<span class="linecomment">;;  partially matches a completion candidate, the value you input is</span>
<span class="linecomment">;;  exactly what you typed.  That is, exiting does not automatically</span>
<span class="linecomment">;;  complete your input - what you type is what you get.  This is</span>
<span class="linecomment">;;  "lax" (or "permissive") completion, and it is desirable most of</span>
<span class="linecomment">;;  the time, because it lets you input a value that does not</span>
<span class="linecomment">;;  correspond to any of the completion candidates.  This is how, for</span>
<span class="linecomment">;;  instance, you can use `C-x C-f' to open a new file or `C-x b' to</span>
<span class="linecomment">;;  create a new buffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, some people prefer "strict" completion: limiting input to</span>
<span class="linecomment">;;  the available completion candidates.  This can be handy in the</span>
<span class="linecomment">;;  case of switching to a buffer, for instance.  If you have a buffer</span>
<span class="linecomment">;;  named `new-ideas.txt', you might like to be able to type only</span>
<span class="linecomment">;;  `new' followed by `RET', and not have to first complete the input</span>
<span class="linecomment">;;  text.  This is the behavior of libraries `ido.el' and</span>
<span class="linecomment">;;  `iswitchb.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is the command you use that decides whether `RET' first</span>
<span class="linecomment">;;  completes your input before exiting the minibuffer (strict</span>
<span class="linecomment">;;  completion) or not (lax completion).  This is done in the command</span>
<span class="linecomment">;;  definition by providing a non-nil or nil REQUIRE-MATCH argument to</span>
<span class="linecomment">;;  function `completing-read', which prompts you and reads your</span>
<span class="linecomment">;;  input, possibly completing it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use standard Emacs command `switch-to-buffer' then</span>
<span class="linecomment">;;  completion is lax: `RET' does not complete your input `new' to</span>
<span class="linecomment">;;  `new-ideas.txt'; it simply accepts your input as is, and creates a</span>
<span class="linecomment">;;  new buffer with that name, `new'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using `S-RET' to Accept a Partial Match")</span>
<span class="linecomment">;;  ** Using `S-RET' to Accept a Partial Match **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, Icicles command `icicle-buffer', not</span>
<span class="linecomment">;;  `switch-to-buffer', is bound to `C-x b' in Icicle mode.  The</span>
<span class="linecomment">;;  default behavior of `icicle-buffer' is the same as the behavior of</span>
<span class="linecomment">;;  `switch-to-buffer' with respect to `RET'.  However, you can obtain</span>
<span class="linecomment">;;  the complete-and-exit `RET' behavior with `icicle-buffer' by</span>
<span class="linecomment">;;  setting option `icicle-buffer-require-match-flag' to</span>
<span class="linecomment">;;  `partial-match-ok'.  This value overrides the REQUIRE-MATCH</span>
<span class="linecomment">;;  argument to `completing-read', in effect forcing it to `t'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whenever completion is strict, requiring a match against one of</span>
<span class="linecomment">;;  the completion candidates (typically, an existing file or buffer</span>
<span class="linecomment">;;  name), you can complete and exit the minibuffer all at once, with</span>
<span class="linecomment">;;  only partial input in the minibuffer, by using `RET'.  But what</span>
<span class="linecomment">;;  about apropos completion?  Simply use `S-RET'</span>
<span class="linecomment">;;  (`icicle-apropos-complete-and-exit') instead of `RET': `RET' is</span>
<span class="linecomment">;;  standard in Emacs and uses prefix completion; `S-RET' is specific</span>
<span class="linecomment">;;  to Icicles and uses apropos completion.  For example, you can type</span>
<span class="linecomment">;;  `idea' followed by `S-RET' to switch to buffer `new-ideas.txt'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: You can customize `icicle-top-level-key-bindings' to prevent</span>
<span class="linecomment">;;  the rebinding of `C-x b' in Icicle mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Accepting Partial Matches by Default")</span>
<span class="linecomment">;;  ** Accepting Partial Matches by Default **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For those people who prefer that a partial match always be</span>
<span class="linecomment">;;  accepted immediately, regardless of the context (whether a match</span>
<span class="linecomment">;;  is required or not) and without having to use `RET' or `S-RET',</span>
<span class="linecomment">;;  there is Icicles user option</span>
<span class="linecomment">;;  `icicle-top-level-when-sole-completion-flag'.  If you set this to</span>
<span class="linecomment">;;  non-nil, then, whenever your input matches only one candidate</span>
<span class="linecomment">;;  completion, that candidate is used immediately.  I don't recommend</span>
<span class="linecomment">;;  this practice, but some people might prefer it.</span>
 
<span class="linecomment">;;(@* "*Completions* Display")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  *Completions* Display</span>
<span class="linecomment">;;  ---------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles adds a few enhancements to the `*Completions*' display,</span>
<span class="linecomment">;;  for convenience.  The following apply whenever buffer</span>
<span class="linecomment">;;  `*Completions*' is displayed:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * When you cycle completions in the minibuffer, the current</span>
<span class="linecomment">;;    candidate is highlighted in `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use `C-insert' to move back and forth between the</span>
<span class="linecomment">;;    minibuffer and `*Completions*'.  In each direction, the current</span>
<span class="linecomment">;;    candidate is tracked in the destination buffer.  For example, if</span>
<span class="linecomment">;;    the candidate in the minibuffer is `foobar', after you hit</span>
<span class="linecomment">;;    `C-insert' the cursor is on `foobar' in `*Completions*'.  In the</span>
<span class="linecomment">;;    other direction, if the cursor is on `foobar' in</span>
<span class="linecomment">;;    `*Completions*', after you hit `C-insert' the current input in</span>
<span class="linecomment">;;    the minibuffer is `foobar'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * In buffer `*Completions*', you can use the arrow keys to</span>
<span class="linecomment">;;    navigate among the candidate completions.  The current candidate</span>
<span class="linecomment">;;    (under the cursor) is highlighted.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `*Completions*' can also serve as a new kind of icompletion help</span>
<span class="linecomment">;;    - see (@&gt; "Icompletion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use `C-M-.' (`icicle-toggle-hiding-common-match') in the</span>
<span class="linecomment">;;    minibuffer at any time during completion to toggle hiding of the</span>
<span class="linecomment">;;    matched portions of the candidates in *Completions*.  This</span>
<span class="linecomment">;;    portion is replaced by ellipsis, `...'.  (In Emacs 20, it is</span>
<span class="linecomment">;;    replaced by nothing.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    This can be useful when you don't care about the text that</span>
<span class="linecomment">;;    matches or when that text is particularly long.  For example, if</span>
<span class="linecomment">;;    you use `icicle-find-file-absolute' (`C-u C-x C-f') and the</span>
<span class="linecomment">;;    completion candidates are absolute file names that share a</span>
<span class="linecomment">;;    common directory, it can be convenient to hide the directory</span>
<span class="linecomment">;;    portion that is common to all candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can choose multiple candidates during completion, by</span>
<span class="linecomment">;;    clicking them with `mouse-2' while holding the Control key</span>
<span class="linecomment">;;    pressed.  See (@&gt; "Multi-Commands").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Icicles varies the number of columns used to display completion</span>
<span class="linecomment">;;    candidates, for a better fit.  You can tweak this with user</span>
<span class="linecomment">;;    options `icicle-candidate-width-factor' and</span>
<span class="linecomment">;;    `icicle-inter-candidates-min-spaces'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If you use Do Re Mi (library `doremi.el'), then you can even</span>
<span class="linecomment">;;    modify these options incrementally during completion, seeing the</span>
<span class="linecomment">;;    effect as they change.  Use `C-x w' or `C-x |' from the</span>
<span class="linecomment">;;    minibuffer, then use the arrow keys or the mouse wheel to</span>
<span class="linecomment">;;    increment and decrement the current value.  WYSIWYG.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Icicles dynamically resizes the `*Completions*' window</span>
<span class="linecomment">;;    vertically, to fit the current set of completion candidates.</span>
<span class="linecomment">;;    The window is not resized, however, if buffer `*Completions*'</span>
<span class="linecomment">;;    appears in its own frame.  (It is also not resized in Emacs</span>
<span class="linecomment">;;    releases prior to 21.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    You can control this automatic resizing generally or on a</span>
<span class="linecomment">;;    per-command basis:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     * User option `icicle-Completions-window-max-height' is the</span>
<span class="linecomment">;;       maximum number of lines to show in the `*Completions*'</span>
<span class="linecomment">;;       window.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     * You can override the behavior of option</span>
<span class="linecomment">;;       `icicle-Completions-window-max-height' for any given command,</span>
<span class="linecomment">;;       by setting property `icicle-Completions-window-max-height' on</span>
<span class="linecomment">;;       the command symbol to a different maximum window height</span>
<span class="linecomment">;;       value.  This property value is predefined for commands, such</span>
<span class="linecomment">;;       as `icicle-buffer' and `icicle-file', that don't involve the</span>
<span class="linecomment">;;       content of the current buffer during completion.  A large</span>
<span class="linecomment">;;       value is used for these commands, so that nearly all of the</span>
<span class="linecomment">;;       frame real estate is given to the `*Completions*' window.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    For example, you can use this code to set the maximum</span>
<span class="linecomment">;;    `*Completions*' height for command `foo' to 100 and turn off</span>
<span class="linecomment">;;    per-command control of the height for command `bar'.  If you use</span>
<span class="linecomment">;;    such code, evaluate it after you load Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       (put 'foo 'icicle-Completions-window-max-height 100)</span>
<span class="linecomment">;;       (put 'bar 'icicle-Completions-window-max-height nil)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can scroll `*Completions*' down using `C-v', and up using</span>
<span class="linecomment">;;    `M-v'.  You can use `C-u' at any time to reverse the scroll</span>
<span class="linecomment">;;    directions.  In Emacs 22 or later, you can also use the mouse</span>
<span class="linecomment">;;    wheel to scroll `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * In some cases, Icicles adds one or more additional, proxy</span>
<span class="linecomment">;;    completion candidates.  These are placeholders for real</span>
<span class="linecomment">;;    candidates.  If you choose a proxy candidate, then the real</span>
<span class="linecomment">;;    candidate that is referred to is used.  Typical proxy candidates</span>
<span class="linecomment">;;    include a reference to a name under the cursor, a reference to</span>
<span class="linecomment">;;    whatever you then click `mouse-2' on, and a reference to a name</span>
<span class="linecomment">;;    that is the value of a variable.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The inclusion of proxy candidates is controlled by user option</span>
<span class="linecomment">;;    `icicle-add-proxy-candidates-flag'.  You can toggle this</span>
<span class="linecomment">;;    inclusion at any time during completion, using `C-M-_'.  For</span>
<span class="linecomment">;;    performance reasons, you must re-invoke some commands after</span>
<span class="linecomment">;;    toggling the flag on, to make the proxy candidates available.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Examples:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     . When you read a file name with completion, the proxy</span>
<span class="linecomment">;;       candidates include the following (reading a face name is</span>
<span class="linecomment">;;       similar):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - `*mouse-2 file name*' - proxy for a file name that you</span>
<span class="linecomment">;;         click with `mouse-2'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - `*point file name*' - proxy for the file name at point (if</span>
<span class="linecomment">;;         available).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - Single-quoted names of file-name variables - proxy for the</span>
<span class="linecomment">;;         variable value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     . When a command reads input using `icicle-read-number' or</span>
<span class="linecomment">;;       `icicle-read-string-completing', the proxy candidates are all</span>
<span class="linecomment">;;       variables whose values are numbers or strings, respectively.</span>
<span class="linecomment">;;       You can choose such a proxy candidate to use its value.  (All</span>
<span class="linecomment">;;       candidates are proxy candidates for these functions.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     . When you use command `icicle-read-color', the proxy</span>
<span class="linecomment">;;       candidates include the following:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - `*point foreground*' - proxy for the foreground color at</span>
<span class="linecomment">;;         the cursor position (point).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - `*mouse-2 foreground*' - proxy for the foreground color</span>
<span class="linecomment">;;         where you then click `mouse-2'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - `*copied foreground*' - proxy for a previously copied</span>
<span class="linecomment">;;         foreground color, the value of variable</span>
<span class="linecomment">;;         `eyedrop-picked-foreground'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - Background versions of the first three: `*copied</span>
<span class="linecomment">;;         background*' etc.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - Single-quoted names of color-valued variables - proxy for</span>
<span class="linecomment">;;         the variable value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;  (@&gt; "Different Places for Saving and Retrieving Candidates") for</span>
<span class="linecomment">;;  information about using `C-M-{' in the minibuffer to retrieve the</span>
<span class="linecomment">;;  value of any variable as minibuffer input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are lots of Icicles features that enhance the display and</span>
<span class="linecomment">;;  behavior of `*Completions*' in some way.  Read on...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: </span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Moving Between the Minibuffer and Other Buffers"), for</span>
<span class="linecomment">;;    information on the `pause' key, which is somewhat related to</span>
<span class="linecomment">;;    using `C-insert'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Candidates with Text Properties")</span>
<span class="linecomment">;;    and (@file :file-name "icicles-doc2.el" :to "Programming Multi-Completions")</span>
<span class="linecomment">;;    for information about using text properties in `*Completions*'.</span>
<span class="linecomment">;;    These sections are for Emacs-Lisp programmers.</span>
 
<span class="linecomment">;;(@* "Icompletion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icompletion</span>
<span class="linecomment">;;  -----------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Emacs incremental completion, or icompletion, provided by standard</span>
<span class="linecomment">;;  library `icomplete.el', displays matching prefix completions in</span>
<span class="linecomment">;;  the minibuffer.  This display is updated incrementally as you type</span>
<span class="linecomment">;;  characters.  In spite of the name, icompletion does not, in fact,</span>
<span class="linecomment">;;  provide any completion; it provides completion help, letting you</span>
<span class="linecomment">;;  know which (prefix) completions are available.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles enhances Emacs icompletion in three ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. It works with my library `icomplete+.el' to provide minibuffer</span>
<span class="linecomment">;;     feedback on the number of completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. It highlights the part of your input that does not match any</span>
<span class="linecomment">;;     completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. It provides a new kind of icompletion, using buffer</span>
<span class="linecomment">;;     `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "icomplete+.el Displays the Number of Other Prefix Candidates")</span>
<span class="linecomment">;;  ** icomplete+.el Displays the Number of Other Prefix Candidates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Library `icomplete+.el' enhances `icomplete.el' in various ways.</span>
<span class="linecomment">;;  One of these ways is to complement Icicles by displaying the</span>
<span class="linecomment">;;  number of other prefix-completion candidates when cycling.  This</span>
<span class="linecomment">;;  number is displayed whenever you change direction when cycling.</span>
<span class="linecomment">;;  For example:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;      M-x forward-line   [Matched]  (13 more)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Like `icomplete.el', `icomplete+.el' provides help for only prefix</span>
<span class="linecomment">;;  completions, not apropos completions.  (Reminder: There is no</span>
<span class="linecomment">;;  icompletion for file-name completion - see standard library</span>
<span class="linecomment">;;  `icomplete.el'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icompletion in *Completions*: Apropos and Prefix Completion")</span>
<span class="linecomment">;;  ** Icompletion in *Completions*: Apropos and Prefix Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Buffer `*Completions*' shows you the current set of candidates for</span>
<span class="linecomment">;;  either prefix or apropos completion.  Together, user options</span>
<span class="linecomment">;;  `icicle-incremental-completion-flag',</span>
<span class="linecomment">;;  `icicle-incremental-completion-delay', and</span>
<span class="linecomment">;;  `icicle-incremental-completion-threshold' control incremental</span>
<span class="linecomment">;;  updating of `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If `icicle-incremental-completion-flag' is non-nil, then</span>
<span class="linecomment">;;  `*Completions*' is automatically updated when you change your</span>
<span class="linecomment">;;  input in the minibuffer - that is, with each character that you</span>
<span class="linecomment">;;  type or delete.  This is another form of icompletion, unique to</span>
<span class="linecomment">;;  Icicles.  It uses buffer `*Completions*', instead of the</span>
<span class="linecomment">;;  minibuffer, to show the completion help.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The particular non-nil value of</span>
<span class="linecomment">;;  `icicle-incremental-completion-flag' determines when</span>
<span class="linecomment">;;  `*Completions*' is displayed and updated.  The default value, t,</span>
<span class="linecomment">;;  means that `*Completions*' is updated only if it is already</span>
<span class="linecomment">;;  displayed.  Use t if you don't want `*Completions*' to be too</span>
<span class="linecomment">;;  intrusive but you want it to provide the most help when you ask</span>
<span class="linecomment">;;  for help (via `TAB' or `S-TAB').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Any other non-nil value displays and updates `*Completions*'</span>
<span class="linecomment">;;  whenever there is more than one completion candidate.  That can be</span>
<span class="linecomment">;;  more helpful, but it can also be more distracting.  A value of nil</span>
<span class="linecomment">;;  turns off automatic updating altogether - `*Completions*' is then</span>
<span class="linecomment">;;  displayed only upon demand.  I find that t represents a good</span>
<span class="linecomment">;;  compromise, providing help when I ask for it, and then continuing</span>
<span class="linecomment">;;  to help until I've finished choosing a candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Option `icicle-incremental-completion-delay' is the number of</span>
<span class="linecomment">;;  seconds to wait before updating `*Completions*' incrementally.  It</span>
<span class="linecomment">;;  has an effect only when the number of completion candidates is</span>
<span class="linecomment">;;  greater than `icicle-incremental-completion-threshold'.  This</span>
<span class="linecomment">;;  delay can improve performance when there are many candidates.  It</span>
<span class="linecomment">;;  lets you type ahead before any redisplay occurs; otherwise,</span>
<span class="linecomment">;;  redisplay occurs for each character you type or delete.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can toggle incremental completion at any time (changing</span>
<span class="linecomment">;;  `icicle-incremental-completion-flag' between nil and t) using</span>
<span class="linecomment">;;  command `icicle-toggle-incremental-completion', which is bound to</span>
<span class="linecomment">;;  `C-#' in the minibuffer.  If the number of completion candidates</span>
<span class="linecomment">;;  is very large, then use `C-#' to toggle incremental completion off</span>
<span class="linecomment">;;  - that will save time by not updating `*Completions*'.  See also</span>
<span class="linecomment">;;  (@&gt; "Dealing With Large Candidate Sets") for other ways to deal</span>
<span class="linecomment">;;  with a large number of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Incremental completion is effectively turned off when a</span>
<span class="linecomment">;;  remote file name is read, that is, whenever your file-name input</span>
<span class="linecomment">;;  matches a remote-file syntax.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are several advantages of using `*Completions*' for</span>
<span class="linecomment">;;  icompletion, as opposed to the minibuffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Many more candidates can be displayed in `*Completions*' than</span>
<span class="linecomment">;;     can be displayed by standard icompletion, which uses the</span>
<span class="linecomment">;;     minibuffer for feedback.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Standard (minibuffer) icompletion provides feedback only on</span>
<span class="linecomment">;;     matches for prefix completion.  If you use both standard</span>
<span class="linecomment">;;     icompletion and Icicles icompletion, you can have incremental</span>
<span class="linecomment">;;     help for both prefix completion and apropos completion at the</span>
<span class="linecomment">;;     same time, one in the minibuffer and the other in</span>
<span class="linecomment">;;     `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. The other Icicles `*Completions*' features are available for</span>
<span class="linecomment">;;     the current set of matching candidates: cycling, highlighting</span>
<span class="linecomment">;;     of match root, highlighting of previously used candidates, and</span>
<span class="linecomment">;;     so on.  See (@&gt; "*Completions* Display").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicles Highlights the Input that Won't Complete")</span>
<span class="linecomment">;;  ** Icicles Highlights the Input that Won't Complete **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you are typing or correcting your input during completion,</span>
<span class="linecomment">;;  Icicles highlights the part of your minibuffer input that prevents</span>
<span class="linecomment">;;  it from matching any completion candidates, by default.  This</span>
<span class="linecomment">;;  works for both prefix completion and apropos completion.  For</span>
<span class="linecomment">;;  both, it highlights your input from the leftmost mismatch through</span>
<span class="linecomment">;;  the input end.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `C-M-l' to move the cursor to the start of the</span>
<span class="linecomment">;;  highlighted, mismatched part of your input.  Repeat `C-M-l' to</span>
<span class="linecomment">;;  kill the highlighted portion.  (Because it is killed, `C-y' yanks</span>
<span class="linecomment">;;  it back.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  User options `icicle-incremental-completion-flag',</span>
<span class="linecomment">;;  `icicle-test-for-remote-files-flag',</span>
<span class="linecomment">;;  `icicle-highlight-input-completion-failure',</span>
<span class="linecomment">;;  `icicle-highlight-input-completion-failure-delay', and</span>
<span class="linecomment">;;  `icicle-highlight-input-completion-failure-threshold' control this</span>
<span class="linecomment">;;  highlighting, which is done using face</span>
<span class="linecomment">;;  `icicle-input-completion-fail' (for strict completion) or</span>
<span class="linecomment">;;  `icicle-input-completion-fail-lax' (for lax completion).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If either `icicle-incremental-completion-flag' or</span>
<span class="linecomment">;;  `icicle-highlight-input-completion-failure' is nil, then no such</span>
<span class="linecomment">;;  highlighting is done.  Remember that you can toggle incremental</span>
<span class="linecomment">;;  completion using `C-#' in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because this highlighting can have a negative impact on</span>
<span class="linecomment">;;  performance, you can fine-tune when you want it to occur.  The</span>
<span class="linecomment">;;  value of `icicle-highlight-input-completion-failure' determines</span>
<span class="linecomment">;;  when this highlighting can take place.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In particular, highlighting the non-matching part of remote file</span>
<span class="linecomment">;;  names can be slow.  Two values of the option allow remote file</span>
<span class="linecomment">;;  name highlighting: `always' and `explicit-remote'.  The other</span>
<span class="linecomment">;;  values do not highlight remote file names.  You probably do not</span>
<span class="linecomment">;;  want to use a value of `always'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If the value is nil, then highlighting never occurs.  If the value</span>
<span class="linecomment">;;  is `explicit-strict', `explicit', or `explicit-remote', then</span>
<span class="linecomment">;;  highlighting occurs only upon demand: when you hit `TAB' or</span>
<span class="linecomment">;;  `S-TAB' to request completion.  If the value is `implicit-strict',</span>
<span class="linecomment">;;  `implicit', or `always', then highlighting occurs also when you</span>
<span class="linecomment">;;  update input during incremental completion (if incremental</span>
<span class="linecomment">;;  completion is turned on).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I use a value of `implicit' myself, but the default value is</span>
<span class="linecomment">;;  `implicit-strict' because, depending on your setup and use cases,</span>
<span class="linecomment">;;  `implicit' can impact performance for file-name completion (which</span>
<span class="linecomment">;;  is lax, not strict).  I suggest you try `implicit' to see - this</span>
<span class="linecomment">;;  feature is especially useful for file names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Summary of `icicle-highlight-input-completion-failure' choices:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  nil               Never</span>
<span class="linecomment">;;  `explicit-strict' Only on demand and only during strict completion</span>
<span class="linecomment">;;  `explicit'        Only on demand (lax and strict completion)</span>
<span class="linecomment">;;  `explicit-remote' Only on demand, even for remote file names</span>
<span class="linecomment">;;  `implicit-strict' Incremental or explicit completion - strict only</span>
<span class="linecomment">;;  `implicit'        Incremental/explicit, lax/strict completion</span>
<span class="linecomment">;;  `always'          Always (including for remote file names)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These values are listed here in terms of increasing</span>
<span class="linecomment">;;  permissiveness, which also can mean increasing performance impact.</span>
<span class="linecomment">;;  That is, a value of `implicit' is more likely to affect</span>
<span class="linecomment">;;  performance than a value of `explicit'.  The greatest performance</span>
<span class="linecomment">;;  hit comes from file-name matching, in particular if remote files</span>
<span class="linecomment">;;  are involved.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you know that you will not be using remote file names for a</span>
<span class="linecomment">;;  while, you can let Icicles and Tramp know this by using the toggle</span>
<span class="linecomment">;;  `C-^' in the minibuffer to turn off option</span>
<span class="linecomment">;;  `icicle-test-for-remote-files-flag'.  When this is off, you cannot</span>
<span class="linecomment">;;  use remote files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Turning off `icicle-test-for-remote-files-flag' using `C-^' turns</span>
<span class="linecomment">;;  off Tramp's remote file-name completion and remote file handling.</span>
<span class="linecomment">;;  If you turn off the option using `C-^', then turn it back on using</span>
<span class="linecomment">;;  `C-^' also (instead of just setting the option to non-nil), in</span>
<span class="linecomment">;;  order to re-enable Tramp's file-name handling and completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Turning off `icicle-test-for-remote-files-flag' can slightly speed</span>
<span class="linecomment">;;  up file-name completion for local files, by avoiding any check for</span>
<span class="linecomment">;;  remote file names.  If you seldom use remote files, then you might</span>
<span class="linecomment">;;  want to customize `icicle-test-for-remote-files-flag' to nil and</span>
<span class="linecomment">;;  use `C-^' to toggle it back on whenever you do use remote files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A nil value of `icicle-test-for-remote-files-flag' also overrides</span>
<span class="linecomment">;;  the `icicle-highlight-input-completion-failure' values</span>
<span class="linecomment">;;  `implicit-strict', and `explicit-strict' for file-name completion,</span>
<span class="linecomment">;;  treating them the same as `implicit'.  It is assumed that you use</span>
<span class="linecomment">;;  those values only to avoid the cost of remote file-name matching.</span>
 
<span class="linecomment">;;(@* "Sorting Candidates and Removing Duplicates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sorting Candidates and Removing Duplicates</span>
<span class="linecomment">;;  ------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, completion candidates are presented in buffer</span>
<span class="linecomment">;;  `*Completions*' in alphabetic order.  The order in `*Completions*'</span>
<span class="linecomment">;;  is also the order of cycling among candidates.  Also by default,</span>
<span class="linecomment">;;  duplicate candidates are removed as completion choices.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Some commands however, impose different orders, which are</span>
<span class="linecomment">;;  appropriate in their particular contexts, and some commands do not</span>
<span class="linecomment">;;  remove duplicates.  For example, command `icicle-search' (`C-c `')</span>
<span class="linecomment">;;  uses completion to navigate among search hits.  The unsorted order</span>
<span class="linecomment">;;  of the hit occurrences in the buffer is retained, as are duplicate</span>
<span class="linecomment">;;  matches.  Although some search-hit candidates might have the same</span>
<span class="linecomment">;;  text, they are located at different buffer positions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For a small minority of commands such as `icicle-search', the</span>
<span class="linecomment">;;  candidate order is fixed.  The completion candidates you see in</span>
<span class="linecomment">;;  buffer `*Completions*' are just names for (invisible) candidate</span>
<span class="linecomment">;;  objects that contain additional information (buffer and buffer</span>
<span class="linecomment">;;  position, in the case of `icicle-search').  Different such objects</span>
<span class="linecomment">;;  might have the same completion-candidate name, so it is important</span>
<span class="linecomment">;;  that the order of presentation remain constant.  Icicles picks the</span>
<span class="linecomment">;;  candidate object to use, according to which candidate name you</span>
<span class="linecomment">;;  click with `mouse-2' or which candidate name is current during</span>
<span class="linecomment">;;  cycling.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Commands such as `icicle-search' are the exception.  For most</span>
<span class="linecomment">;;  commands, you can interactively control the order of candidates</span>
<span class="linecomment">;;  and whether duplicates are removed.  Use `C-,' during completion</span>
<span class="linecomment">;;  to choose a different sort order or to turn off sorting altogether</span>
<span class="linecomment">;;  (one of the available sort orders is in fact called "turned OFF").</span>
<span class="linecomment">;;  Use `C-$' to toggle the removal of duplicate candidates.  Commands</span>
<span class="linecomment">;;  such as `icicle-search', for which sorting is inappropriate,</span>
<span class="linecomment">;;  prevent you from sorting.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Changing the Sort Order")</span>
<span class="linecomment">;;  ** Changing the Sort Order **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are a couple of ways to use `C-,' (bound to command</span>
<span class="linecomment">;;  `icicle-change-sort-order').  Its behavior depends on the value of</span>
<span class="linecomment">;;  user option `icicle-change-sort-order-completion-flag', which is</span>
<span class="linecomment">;;  nil by default.  This value means to simply cycle to the next sort</span>
<span class="linecomment">;;  order each time you hit `C-,'.  A non-nil value means to use</span>
<span class="linecomment">;;  completion to choose another sort order.  If you have many</span>
<span class="linecomment">;;  available sort orders, then you might prefer a non-nil value.  In</span>
<span class="linecomment">;;  any case, you can also change this behavior on the fly: using</span>
<span class="linecomment">;;  plain `C-u' (no number) with `C-,' reverses the meaning of</span>
<span class="linecomment">;;  `icicle-change-sort-order-completion-flag' for `C-,'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, a numeric prefix argument, such as `C-9', means to simply</span>
<span class="linecomment">;;  reverse the direction of the current sort order; it invokes</span>
<span class="linecomment">;;  command `icicle-reverse-sort-order'.  For example, if candidates</span>
<span class="linecomment">;;  are sorted alphabetically from A to Z, then `C-9 C-,' flips the</span>
<span class="linecomment">;;  sort order, so that from then on sorting is from Z to A.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to the current sort order, which is defined by the</span>
<span class="linecomment">;;  value of user option `icicle-sort-function', an alternative sort</span>
<span class="linecomment">;;  order is available at all times.  It is the value of option</span>
<span class="linecomment">;;  `icicle-alternative-sort-function'.  By default, this sorts</span>
<span class="linecomment">;;  candidates into two alphabetical groups: those previously used as</span>
<span class="linecomment">;;  accepted input, followed by those not yet used.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just as you can choose a different current sort order using `C-,',</span>
<span class="linecomment">;;  so you can choose a different alternative sort order using `M-,'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  How do you actually use the alternative sort order?  Use `C-M-,'</span>
<span class="linecomment">;;  (command `icicle-toggle-alternative-sorting') to swap the</span>
<span class="linecomment">;;  alternative sort for the current sort.  This is the quickest way</span>
<span class="linecomment">;;  to flip between two sort orders.  If, for example, you set your</span>
<span class="linecomment">;;  alternative sort order to "turned OFF", then this is a quick way</span>
<span class="linecomment">;;  to toggle sorting on and off.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Commands that read buffer names with completion can use another</span>
<span class="linecomment">;;  sort-function user option, `icicle-buffer-sort'.  It has the same</span>
<span class="linecomment">;;  meaning as `icicle-sort-function', but it applies only to those</span>
<span class="linecomment">;;  commands.  It is provided so that you can customize it separately.</span>
<span class="linecomment">;;  You can also define buffer configurations that are used for</span>
<span class="linecomment">;;  completion: named sets of buffers, sort functions, and other</span>
<span class="linecomment">;;  parameters that control completion of buffer names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Defining New Sort Orders")</span>
<span class="linecomment">;;  ** Defining New Sort Orders **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you use `C-,' or `M-,', the sort orders that you can choose</span>
<span class="linecomment">;;  from are those in user option `icicle-sort-functions-alist'.  You</span>
<span class="linecomment">;;  can customize this option to add or remove available sort orders.</span>
<span class="linecomment">;;  A better way to define a new sort order is to use macro</span>
<span class="linecomment">;;  `icicle-define-sort-command' in your Emacs init file (~/.emacs).</span>
<span class="linecomment">;;  This defines a new Icicles command, named `icicle-sort-ORDER',</span>
<span class="linecomment">;;  where `ORDER' is the name of the new sort order.  The definition</span>
<span class="linecomment">;;  of the "alphabetical" sort order provides an example:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (icicle-define-sort-command "alphabetical"</span>
<span class="linecomment">;;                                icicle-case-string-less-p</span>
<span class="linecomment">;;      "Sort completion candidates alphabetically.")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The first argument, "alphabetical", is a string naming the new</span>
<span class="linecomment">;;  sort order.  When you change to this sort order, a message says</span>
<span class="linecomment">;;  "Sorting is now alphabetical".  Whatever sort-order name you</span>
<span class="linecomment">;;  provide is used in the message.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The second argument is the actual function used for sorting.  It</span>
<span class="linecomment">;;  can be any function, including a lambda expression.  The function</span>
<span class="linecomment">;;  takes two string arguments and returns non-nil if and only if the</span>
<span class="linecomment">;;  first string sorts before (is "less than") the second.  In this</span>
<span class="linecomment">;;  case, function `icicle-case-string-less-p' is used, which compares</span>
<span class="linecomment">;;  its two arguments alphabetically (lexicographically).  The third</span>
<span class="linecomment">;;  argument is the doc string for the new sorting command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The result of this definition is:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. The creation of command `icicle-sort-alphabetical'.</span>
<span class="linecomment">;;  2. The addition of an entry for the new sort order in option</span>
<span class="linecomment">;;     `icicle-sort-functions-alist'.  The entry associates sort order</span>
<span class="linecomment">;;     "alphabetical" with comparison function</span>
<span class="linecomment">;;     `icicle-case-string-less-p'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can invoke the new sorting command any time using `M-x', but</span>
<span class="linecomment">;;  you can also change to the new sort order using `C-,' (or `M-,')</span>
<span class="linecomment">;;  during minibuffer completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Different Sorts for Different Sorts of Uses")</span>
<span class="linecomment">;;  ** Different Sorts for Different Sorts of Uses **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are many different uses of completion in Emacs, and this</span>
<span class="linecomment">;;  means that sorting candidates needs to be flexible - there cannot</span>
<span class="linecomment">;;  be a single sort order that is useful for all purposes.</span>
<span class="linecomment">;;  Completion, and therefore sorting of completion candidates, needs</span>
<span class="linecomment">;;  to deal with different types of candidates and different numbers</span>
<span class="linecomment">;;  of them, in different contexts.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles predefines several sort functions, and you can easily</span>
<span class="linecomment">;;  define more of your own.  You can choose a different sort at any</span>
<span class="linecomment">;;  time, as mentioned above.  A good sort order can be a big help,</span>
<span class="linecomment">;;  depending on the context.  However, sorting isn't free, and it's</span>
<span class="linecomment">;;  helpful to think for a moment about some of the consequences of</span>
<span class="linecomment">;;  sorting, in terms of performance.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What does a sort function do?  It determines which of two strings</span>
<span class="linecomment">;;  should come first, that is, which is "less than" the other.</span>
<span class="linecomment">;;  During sorting, pairs of candidates are compared using the sort</span>
<span class="linecomment">;;  function.  And each time you change your input by typing or</span>
<span class="linecomment">;;  deleting a character, the new set of matching candidates is sorted</span>
<span class="linecomment">;;  (if `icicle-incremental-completion-flag' is non-nil).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The number of candidates to be sorted depends on how you use</span>
<span class="linecomment">;;  Icicles.  Some Icicles users like to use cycling more and</span>
<span class="linecomment">;;  completion less, which means sorting more candidates.  Other users</span>
<span class="linecomment">;;  favor using completion to narrow down the number of matches (which</span>
<span class="linecomment">;;  I recommend).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If there are many candidates matching your input, then many</span>
<span class="linecomment">;;  comparisons will be made each time the candidate set is sorted.</span>
<span class="linecomment">;;  This means that if your sort function is complex, response can be</span>
<span class="linecomment">;;  slow.  A complex sort function might be OK for sorting a small or</span>
<span class="linecomment">;;  medium set of candidates, but it might not be appropriate for</span>
<span class="linecomment">;;  sorting a very large set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Only you, as a user, can control which sort makes the best sense</span>
<span class="linecomment">;;  for you in any given situation.  If you are likely to have</span>
<span class="linecomment">;;  zillions of candidates in some context, then you probably will</span>
<span class="linecomment">;;  want to change to a sort that computes quickly.  You can, of</span>
<span class="linecomment">;;  course, even choose not to sort at all, but simple sort</span>
<span class="linecomment">;;  comparisons don't noticeably impact performance, even for a very</span>
<span class="linecomment">;;  large number of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles could offer a threshold option similar to</span>
<span class="linecomment">;;  `icicle-incremental-completion-threshold' (or it could reuse that</span>
<span class="linecomment">;;  option), and not bother to sort if the number of candidates passed</span>
<span class="linecomment">;;  the threshold, but there can be many sort orders of differing</span>
<span class="linecomment">;;  complexity, so a set of thresholds would really be needed, perhaps</span>
<span class="linecomment">;;  one per sort order.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Rather than having you try to manage such complexity ahead of time</span>
<span class="linecomment">;;  using options, it's better to just let you manage it at completion</span>
<span class="linecomment">;;  time: Choose the sort order with knowledge of the possible</span>
<span class="linecomment">;;  candidate set.  For example, if the set of candidates to sort will</span>
<span class="linecomment">;;  include every file on your file system, then you probably will</span>
<span class="linecomment">;;  want to use a simple sort.  On the other hand, there are</span>
<span class="linecomment">;;  situations where you might nevertheless prefer to wait a few</span>
<span class="linecomment">;;  seconds, in order to perform a complex sort that is of particular</span>
<span class="linecomment">;;  use.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In sum, Icicles keeps it simple, and leaves it up to you to choose</span>
<span class="linecomment">;;  the appropriate sort order for any given context.  This design</span>
<span class="linecomment">;;  choice is one reason why Icicles makes it easy to choose a sort</span>
<span class="linecomment">;;  even while you are completing input - each act of completion is</span>
<span class="linecomment">;;  different.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It can help you choose, however, to know which of the predefined</span>
<span class="linecomment">;;  Icicles sort orders are more complex, and therefore tend to be</span>
<span class="linecomment">;;  slower.  Here they are:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Sort Order                      Sort Function Used</span>
<span class="linecomment">;;    ----------                      ------------------</span>
<span class="linecomment">;;    by previous use alphabetically  `icicle-historical-alphabetic-p'</span>
<span class="linecomment">;;    by last use                     `icicle-most-recent-first-p'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The reason these sorts are slower is that they check the current</span>
<span class="linecomment">;;  minibuffer history, to see whether, and where, each candidate is</span>
<span class="linecomment">;;  located in the history list.  If you, like I, have very long</span>
<span class="linecomment">;;  history lists, then this can take a while.  I use histories of</span>
<span class="linecomment">;;  virtually unlimited length - I let library `savehist-20+.el' save</span>
<span class="linecomment">;;  all of my histories from one Emacs session to the next.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here are some of the Icicles sort orders that exist by default:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - alphabetical - see</span>
<span class="linecomment">;;      (@&gt; "Putting Previous Candidates First: `C-M-,'")</span>
<span class="linecomment">;;      by color name - see</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc2.el" :to "Candidates with Text Properties")</span>
<span class="linecomment">;;      by color hue</span>
<span class="linecomment">;;      by color purity (saturation)</span>
<span class="linecomment">;;      by color brightness (value)</span>
<span class="linecomment">;;      by amount of red</span>
<span class="linecomment">;;      by amount of green</span>
<span class="linecomment">;;      by amount of blue</span>
<span class="linecomment">;;      by color rgb</span>
<span class="linecomment">;;   22 by key name, prefix keys first - see (@&gt; "Completing Prefix Keys")</span>
<span class="linecomment">;;   22 by key name, local bindings first - see</span>
<span class="linecomment">;;      (@&gt; "Local Bindings Are Highlighted")</span>
<span class="linecomment">;;   22 by command name</span>
<span class="linecomment">;;    - special candidates first - see</span>
<span class="linecomment">;;      (@&gt; "Local Bindings Are Highlighted"),</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc2.el" :to "Candidates with Text Properties"),</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc2.el" :to "Icicles OO: Object-Action Interaction")</span>
<span class="linecomment">;;    - proxy candidates first - see (&gt; "*Completions* Display")</span>
<span class="linecomment">;;    - extra candidates first - see</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc2.el" :to "Global Filters")</span>
<span class="linecomment">;;    - by second multi-completion part - see</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc2.el" :to "Sorting Candidates by Their Second Part")</span>
<span class="linecomment">;;    - case-insensitive - (@&gt; "Completion Status Indicators")</span>
<span class="linecomment">;;    - by last file modification time - see</span>
<span class="linecomment">;;      (@&gt; "Icicles Commands that Read File Names")</span>
<span class="linecomment">;;    - by directories last</span>
<span class="linecomment">;;    - by last use</span>
<span class="linecomment">;;    - by abbrev frequency - see</span>
<span class="linecomment">;;      (@&gt; "Multi `M-x' Turns Every Command into a Multi-Command")</span>
<span class="linecomment">;;    - by previous use alphabetically - see</span>
<span class="linecomment">;;      (@&gt; "Putting Previous Candidates First: `C-M-,'")</span>
<span class="linecomment">;;    - in book order (for Info) - see</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc2.el" :to "Icicles Completion for Info")</span>
<span class="linecomment">;;    - turned OFF  (does not sort at all)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As you can see, some are appropriate only for color completion,</span>
<span class="linecomment">;;  and some are appropriate for file-name completion.  The latter</span>
<span class="linecomment">;;  sort alphabetically when completion is not for file names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Those with `22' can be used only with Emacs 22 or later.  Those</span>
<span class="linecomment">;;  marked with a hyphen (-) are defined using</span>
<span class="linecomment">;;  `icicle-define-sort-command', so they correspond to explicit</span>
<span class="linecomment">;;  commands whose doc you can examine.  The command names in this</span>
<span class="linecomment">;;  case are `icicle-sort-' followed by the sort-order names (with</span>
<span class="linecomment">;;  hyphens substituted for spaces),</span>
<span class="linecomment">;;  e.g. `icicle-sort-by-directories-last' and</span>
<span class="linecomment">;;  `icicle-sort-turned-OFF'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Customization and General Tips")</span>
<span class="linecomment">;;    for more about `icicle-buffer-sort' and other buffer-name</span>
<span class="linecomment">;;    completion parameters.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Global Filters") for a</span>
<span class="linecomment">;;    way to filter and sort the domain of discourse, that is, all</span>
<span class="linecomment">;;    possible candidates, prior to any use of completion.</span>
 
<span class="linecomment">;;(@* "Get Help on Candidates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Get Help on Candidates</span>
<span class="linecomment">;;  ----------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  General Icicles help is available at any time during minibuffer</span>
<span class="linecomment">;;  input, by hitting `C-?' (`icicle-minibuffer-help').  This section</span>
<span class="linecomment">;;  is about specific help on individual completion candidates</span>
<span class="linecomment">;;  instead.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  While you are cycling among candidates for input to a command, you</span>
<span class="linecomment">;;  can simultaneously display help on each candidate or any given</span>
<span class="linecomment">;;  candidate.  To show help on each candidate as you cycle, press and</span>
<span class="linecomment">;;  hold the Control and Meta keys while using the vertical arrow</span>
<span class="linecomment">;;  keys, for prefix completion, or the `prior' and `next' keys (often</span>
<span class="linecomment">;;  labeled Page Up and Page Down), for apropos completion.  To show</span>
<span class="linecomment">;;  help on any individual candidate, just navigate to it (by cycling</span>
<span class="linecomment">;;  or using completion), and hit `C-M-RET' - or press Control and</span>
<span class="linecomment">;;  Meta and click it with `mouse-2' (`C-M-mouse-2') in buffer</span>
<span class="linecomment">;;  `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, if you use standard command `switch-to-buffer' and</span>
<span class="linecomment">;;  you cycle among candidate buffers with `C-M-down' (prefix</span>
<span class="linecomment">;;  completion), then the major and minor modes of each candidate</span>
<span class="linecomment">;;  buffer are described in buffer *Help* as the buffer name appears</span>
<span class="linecomment">;;  in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, you need not use the Meta key for candidate help; the</span>
<span class="linecomment">;;  same bindings work with just the Control key.  So, for example,</span>
<span class="linecomment">;;  you can click `C-mouse-2' to get help on a candidate or use</span>
<span class="linecomment">;;  `C-next' to cycle candidate help information.  However, Icicles</span>
<span class="linecomment">;;  multi-commands often have a different use for these bindings that</span>
<span class="linecomment">;;  do not include Meta.  It is only by default, when a multi-command</span>
<span class="linecomment">;;  has not bound a more specific action to the plain Control</span>
<span class="linecomment">;;  bindings, that you can use the sans-Meta bindings for help on</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, Icicles binds `M-x', `C-x b', and `C-x C-f' to</span>
<span class="linecomment">;;  multi-commands that execute a command, switch to a buffer, and</span>
<span class="linecomment">;;  open a file, respectively.  If you use only the Control key,</span>
<span class="linecomment">;;  without the Meta key, when choosing candidates for these commands,</span>
<span class="linecomment">;;  you will not get help on the candidates; instead, you will execute</span>
<span class="linecomment">;;  a candidate command, switch to a candidate buffer, and open a</span>
<span class="linecomment">;;  candidate file, respectively.  For more information, see</span>
<span class="linecomment">;;  (@&gt; "Multi-Commands").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Use Candidate Help Like You Use Emacs Command `apropos'")</span>
<span class="linecomment">;;  ** Use Candidate Help Like You Use Emacs Command `apropos' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use this candidate-help functionality as a kind of</span>
<span class="linecomment">;;  expanded `apropos' functionality.  As an example, type `C-h v</span>
<span class="linecomment">;;  out', then type `S-TAB' to display all variables that match "out"</span>
<span class="linecomment">;;  (in buffer `*Completions*').  Then use `C-M-next' repeatedly to</span>
<span class="linecomment">;;  cycle among those variables, displaying their documentation in the</span>
<span class="linecomment">;;  *Help* buffer as they appear one by one in the minibuffer.  Or</span>
<span class="linecomment">;;  click individual variable names with `C-M-mouse-2', to display</span>
<span class="linecomment">;;  their documentation.  The standard `apropos' commands show only</span>
<span class="linecomment">;;  the first doc-string line; Icicles shows the complete doc string.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This can be handy, for instance, when you are unsure which of</span>
<span class="linecomment">;;  several similarly named candidates to choose.  Seeing a</span>
<span class="linecomment">;;  candidate's documentation along with its name can help you decide.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can click links in buffer *Help* to look up more info, and</span>
<span class="linecomment">;;  then resume `C-M-next' where you left off, all without leaving</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This also works with menu items, if you load library `lacarte.el'</span>
<span class="linecomment">;;  as well as Icicles.  As you cycle among matching menu items, the</span>
<span class="linecomment">;;  corresponding command documentation is displayed in *Help*.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you also use library `help-fns+.el' (Emacs 22 or later) or</span>
<span class="linecomment">;;  library `help+.el' (or `help+20.el' for Emacs 20), then you can</span>
<span class="linecomment">;;  use these Icicles features with additional help commands such as</span>
<span class="linecomment">;;  `describe-keymap' (`C-h M-k'), `describe-command' (`C-h C-c'),</span>
<span class="linecomment">;;  `describe-option' (`C-h o'), and `describe-option-of-type'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-h C-o', which is bound by those libraries to command</span>
<span class="linecomment">;;  `describe-option-of-type', is bound in Icicle mode to</span>
<span class="linecomment">;;  `icicle-describe-option-of-type' instead, which uses</span>
<span class="linecomment">;;  multi-completion and is therefore more powerful.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc2.el" :to "Multi-Completions").</span>
<span class="linecomment">;;  `C-h C-o' describes a user option that is of a particular custom</span>
<span class="linecomment">;;  type: you match the type and the option name at the same time.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an example, try `C-h C-o ici C-M-j string S-TAB' (`C-M-j' just</span>
<span class="linecomment">;;  separates the option name and type parts).  In buffer</span>
<span class="linecomment">;;  *Completions*, you see all options whose name contains `ici' and</span>
<span class="linecomment">;;  whose type (or an inherited type) definition contains `string'.</span>
<span class="linecomment">;;  That means not only options that are strings, but options that are</span>
<span class="linecomment">;;  lists that contain string elements, options that can be a string</span>
<span class="linecomment">;;  or something else, and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Browse the doc for these options, one after the other, using</span>
<span class="linecomment">;;  `C-M-next'.  This is a way to see, at the same time, the</span>
<span class="linecomment">;;  documentation for individual options (in buffer *Help*) and the</span>
<span class="linecomment">;;  types their values must satisfy (in *Completions*).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And remember that you can leave the option-name part or the type</span>
<span class="linecomment">;;  part empty, to see all options of a certain type or options of all</span>
<span class="linecomment">;;  types with a certain name pattern.  For example, `C-h C-o .* C-M-j</span>
<span class="linecomment">;;  string S-TAB' or `C-h C-o ici S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And you can of course use progressive completion as well, to</span>
<span class="linecomment">;;  match, say, a type that has a `string' component and an `integer'</span>
<span class="linecomment">;;  component - or whatever.  The type part of a completion candidate</span>
<span class="linecomment">;;  is an entire `defcustom' type, so its `:tag' values are also</span>
<span class="linecomment">;;  included.  This means that you can also match against the</span>
<span class="linecomment">;;  descriptive text (tag) that appears next to a value component in</span>
<span class="linecomment">;;  Customize.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-h C-o' is a powerful way to browse options and their</span>
<span class="linecomment">;;  documentation.  See the doc string of</span>
<span class="linecomment">;;  `icicle-describe-option-of-type' for more possibilities.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Candidate help (prefix `C-M-') is available for these types of</span>
<span class="linecomment">;;  completion candidates, by default:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * menu items</span>
<span class="linecomment">;;  * commands and other functions</span>
<span class="linecomment">;;  * keymap variables (if `describe-keymap' is defined - see</span>
<span class="linecomment">;;    library `help-fns+.el')</span>
<span class="linecomment">;;  * user options and other variables</span>
<span class="linecomment">;;  * faces</span>
<span class="linecomment">;;  * command abbreviations (using `apropos-command' for matches)</span>
<span class="linecomment">;;  * property lists</span>
<span class="linecomment">;;  * buffers</span>
<span class="linecomment">;;  * files</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, any command that uses completion can define its own</span>
<span class="linecomment">;;  candidate help action function and bind it to</span>
<span class="linecomment">;;  `icicle-candidate-help-fn'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For more information about the types of candidates and their</span>
<span class="linecomment">;;  associated documentation, see the documentation for command</span>
<span class="linecomment">;;  `icicle-help-on-candidate'.  This command is bound to `C-M-RET',</span>
<span class="linecomment">;;  `C-M-mouse-2', `C-help', `C-M-help', `C-f1', and `C-M-f1'.  When</span>
<span class="linecomment">;;  no specific action is defined for candidates, it is also bound to</span>
<span class="linecomment">;;  `C-RET' and `C-mouse-2'.  You can use this to get help on any</span>
<span class="linecomment">;;  completion candidate during completion.  See also the related</span>
<span class="linecomment">;;  help-cycling commands, `icicle-help-on-next-apropos-candidate' and</span>
<span class="linecomment">;;  so on, bound to `C-M-next', `C-M-prior', `C-M-down', and `C-M-up'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use one-buffer-per-frame (`pop-up-frames' non-nil), then</span>
<span class="linecomment">;;  displaying *Help* in one frame might interfere with viewing</span>
<span class="linecomment">;;  `*Completions*' in another.  For that reason, the `*Completions*'</span>
<span class="linecomment">;;  frame is raised to the front.  Also, if user option</span>
<span class="linecomment">;;  `icicle-Completions-frame-at-right-flag' is non-nil (default</span>
<span class="linecomment">;;  value: `t'), then the `*Completions*' frame is moved to the right,</span>
<span class="linecomment">;;  out of the way, whenever you access help on a candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Other Icicles Apropos Commands")</span>
<span class="linecomment">;;  ** Other Icicles Apropos Commands **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are also Icicles replacements for the standard Emacs</span>
<span class="linecomment">;;  `apropos' commands.  They act similarly, but they also let you see</span>
<span class="linecomment">;;  the list of regexp matches incrementally (as with all Icicles</span>
<span class="linecomment">;;  commands), using `S-TAB'.  If you also use my library</span>
<span class="linecomment">;;  `apropos-fn+var.el', then these Icicles commands take advantage of</span>
<span class="linecomment">;;  the apropos enhancements in that library.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The Icicles apropos commands are: `icicle-apropos',</span>
<span class="linecomment">;;  `icicle-apropos-command', `icicle-apropos-function',</span>
<span class="linecomment">;;  `icicle-apropos-option', `icicle-apropos-variable', and</span>
<span class="linecomment">;;  `icicle-apropos-zippy'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another feature of these Icicles commands is that when more than</span>
<span class="linecomment">;;  one type of object can be a candidate, candidates of a certain</span>
<span class="linecomment">;;  type are shown in buffer `*Completions*' using face</span>
<span class="linecomment">;;  `icicle-special-candidate'.  For example, command `icicle-apropos'</span>
<span class="linecomment">;;  shows function names as special candidates, to help you</span>
<span class="linecomment">;;  distinguish them from variable names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, Icicles commands `icicle-doc', `icicle-fundoc', and</span>
<span class="linecomment">;;  `icicle-vardoc' provide the functionality of standard Emacs</span>
<span class="linecomment">;;  command `apropos-documentation', but with additional features -</span>
<span class="linecomment">;;  see (@file :file-name "icicles-doc2.el" :to "Multi-Completions").</span>
<span class="linecomment">;;  In addition, you can use command `icicle-plist' to find symbols</span>
<span class="linecomment">;;  with certain property-list keys and values, and you can use</span>
<span class="linecomment">;;  command `icicle-describe-option-of-type' (bound to `C-h C-o') to</span>
<span class="linecomment">;;  find user options of a certain type.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-customize-apropos-options-of-type' is similar to</span>
<span class="linecomment">;;  `icicle-describe-option-of-type', in that it lets you specify the</span>
<span class="linecomment">;;  type of matching options.  But instead of describing an option, it</span>
<span class="linecomment">;;  opens Customize for all options of the specified type that match</span>
<span class="linecomment">;;  your input regexp.  (Unlike `icicle-describe-option-of-type',</span>
<span class="linecomment">;;  however, it is not a multi-completion command: you first specify</span>
<span class="linecomment">;;  the type, then the regexp to match.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One difference between Icicles apropos commands and the standard</span>
<span class="linecomment">;;  commands, besides the Icicles enhancements already described, is</span>
<span class="linecomment">;;  that (starting with Emacs 22) the standard commands let you input</span>
<span class="linecomment">;;  a set of keywords, as an alternative to inputting a regexp.</span>
<span class="linecomment">;;  Icicles apropos commands do not allow for keyword input, as such.</span>
<span class="linecomment">;;  However, Icicles progressive completion provides a more powerful</span>
<span class="linecomment">;;  way to search with multiple keywords (in fact, multiple regexps) -</span>
<span class="linecomment">;;  you can of course use it with the Icicles apropos commands.  Also,</span>
<span class="linecomment">;;  there are several problems with the standard Emacs apropos</span>
<span class="linecomment">;;  commands, with respect to interpreting your input as either a set</span>
<span class="linecomment">;;  of keywords or a regexp.  Because they allow two very different</span>
<span class="linecomment">;;  syntaxes as input, the standard apropos commands are forced to</span>
<span class="linecomment">;;  make some limiting compromises for keyword searching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: (@&gt; "Progressive Completion").</span>
 
<span class="linecomment">;;(@* "Multi-Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Multi-Commands</span>
<span class="linecomment">;;  --------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "What Is a Multi-Command?")</span>
<span class="linecomment">;;  ** What Is a Multi-Command? **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A multi-command is a command that lets you make multiple input</span>
<span class="linecomment">;;  choices in a single command execution: a multiple-choice command.</span>
<span class="linecomment">;;  You can choose multiple items from a set of choices, using buffer</span>
<span class="linecomment">;;  `*Completions*' as a multiple-choice "menu".  (It's not necessary</span>
<span class="linecomment">;;  to display `*Completions*', however.)  Instead of asking you</span>
<span class="linecomment">;;  "Which file do you want to delete?", a multi-command asks you, in</span>
<span class="linecomment">;;  effect, "Which file(S) do you want to delete?".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Nothing especially new here.  Any Emacs command could be defined</span>
<span class="linecomment">;;  to use an input loop, asking for file names until you do something</span>
<span class="linecomment">;;  to signal that you're done inputting.  It could provide for</span>
<span class="linecomment">;;  file-name completion by calling `read-file-name' to read your</span>
<span class="linecomment">;;  input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * But what if you could also filter the domain of discourse on the</span>
<span class="linecomment">;;    fly, so that the candidate files were only those matching a</span>
<span class="linecomment">;;    regular expression (regexp) that you typed? Then, the command</span>
<span class="linecomment">;;    definition would need to provide for that behavior too.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * And what if you could then take the complement of that set of</span>
<span class="linecomment">;;    candidate file names, with respect to the complete set of files</span>
<span class="linecomment">;;    in the directory? Or subtract (exclude) some set of file names</span>
<span class="linecomment">;;    from the set of matching names, to get the set of possible</span>
<span class="linecomment">;;    choices?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * And what if the set of potential candidates at each step (regexp</span>
<span class="linecomment">;;    match, complement, set difference) could also be displayed in a</span>
<span class="linecomment">;;    multiple-choice menu?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For such multi-command functionality you need Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can tell whether a command is a multi-command when you execute</span>
<span class="linecomment">;;  it: if it is a multi-command, then the prompt is prefixed by `+'.</span>
<span class="linecomment">;;  For example, multi-command `icicle-file' uses this prompt:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    + File or directory:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Normal, non multi-command `find-file' uses this prompt, which has</span>
<span class="linecomment">;;  no `+':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Find file:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just remember that `+' means that you can choose any number of</span>
<span class="linecomment">;;  inputs.  For a list of predefined Icicles multi-commands, use</span>
<span class="linecomment">;;  `C-?' (`icicle-minibuffer-help') in the minibuffer - search for</span>
<span class="linecomment">;;  `+' at the beginning of a line.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "How Does a Multi-Command Work?")</span>
<span class="linecomment">;;  ** How Does a Multi-Command Work? **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When an Icicles multi-command prompts you for input, you can make</span>
<span class="linecomment">;;  a single choice and press `RET' to confirm it, as usual, or you</span>
<span class="linecomment">;;  can choose any number of completion candidates, using `C-RET' (or</span>
<span class="linecomment">;;  `C-mouse-2') for each.  You can thus act on multiple candidates,</span>
<span class="linecomment">;;  or even multiple times on the same candidate, during the same</span>
<span class="linecomment">;;  execution of the command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But you don't have to - you can use any multi-command just as if</span>
<span class="linecomment">;;  it were a normal, single-choice command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, command `icicle-delete-file' lets you delete a single</span>
<span class="linecomment">;;  file or a set of files that match your minibuffer input - all in</span>
<span class="linecomment">;;  the same command execution.  If you type no input, then all files</span>
<span class="linecomment">;;  in the current directory match, and you can delete any number of</span>
<span class="linecomment">;;  them individually.  If you type `~$' and hit `S-TAB'</span>
<span class="linecomment">;;  (`icicle-apropos-complete'), then all files that end in `~' match,</span>
<span class="linecomment">;;  and you can delete any number of them.  Similarly, command</span>
<span class="linecomment">;;  `icicle-buffer-other-window' lets you display any number of</span>
<span class="linecomment">;;  buffers, and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You make multiple choices this way by cycling through the</span>
<span class="linecomment">;;  candidate completions, as usual, and hitting `C-RET' whenever you</span>
<span class="linecomment">;;  want to choose (act on) the current cycle candidate.  Or just</span>
<span class="linecomment">;;  press and hold Control while clicking each chosen candidate with</span>
<span class="linecomment">;;  `mouse-2'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Similarly, you can use `C-next', `C-prior', `C-down', and `C-up'</span>
<span class="linecomment">;;  to act on successive candidates, forward or backward.  You can</span>
<span class="linecomment">;;  thus just hold down the Control key while cycling, to act on each</span>
<span class="linecomment">;;  candidate in turn, if you want.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Instead of, or in addition to, cycling, you can use completion to</span>
<span class="linecomment">;;  get to a particular candidate you want.  No matter how a candidate</span>
<span class="linecomment">;;  is made current, you can choose the current candidate (perform the</span>
<span class="linecomment">;;  action on it) using `C-RET' or `C-mouse-2'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For lax (permissive) completion, you can act on any input text</span>
<span class="linecomment">;;  with `C-RET' (but not with the other multi-command keys) -- you</span>
<span class="linecomment">;;  need not choose one of the available candidates.  This means, for</span>
<span class="linecomment">;;  example, that you can create any number of new file buffers with a</span>
<span class="linecomment">;;  single `C-x C-f' invocation, as well as open any number of</span>
<span class="linecomment">;;  existing files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As always, hitting `RET' (or `S-RET') ends the command.  For most</span>
<span class="linecomment">;;  multi-commands, hitting `RET' performs the same action as `C-RET',</span>
<span class="linecomment">;;  but it is possible to have a command that acts differently for</span>
<span class="linecomment">;;  `RET' and `C-RET'.  That is the case, for instance, when help is</span>
<span class="linecomment">;;  displayed via `C-RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `C-RET' or `C-mouse-2' repeatedly to act multiple</span>
<span class="linecomment">;;  times on the same candidate.  A shortcut is to use `C-u' with</span>
<span class="linecomment">;;  `C-RET' or `C-mouse-2'.  That will work if the candidate action</span>
<span class="linecomment">;;  function is designed to be `C-u' sensitive.  This is the case for</span>
<span class="linecomment">;;  the Icicles multi-commands that read the name of a command or</span>
<span class="linecomment">;;  keyboard macro and execute the command or macro:</span>
<span class="linecomment">;;  `icicle-execute-extended-command' (`M-x'), `icicle-kmacro'</span>
<span class="linecomment">;;  (`S-f4'), and `icicle-execute-named-keyboard-macro' (`C-x M-e').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So, for example, if you use `C-u 10 C-RET' on command</span>
<span class="linecomment">;;  `forward-char' during `M-x' command completion, the cursor</span>
<span class="linecomment">;;  advances 10 characters.  Another example: `C-x M-e C-u 200 C-RET'</span>
<span class="linecomment">;;  on a keyboard-macro candidate `foo' executes `foo' 200 times.  You</span>
<span class="linecomment">;;  can use all of the numeric prefix argument shortcuts, such as</span>
<span class="linecomment">;;  `M--', `M-7', and `C-6', with the exception of `C--', which has a</span>
<span class="linecomment">;;  different meaning (`icicle-candidate-set-difference') in the</span>
<span class="linecomment">;;  Icicles minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that you can supply a prefix argument for both the</span>
<span class="linecomment">;;  multi-command and any of its individual actions.  The command is</span>
<span class="linecomment">;;  free to interpret these differently.  For example, a prefix arg</span>
<span class="linecomment">;;  for `icicle-kmacro' provides a default repeat factor, which can</span>
<span class="linecomment">;;  then be overridden for any individual action by providing a</span>
<span class="linecomment">;;  different prefix arg.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If user option `icicle-use-candidates-only-once-flag' is non-nil,</span>
<span class="linecomment">;;  then, when you act on a candidate, it is removed from the list of</span>
<span class="linecomment">;;  available candidates, for clarity.  Commands where this behavior</span>
<span class="linecomment">;;  is appropriate bind this option to a non-nil value.  This is a</span>
<span class="linecomment">;;  user option, but you normally will not customize it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `C-g' to exit a multi-command at any time, without</span>
<span class="linecomment">;;  making a final choice using `RET'.  If the actions performed by a</span>
<span class="linecomment">;;  multi-command are easily reversible, `C-g' will often restore</span>
<span class="linecomment">;;  things to the way they were before performing the actions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Does this `C-RET' stuff sound familiar?  Using a multi-command is</span>
<span class="linecomment">;;  similar to accessing help on a candidate</span>
<span class="linecomment">;;  (see (@&gt; "Get Help on Candidates")).  A multi-command is any</span>
<span class="linecomment">;;  command that has a special action defined for use with `C-RET'</span>
<span class="linecomment">;;  (command `icicle-candidate-action') on the current cycle</span>
<span class="linecomment">;;  candidate.  If no such special action is defined, then help on the</span>
<span class="linecomment">;;  candidate is displayed - displaying help is just the default</span>
<span class="linecomment">;;  action for `C-RET', used when no other action is defined.  You can</span>
<span class="linecomment">;;  always access candidate help using the `C-M-' prefix: `C-M-help',</span>
<span class="linecomment">;;  `C-M-f1', `C-M-RET', `C-M-mouse-2', `C-M-next', `C-M-prior',</span>
<span class="linecomment">;;  `C-M-down', and `C-M-up'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also cycle among elements of a set, performing actions, if</span>
<span class="linecomment">;;  you use my libraries `doremi.el', `doremi-cmd.el', and</span>
<span class="linecomment">;;  `doremi-frm.el'.  Like Icicles, DoReMi lets you see the effect of</span>
<span class="linecomment">;;  a choice immediately, whenever you make changes.  Each library has</span>
<span class="linecomment">;;  its own advantages and special uses.  Advantages of Icicles</span>
<span class="linecomment">;;  include:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - completion to candidate values</span>
<span class="linecomment">;;    - restoration after making changes, letting you preview changes</span>
<span class="linecomment">;;      without actually applying them</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "More about Multi-Commands") for more about using</span>
<span class="linecomment">;;    multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Defining Icicles Commands (Including Multi-Commands)")</span>
<span class="linecomment">;;    for how to define your own multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Moving Between the Minibuffer and Other Buffers").</span>
 
<span class="linecomment">;;(@* "More about Multi-Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  More about Multi-Commands</span>
<span class="linecomment">;;  -------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A multi-command is any command that uses input completion and lets</span>
<span class="linecomment">;;  you perform actions on any number of individual completion</span>
<span class="linecomment">;;  candidates without exiting completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The default action is invoked on the current candidate by `C-RET'</span>
<span class="linecomment">;;  (`icicle-candidate-action').  There are three other kinds of</span>
<span class="linecomment">;;  actions on individual candidates:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * alternative actions, invoked by `C-S-RET'</span>
<span class="linecomment">;;  * deletion actions, invoked by `S-delete'</span>
<span class="linecomment">;;  * help actions, invoked by `C-M-RET'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A given command can define any combination of these four kinds of</span>
<span class="linecomment">;;  actions: none of them, any one of them, any two of them, any three</span>
<span class="linecomment">;;  of them, or all four kinds.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section provides information about alternative actions and</span>
<span class="linecomment">;;  deletion actions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Get Help on Candidates") for information about using</span>
<span class="linecomment">;;    candidate help.</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Defining Multi-Commands the Hard Way")</span>
<span class="linecomment">;;    for information about defining a custom candidate-help action</span>
<span class="linecomment">;;    for a command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Alternative Actions")</span>
<span class="linecomment">;;  ** Alternative Actions **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just as you can use `C-RET', `C-mouse-2', `C-next', and so on to</span>
<span class="linecomment">;;  invoke a command's default action on multiple completion</span>
<span class="linecomment">;;  candidates individually, so you can use `C-S-RET'</span>
<span class="linecomment">;;  (`icicle-candidate-alt-action'), `C-S-mouse-2', `C-S-next', and so</span>
<span class="linecomment">;;  on to invoke an alternative action that is associated with the</span>
<span class="linecomment">;;  command.  If the main action of a command `my-find-file' is to</span>
<span class="linecomment">;;  open a file, and the alternative action is to print a file, then</span>
<span class="linecomment">;;  you can use `C-S-RET' to print files even as you are completing</span>
<span class="linecomment">;;  the name of a file to be opened.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Keys `C-|' and `M-|' apply the alternative action defined for a</span>
<span class="linecomment">;;  given multi-command to all matching candidates, in the same way</span>
<span class="linecomment">;;  that `C-!' and `M-!' apply the normal action defined for it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles search (e.g. `C-c `') is an example of a command where you</span>
<span class="linecomment">;;  can use the alternative action - it replaces all or part of the</span>
<span class="linecomment">;;  current search hit.  It is likely that there will be more commands</span>
<span class="linecomment">;;  that provide alternative actions in the future.  And Emacs-Lisp</span>
<span class="linecomment">;;  programmers can define their own commands to take advantage of</span>
<span class="linecomment">;;  this feature.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Search and Replace")</span>
<span class="linecomment">;;  * (@* "Choose All Completion Candidates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Deleting Objects")</span>
<span class="linecomment">;;  ** Deleting Objects **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When it is defined for a particular command, minibuffer command</span>
<span class="linecomment">;;  `icicle-delete-candidate-object', bound to `S-delete' (that's the</span>
<span class="linecomment">;;  `delete' key, Shifted), deletes the object or objects named by the</span>
<span class="linecomment">;;  completion candidate on which it operates.  (At least that is the</span>
<span class="linecomment">;;  default behavior - if you customize `icicle-deletion-action-flag'</span>
<span class="linecomment">;;  to nil, then `S-delete' has no effect.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Which objects are thus targeted by a given candidate (name) is</span>
<span class="linecomment">;;  something that must be defined by the particular command.  The doc</span>
<span class="linecomment">;;  string of a command should always indicate the effect of using</span>
<span class="linecomment">;;  `S-delete', if a deletion action is defined.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an example of a deletion action, Icicles command</span>
<span class="linecomment">;;  `icicle-buffer-other-window', bound to `C-x 4 b', opens buffers</span>
<span class="linecomment">;;  named by the individual candidates you act on, using `C-RET'.  But</span>
<span class="linecomment">;;  it also kills any buffer that you act on, using `S-delete'.  This</span>
<span class="linecomment">;;  is not the alternative action for the command (which is bound to</span>
<span class="linecomment">;;  `C-S-RET'); it is the deletion action.  Similarly, command</span>
<span class="linecomment">;;  `icicle-select-region', bound to `C-u C-x C-x', selects regions,</span>
<span class="linecomment">;;  but you can also use `S-delete' with it to remove individual</span>
<span class="linecomment">;;  regions from the list of saved regions, `icicle-region-alist'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you use `S-delete' with commands, such as</span>
<span class="linecomment">;;  `icicle-select-region' (`C-u C-x C-x'), that allow duplicate</span>
<span class="linecomment">;;  candidate names that represent different candidate objects, it</span>
<span class="linecomment">;;  deletes only the object associated with the current candidate</span>
<span class="linecomment">;;  (name).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Some multi-commands define a deletion action, so that `S-delete'</span>
<span class="linecomment">;;  works; some do not.  Consult the doc for any given command to see</span>
<span class="linecomment">;;  if it does.  Whenever it is defined, the meaning of "delete"</span>
<span class="linecomment">;;  depends on the particular command you use.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `S-delete' deletes only the objects named by the current</span>
<span class="linecomment">;;  completion candidate.  However, with a prefix argument, it deletes</span>
<span class="linecomment">;;  *ALL* objects named by the current set of completion candidates,</span>
<span class="linecomment">;;  after you confirm that this is really what you want to do.  This</span>
<span class="linecomment">;;  is a quick way to delete things whenever `S-delete' is available:</span>
<span class="linecomment">;;  Use input patterns, with progressive completion, chipping away,</span>
<span class="linecomment">;;  and so on, to define the candidates to delete, then use `C-u</span>
<span class="linecomment">;;  S-delete' and confirm their deletion.  Bye-bye.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Don't confuse the unshifted `delete' key with `S-delete'.</span>
<span class="linecomment">;;  `delete' does not delete any objects; it just removes a completion</span>
<span class="linecomment">;;  candidate so that you can't complete to it.  `S-delete' deletes an</span>
<span class="linecomment">;;  object and removes its name as a completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you are an Emacs-Lisp programmer, then you can define your own</span>
<span class="linecomment">;;  multi-commands that provide a deletion action via `S-delete'.</span>
<span class="linecomment">;;  There are two ways to do this.  Both involve binding</span>
<span class="linecomment">;;  `icicle-delete-candidate-object':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Bind it to a deletion function.  The function must accept a</span>
<span class="linecomment">;;    completion candidate string and perform the deletion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Bind it to a symbol (variable) whose value is a list of</span>
<span class="linecomment">;;    completion-candidate objects.  The entries in the list must be</span>
<span class="linecomment">;;    completion candidates for the current call to `completing-read',</span>
<span class="linecomment">;;    but the list itself need not be the COLLECTION argument to</span>
<span class="linecomment">;;    `completing-read'.  The list can be an alist, a list of strings,</span>
<span class="linecomment">;;    or a list of symbols.  The object that corresponds to the</span>
<span class="linecomment">;;    current candidate when `S-delete' is invoked is deleted from the</span>
<span class="linecomment">;;    list.  If, in addition, the list variable is a user option, then</span>
<span class="linecomment">;;    the updated list value is saved in the user's custom file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For more information about using this feature in Emacs-Lisp code,</span>
<span class="linecomment">;;  see the doc of function `icicle-delete-current-candidate-object'</span>
<span class="linecomment">;;  (`S-delete') and variable `icicle-delete-candidate-object'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Option `icicle-use-C-for-actions-flag'")</span>
<span class="linecomment">;;  ** "Option `icicle-use-C-for-actions-flag' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In some contexts, you end up using `C-next' more than `next', and</span>
<span class="linecomment">;;  likewise for the other keys that combine candidate action and</span>
<span class="linecomment">;;  cycling.  This is especially true for Icicles multi-commands that</span>
<span class="linecomment">;;  act like a browser, such as `icicle-search', `icicle-imenu',</span>
<span class="linecomment">;;  `icicle-find-tag', `icicle-Info-goto-node', and</span>
<span class="linecomment">;;  `icicle-compilation-search'.  In these cases, you use the action</span>
<span class="linecomment">;;  keys to navigate among the locations indicated by the completion</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you set user option `icicle-use-C-for-actions-flag' to nil,</span>
<span class="linecomment">;;  then the keys that cycle are swapped with the keys that both cycle</span>
<span class="linecomment">;;  and act on a candidate.  You can then use `down', `up', `next',</span>
<span class="linecomment">;;  and `prior' to both cycle and act (e.g. navigate), and `C-down',</span>
<span class="linecomment">;;  `C-up', `C-next', and `C-prior' to merely cycle, without acting.</span>
<span class="linecomment">;;  The option has no effect on other keys.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can toggle `icicle-use-C-for-actions-flag' at any time using</span>
<span class="linecomment">;;  `M-g' (`icicle-toggle-C-for-actions') in the minibuffer.</span>
 
<span class="linecomment">;;(@* "Icicles Tripping")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Tripping with Icicles</span>
<span class="linecomment">;;  ---------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Among the more useful multi-commands are those whose actions take</span>
<span class="linecomment">;;  you to some location indicated by the completion candidate.  This</span>
<span class="linecomment">;;  is the way commands such as `icicle-bookmark', `icicle-find-tag',</span>
<span class="linecomment">;;  `icicle-Info-goto-node', and `icicle-occur' work - you can use</span>
<span class="linecomment">;;  `next' and so on to move among candidates to choose them to act</span>
<span class="linecomment">;;  on, but when you act on them Icicles takes you to the places they</span>
<span class="linecomment">;;  name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So just holding down both the Control key and `next' takes you</span>
<span class="linecomment">;;  from one place to the next.  And `C-mouse-2' takes you directly to</span>
<span class="linecomment">;;  the location you click.  Typically, `C-g' aborts the trip and puts</span>
<span class="linecomment">;;  you back at your starting point.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are many such Icicles tripping (aka navigation or browsing)</span>
<span class="linecomment">;;  commands, and they all work similarly.  They give you the normal</span>
<span class="linecomment">;;  cycling behavior provided by vanilla Emacs commands such as</span>
<span class="linecomment">;;  `find-tag' (via `M-.', `C-u M-.', `M-*' etc.) or</span>
<span class="linecomment">;;  `set-mark-command' (via `C-u C-SPC').  But unlike the vanilla</span>
<span class="linecomment">;;  Emacs commands, the keys for this cycling are always the same.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  More importantly, you need not cycle through all possibilities.</span>
<span class="linecomment">;;  You can go directly to particular locations with `C-RET',</span>
<span class="linecomment">;;  `C-mouse-2' or using completion.  And your input filters the</span>
<span class="linecomment">;;  available candidates, as always.  And you can, as always, use</span>
<span class="linecomment">;;  progressive completion, chipping away, and so on to define your</span>
<span class="linecomment">;;  `C-next' trip itinerary using a process of refinement.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whereas vanilla Emacs gives you some commands that let you use</span>
<span class="linecomment">;;  completion to enter a destination and go there, and it gives you</span>
<span class="linecomment">;;  other commands that let you cycle among locations, Icicles rolls</span>
<span class="linecomment">;;  all of that into one.  And you use the same keys, always, to</span>
<span class="linecomment">;;  navigate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here are some of the Icicles tripping commands:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-bookmark' (`C-- C-x r m') - Trip among bookmarks.</span>
<span class="linecomment">;;  * `icicle-buffer' (`C-x b') - Trip among buffers.</span>
<span class="linecomment">;;  * `icicle-compilation-search' (`C-c `') - Trip among `grep' hits.</span>
<span class="linecomment">;;  * `icicle-find-file' (`C-x C-f') - Trip among files.</span>
<span class="linecomment">;;  * `icicle-find-file-absolute' (`C-u C-x C-f') - Trip among files.</span>
<span class="linecomment">;;  * `icicle-find-first-tag' (`C-x 4 .') - Trip among tag hits.</span>
<span class="linecomment">;;  * `icicle-find-tag' (`M-.') - Trip among tag hits.</span>
<span class="linecomment">;;  * `icicle-goto-global-marker' (`C-- C-x C-SPC') - Trip among</span>
<span class="linecomment">;;    global markers.</span>
<span class="linecomment">;;  * `icicle-goto-marker' (`C-- C-SPC') - Trip among local markers.</span>
<span class="linecomment">;;  * `icicle-imenu' (`C-c ='), `icicle-imenu-command',</span>
<span class="linecomment">;;    `icicle-imenu-non-interactive-function' - Trip among</span>
<span class="linecomment">;;    definitions.</span>
<span class="linecomment">;;  * `icicle-Info-goto-node' (`g' in Info)- Trip among Info nodes.</span>
<span class="linecomment">;;  * `icicle-Info-index' (`i' in Info) - Trip among Info nodes.</span>
<span class="linecomment">;;  * `icicle-Info-menu' (`m' in Info)- Trip among Info nodes.</span>
<span class="linecomment">;;  * `icicle-locate-file' - Trip among files.</span>
<span class="linecomment">;;  * `icicle-occur' (`C-c '') - Trip among `occur' hits</span>
<span class="linecomment">;;     (`icicle-search' among single-line hits).</span>
<span class="linecomment">;;  * `icicle-recent-file' - Trip among recent files.</span>
<span class="linecomment">;;  * `icicle-search' (`C-c `') - Trip among regexp search hits.</span>
<span class="linecomment">;;  * `icicle-search-char-property' - Trip among buffer strings with</span>
<span class="linecomment">;;    some text or overlay property.</span>
<span class="linecomment">;;  * `icicle-search-keywords' (`C-c ^') - Trip among keyword search</span>
<span class="linecomment">;;    hits.</span>
<span class="linecomment">;;  * `icicle-search-overlay-property' - Trip among buffer strings</span>
<span class="linecomment">;;    with some overlay property.</span>
<span class="linecomment">;;  * `icicle-search-region' - Trip among saved regions.</span>
<span class="linecomment">;;  * `icicle-search-text-property' (`C-c "') - Trip among buffer</span>
<span class="linecomment">;;    strings with some text property.</span>
<span class="linecomment">;;  * `icicle-search-word' (`C-c $') - Trip among word-search hits.</span>
<span class="linecomment">;;  * `icicle-select-frame' (`C-x 5 o') - Trip among frames, by name.</span>
<span class="linecomment">;;  * `icicle-select-region' (`C-u C-x C-x') - Trip among saved</span>
<span class="linecomment">;;    regions.</span>
<span class="linecomment">;;  * `icicle-select-window' (`C-0 C-x o') - Trip among windows, by</span>
<span class="linecomment">;;    buffer name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Highlighting the Destination")</span>
<span class="linecomment">;;  ** Highlighting the Destination **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Starting with Emacs 22, the Icicles commands that have single</span>
<span class="linecomment">;;  positions as their trip visits (e.g. `icicle-bookmark',</span>
<span class="linecomment">;;  `icicle-Info-goto-node', `icicle-goto-marker', `icicle-find-tag')</span>
<span class="linecomment">;;  highlight those positions temporarily as they are visited.  Except</span>
<span class="linecomment">;;  for the Icicles search commands, this highlighting is provided by</span>
<span class="linecomment">;;  library `crosshairs.el'.  If `crosshairs.el' and the libraries it</span>
<span class="linecomment">;;  requires are not in your `load-path', then no such highlighting</span>
<span class="linecomment">;;  occurs.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The commands that have regions as their trip visits</span>
<span class="linecomment">;;  (e.g. `icicle-select-region') highlight the currently visited</span>
<span class="linecomment">;;  region if you use Transient Mark mode (or, e.g., Delete Selection</span>
<span class="linecomment">;;  mode).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@* "Icicles Commands that Read File Names") for information</span>
<span class="linecomment">;;    about `icicle-find-file', `icicle-find-file-absolute',</span>
<span class="linecomment">;;    `icicle-locate-file', and `icicle-recent-file'.</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Tags Enhancements")</span>
<span class="linecomment">;;    for information about `icicle-find-first-tag' and</span>
<span class="linecomment">;;    `icicle-find-tag'.</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Info Enhancements")</span>
<span class="linecomment">;;    for information about `icicle-Info-goto-node',</span>
<span class="linecomment">;;    `icicle-Info-index', and `icicle-Info-menu'.</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Multiple Regions") for</span>
<span class="linecomment">;;    information about `icicle-search-region' and</span>
<span class="linecomment">;;    `icicle-select-region'.</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;    for information about `icicle-occur' and `icicle-search'.</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Other Icicles Search Commands")</span>
<span class="linecomment">;;    for information about `icicle-compilation-search',</span>
<span class="linecomment">;;    `icicle-imenu', `icicle-imenu-command',</span>
<span class="linecomment">;;    `icicle-imenu-non-interactive-function',</span>
<span class="linecomment">;;    `icicle-search-char-property', `icicle-search-keywords',</span>
<span class="linecomment">;;    `icicle-search-overlay-property', and</span>
<span class="linecomment">;;    `icicle-search-text-property'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Defining Icicles Tripping Commands")</span>
<span class="linecomment">;;    for information about defining your own tripping commands.</span>
 
<span class="linecomment">;;(@* "Key Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Key Completion</span>
<span class="linecomment">;;  --------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here's another weird Icicles feature: completing key sequences,</span>
<span class="linecomment">;;  instead of commands.  (This feature works only for Emacs 22 and</span>
<span class="linecomment">;;  later.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What on earth for?  Ever want to use one of those myriad `C-x' key</span>
<span class="linecomment">;;  sequences, but forget just what it was?  The standard solution to</span>
<span class="linecomment">;;  that is to use `C-x C-h', to display all of the `C-x' bindings</span>
<span class="linecomment">;;  together with their commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  OK, but then you have to scroll down the list of bindings,</span>
<span class="linecomment">;;  searching for the command you want, and then use its key binding.</span>
<span class="linecomment">;;  You can use `C-M-s' to search for a substring of the command name,</span>
<span class="linecomment">;;  in case you don't recall the exact name, but why not use Icicles</span>
<span class="linecomment">;;  completion for this?  Why not match against possible key sequences</span>
<span class="linecomment">;;  and commands?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Completing Keys")</span>
<span class="linecomment">;;  ** Completing Keys **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To complete keys in Icicles, start the key sequence as usual, and</span>
<span class="linecomment">;;  then hit `S-TAB' (command `icicle-complete-keys').  For example,</span>
<span class="linecomment">;;  use `C-x' or `C-x 4', and then hit `S-TAB' to complete the prefix</span>
<span class="linecomment">;;  `C-x' or `C-x 4' (or whatever).  You're then completing against</span>
<span class="linecomment">;;  candidates that are composed of two parts, separated by "  =  ":</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * a key binding that completes what you've typed so far -</span>
<span class="linecomment">;;    e.g. `C-j' (that is, `C-x C-j')</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * the command it is bound to - e.g. `dired-jump-other-window'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So, for example, this is a single completion candidate:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-j  =  dired-jump-other-window</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can match your minibuffer input against the key name, the</span>
<span class="linecomment">;;  command name, or both.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Suppose, for instance, that you want to use a version-control</span>
<span class="linecomment">;;  command, and you remember that all such commands are bound to key</span>
<span class="linecomment">;;  sequences that begin with `C-x v'.  You enter as much of the key</span>
<span class="linecomment">;;  sequence as you remember (`C-x v'), and then you hit `S-TAB'.  You</span>
<span class="linecomment">;;  can then use completion (either apropos or prefix) against the</span>
<span class="linecomment">;;  matching key sequences and command names to invoke the right</span>
<span class="linecomment">;;  command.  And, as a bonus, you are reminded of its key sequence.</span>
<span class="linecomment">;;  You can thus use Icicles key completion to execute a command and,</span>
<span class="linecomment">;;  at the same time, learn its key binding.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (The documentation always refers to the key that performs key</span>
<span class="linecomment">;;  completion as `S-TAB'.  Actually, it is `S-TAB' only by default.</span>
<span class="linecomment">;;  You can customize it, using option `icicle-key-complete-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`S-TAB' Is Everywhere - Start With It")</span>
<span class="linecomment">;;  ** `S-TAB' Is Everywhere - Start With It **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicle mode, whenever you are not in the minibuffer or buffer</span>
<span class="linecomment">;;  `*Completions*', key `S-TAB' initiates key completion.  That is,</span>
<span class="linecomment">;;  you don't need to first type part of a key sequence to use it -</span>
<span class="linecomment">;;  you can start with it.  Hit `S-TAB' at any time, and you're</span>
<span class="linecomment">;;  completing a key sequence, even if you haven't yet hit any keys.</span>
<span class="linecomment">;;  This lets you see all key sequences that are available in a given</span>
<span class="linecomment">;;  context.  For example, in Dired, keys special to that mode are</span>
<span class="linecomment">;;  included (and are highlighted as local bindings -</span>
<span class="linecomment">;;  see (@&gt; "Local Bindings Are Highlighted")).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When completing a key sequence, you can type part of a command</span>
<span class="linecomment">;;  name, then hit `S-TAB' to apropos-complete against the command</span>
<span class="linecomment">;;  name.  In this respect, `S-TAB' acts like `M-x', but the key</span>
<span class="linecomment">;;  binding is also part of the completion candidate, so you can also</span>
<span class="linecomment">;;  match key names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Completing Keys By Name")</span>
<span class="linecomment">;;  ** Completing Keys By Name **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So, just how do you complete input against a set of</span>
<span class="linecomment">;;  binding-plus-command completion candidates?  You can always cycle</span>
<span class="linecomment">;;  among the candidates, of course, and then choose one.  But what</span>
<span class="linecomment">;;  about completion?  Just type text to match candidates, then use</span>
<span class="linecomment">;;  `S-TAB' or `TAB' as usual to complete the text.  Text?  Yes.</span>
<span class="linecomment">;;  Completion candidates are always, ultimately, strings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Suppose that you type `C-x S-TAB' to show all key sequences that</span>
<span class="linecomment">;;  begin with `C-x'.  You might see a candidate that looks like this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-q  =  toggle-read-only</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can then type "C-q" or "d-onl" or any other substring, and</span>
<span class="linecomment">;;  then use `S-TAB' to complete the candidate.  (This second use of</span>
<span class="linecomment">;;  `S-TAB' invokes the command `icicle-apropos-complete', which has</span>
<span class="linecomment">;;  nothing to do with `icicle-complete-keys', which was invoked by</span>
<span class="linecomment">;;  the first `S-TAB'.  The first was invoked outside the minibuffer;</span>
<span class="linecomment">;;  the second was invoked from the minibuffer, during completion.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Completing Prefix Keys")</span>
<span class="linecomment">;;  ** Completing Prefix Keys **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What happens if the completion candidate is itself a prefix key?</span>
<span class="linecomment">;;  For example, `C-x S-TAB' shows some candidates whose commands are</span>
<span class="linecomment">;;  shown as "...", like this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    4  =  ...      5  =  ...</span>
<span class="linecomment">;;    6  =  ...      C-k  =  ...</span>
<span class="linecomment">;;    ESC  =  ...    RET  =  ...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These represent prefix keys (`C-x 4', `C-x C-k', and so on).  If</span>
<span class="linecomment">;;  you choose such a candidate, then you just continue completing -</span>
<span class="linecomment">;;  buffer `*Completions*' is updated to show the completions of the</span>
<span class="linecomment">;;  compound prefix: `C-x 4', `C-x RET', or whichever you choose.  The</span>
<span class="linecomment">;;  minibuffer prompt shows the completion so far; if you choose</span>
<span class="linecomment">;;  `RET', for instance, then it shows `C-x RET' while prompting you</span>
<span class="linecomment">;;  for the rest of the key sequence.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, completion candidates are sorted in buffer</span>
<span class="linecomment">;;  `*Completions*' with local bindings listed first.  You can use</span>
<span class="linecomment">;;  `C-M-,' at any time during completion to toggle between this order</span>
<span class="linecomment">;;  and sorting with the prefix-key candidates shown first.  You can</span>
<span class="linecomment">;;  use `C-,' at any time to change the sort order among these two</span>
<span class="linecomment">;;  orders and sorting sorting by command name.  (Except in contexts,</span>
<span class="linecomment">;;  such as `icicle-search', where candidate sorting is not possible.</span>
 <span class="linecomment">;;  In those contexts, `C-,' has a different meaning.)</span>
 <span class="linecomment">;;</span>
 <span class="linecomment">;;  Gotcha: Commands that are remapped do not show up with the</span>
 <span class="linecomment">;;  bindings you think they have.  For example, `C-x C-f' is bound to</span>
<span class="linecomment">;;  `icicle-file' in Icicle mode, by default, but `C-x S-TAB' does not</span>
<span class="linecomment">;;  include the completion candidate `C-f  =  icicle-file'.  Instead,</span>
<span class="linecomment">;;  `S-TAB' at the top level (without first doing `C-x') shows a</span>
<span class="linecomment">;;  (pseudo) prefix key `remap  =  ..', and if you follow that then</span>
<span class="linecomment">;;  you'll see the candidate `find-file  =  icicle-file'.  The binding</span>
<span class="linecomment">;;  of `C-x C-f' does not appear as such, because `find-file' is</span>
<span class="linecomment">;;  remapped to command `icicle-file': whatever `find-file' was bound</span>
<span class="linecomment">;;  to is indirectly bound to `icicle-file'. This indirection shows up</span>
<span class="linecomment">;;  in Icicles key completion as (pseudo) prefix key `remap  =  ..'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Meta Key Bindings")</span>
<span class="linecomment">;;  ** Meta Key Bindings **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `S-TAB' at the top level, and you look for the key</span>
<span class="linecomment">;;  sequence `M-x' or `M-d', you won't find it.  Meta key bindings are</span>
<span class="linecomment">;;  there, but many of them are disguised as keys in the `ESC' prefix</span>
<span class="linecomment">;;  keymap - e.g. `ESC x' for `M-x'.  That is, you must first choose</span>
<span class="linecomment">;;  the `ESC` prefix key: `ESC  =  ...', and then choose the `x' key</span>
<span class="linecomment">;;  or whatever.  That's just the way Emacs works.  So, yes, you can</span>
<span class="linecomment">;;  use Icicles key completion to execute any Emacs command, even one</span>
<span class="linecomment">;;  that is not bound to a key sequence, and you can use it to</span>
<span class="linecomment">;;  evaluate any EmacsLisp expression.  See (@&gt; "Three-Key Emacs").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Navigate the Key-Binding Hierarchy")</span>
<span class="linecomment">;;  ** Navigate the Key-Binding Hierarchy **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Choosing a completion candidate such as `C-x  =  ...' effectively</span>
<span class="linecomment">;;  navigates down the key-binding hierachy (prefix-key hierarchy), to</span>
<span class="linecomment">;;  complete against all keys with prefix `C-x'.  Choosing `5  =  ...'</span>
<span class="linecomment">;;  to complete the prefix `C-x' then navigates down another level, to</span>
<span class="linecomment">;;  complete keys that have prefix `C-x 5'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What about navigating back up the hierarchy, say from the `C-x 5'</span>
<span class="linecomment">;;  keys to the `C-x' keys, or from the `C-x' keys to the keys with no</span>
<span class="linecomment">;;  prefix?  The special completion candidate `..' does that.  By</span>
<span class="linecomment">;;  default, it is always the first candidate in the `*Completions*'</span>
<span class="linecomment">;;  list.  It is of course not available unless you are completing a</span>
<span class="linecomment">;;  prefix; that is, it is not available at the top level.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This feature means that you can navigate the key-binding hierachy</span>
<span class="linecomment">;;  just as you would navigate the file-system hierarchy (using, say,</span>
<span class="linecomment">;;  `C-x C-f') or the menu-bar hierarchy (using library</span>
<span class="linecomment">;;  `lacarte.el').  (In fact, since menu-bar bindings are also key</span>
<span class="linecomment">;;  bindings, you can also use key completion to navigate the menu-bar</span>
<span class="linecomment">;;  hierarchy - just complete the prefix key `menu-bar'!)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles key completion thus provides a general browser for key</span>
<span class="linecomment">;;  bindings, which you can also use to learn about keys and their</span>
<span class="linecomment">;;  associated comands, without necessarily executing them - see</span>
<span class="linecomment">;;  (@&gt; "Key and Command Help").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Gotcha: `S-TAB' uses apropos completion, by default, so remember</span>
<span class="linecomment">;;  that typing `.' matches any character (except a newline).  To</span>
<span class="linecomment">;;  match only the literal string `..', do one of the following:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Turn on escaping of regexp special characters - use `C-`' in the</span>
<span class="linecomment">;;    minibuffer to toggle this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Use prefix completion (`TAB').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Escape the regexp special character explicitly: `\.\.' (or use</span>
<span class="linecomment">;;    `^\.').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Local Bindings Are Highlighted")</span>
<span class="linecomment">;;  ** Local Bindings Are Highlighted **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sometimes it helps to know which key sequences are local bindings,</span>
<span class="linecomment">;;  that is, bindings that are specific to the current mode.  For</span>
<span class="linecomment">;;  example, Dired mode defines keys specific to Dired buffer, such as</span>
<span class="linecomment">;;  `* %', `% g', and `!'.  To help you distinguish local key bindings</span>
<span class="linecomment">;;  from others (global and minor-mode bindings), local bindings are</span>
<span class="linecomment">;;  highlighted in buffer `*Completions*' using face</span>
<span class="linecomment">;;  `icicle-special-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Completing Keys By Just Hitting Them")</span>
<span class="linecomment">;;  ** Completing Keys By Just Hitting Them **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It may seem odd that you must complete a key sequence by entering</span>
<span class="linecomment">;;  the names of keys, rather than just hitting the keys themselves:</span>
<span class="linecomment">;;  e.g. typing "C-f" rather than hitting `C-f'.  However, if keys</span>
<span class="linecomment">;;  themselves were used for completing, then they could not be used</span>
<span class="linecomment">;;  normally during key-sequence completion.  You could not move the</span>
<span class="linecomment">;;  cursor around the minibuffer using `C-f' or `right' (right arrow),</span>
<span class="linecomment">;;  because those keys would be treated as input for completion.  You</span>
<span class="linecomment">;;  could not use `up' or `down' to cycle among completion candidates</span>
<span class="linecomment">;;  for the same reason.  Likewise, you could not use printing</span>
<span class="linecomment">;;  (self-inserting) keys, such as `a' and `$', to match command</span>
<span class="linecomment">;;  names.  Having to use key names, instead of keys, for completion</span>
<span class="linecomment">;;  is a small price to pay for being able to complete key sequences.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Nevertheless, Icicles also provides a way for you to type key</span>
<span class="linecomment">;;  sequences directly, even if it is something of a workaround:</span>
<span class="linecomment">;;  precede each key with `M-q' (`icicle-insert-key-description',</span>
<span class="linecomment">;;  during key completion) - think of `q' for "quote".  This inserts</span>
<span class="linecomment">;;  the key description of whatever key you hit next.  This key</span>
<span class="linecomment">;;  description (name) can be used to match key-completion candidates.</span>
<span class="linecomment">;;  So, for example, instead of typing "C-f", you can hit `M-q' and</span>
<span class="linecomment">;;  then hit `C-f'.  The key description "C-f" is inserted in the</span>
<span class="linecomment">;;  minibuffer.  If you use `M-q C-M-right', then "C-M-right" is</span>
<span class="linecomment">;;  inserted.  Try it: `S-TAB M-q C-M-right' -&gt; "C-M-right".  Then hit</span>
<span class="linecomment">;;  `TAB' or `S-TAB' to complete the candidate all the way to this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-M-right  =  enlarge-frame-horizontally</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Whether or not angle brackets are used is governed by user</span>
<span class="linecomment">;;  option `icicle-key-descriptions-use-&lt;&gt;-flag'.  By default, this is</span>
<span class="linecomment">;;  nil, so angle brackets are not used, which I think improves</span>
<span class="linecomment">;;  readability.  If you set this to non-nil, then you will see</span>
<span class="linecomment">;;  "&lt;C-M-right&gt;" instead of "C-M-right", both as a completion</span>
<span class="linecomment">;;  candidate and as what is inserted when you use `M-q'.  You can</span>
<span class="linecomment">;;  also provide a prefix argument to `M-q' to flip the behavior of</span>
<span class="linecomment">;;  `icicle-key-descriptions-use-&lt;&gt;-flag' for that occurrence only.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Key and Command Help")</span>
<span class="linecomment">;;  ** Key and Command Help **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That points out another use of key completion, opposite to</span>
<span class="linecomment">;;  learning the bindings of commands: learning the commands bound to</span>
<span class="linecomment">;;  given keys.  In other words, `S-TAB M-q' does both what `C-h w'</span>
<span class="linecomment">;;  (`where-is') does and what `C-h c' (`describe-key-briefly') does.</span>
<span class="linecomment">;;  It also does what `C-h b' (`describe-bindings') does.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The point here is not that `S-TAB M-q' is quicker than `C-h w' or</span>
<span class="linecomment">;;  `C-h c' or `C-h b' - it's not.  The point is that key completion</span>
<span class="linecomment">;;  can be handy in several ways, and it can teach you various things</span>
<span class="linecomment">;;  about keys and commands as you use it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to this key-completion help about bindings, you can</span>
<span class="linecomment">;;  display help on the commands that are the right sides of the</span>
<span class="linecomment">;;  `S-TAB' completion-candidate equations, by using the multi-command</span>
<span class="linecomment">;;  help keys (see (@&gt; "Help on Completion Candidates")).  That is,</span>
<span class="linecomment">;;  while completing, you can use `C-M-mouse-2', `C-M-RET',</span>
<span class="linecomment">;;  `C-M-next', and so on to describe the command named in the current</span>
<span class="linecomment">;;  completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`S-TAB' Is a Multi-Command")</span>
<span class="linecomment">;;  ** `S-TAB' Is a Multi-Command **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Yes, `S-TAB' as `icicle-complete-keys' is a multi-command - see</span>
<span class="linecomment">;;  (@&gt; "Multi-Commands")).  This means that you can, within the same</span>
<span class="linecomment">;;  execution of `S-TAB', invoke any number of keys by clicking</span>
<span class="linecomment">;;  (`C-mouse-2') their names in buffer `*Completions*' or choosing</span>
<span class="linecomment">;;  them any other way (`C-RET', `C-next', and so on).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Since you can navigate up and down the key-binding hierarchy, you</span>
<span class="linecomment">;;  could even stay within a single `S-TAB' invocation to do nearly</span>
<span class="linecomment">;;  everything you want in Emacs (see (@&gt; "Three-Key Emacs"))!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Possible Source of Confusion")</span>
<span class="linecomment">;;  ** Possible Source of Confusion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Keep in mind that `S-TAB' has two different uses in Icicles when</span>
<span class="linecomment">;;  you are providing input in the minibuffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If input completion is available, then `S-TAB' performs apropos</span>
<span class="linecomment">;;    completion (it is, in effect, bound to</span>
<span class="linecomment">;;    `icicle-apropos-complete').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If input completion is not available, then `S-TAB' performs key</span>
<span class="linecomment">;;    completion (it is, in effect, bound to `icicle-complete-keys').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, in buffer *Completions* `S-TAB' moves backward among</span>
<span class="linecomment">;;  the candidate completions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is by design; it takes advantage of the fact that these</span>
<span class="linecomment">;;  contexts are mutually exclusive.  However, this economy comes at a</span>
<span class="linecomment">;;  risk of potential confusion.  It's important that you know whether</span>
<span class="linecomment">;;  or not completion is available when you are inputting text.  If</span>
<span class="linecomment">;;  input completion is not available, but you think it is, then</span>
<span class="linecomment">;;  hitting `S-TAB' might give you a surprise by key completing.  That</span>
<span class="linecomment">;;  behavior is normal - you can use key-completion to input special</span>
<span class="linecomment">;;  characters, for instance.  But if you think that you are instead</span>
<span class="linecomment">;;  completing the original input requested, then you can become</span>
<span class="linecomment">;;  confused.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles provides completion status indicators so that you can</span>
<span class="linecomment">;;  easily tell when completion is available for minibuffer input.</span>
<span class="linecomment">;;  There are two indicators: (1) at the beginning of the minibuffer</span>
<span class="linecomment">;;  prompt and (2) in the `Icy' minor-mode lighter in the mode line.</span>
<span class="linecomment">;;  See (@&gt; "Completion Status Indicators").  If completion is not</span>
<span class="linecomment">;;  indicated when you are prompted for input, it means that `S-TAB'</span>
<span class="linecomment">;;  is available, not for input completion, but for key completion.</span>
<span class="linecomment">;;  Another clue can be found in the prompt text.  For key completion,</span>
<span class="linecomment">;;  it says "Complete keys: ".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you nevertheless find the overloaded use of `S-TAB' confusing,</span>
<span class="linecomment">;;  you can change the bindings of the key `S-TAB' in these different</span>
<span class="linecomment">;;  contexts.  To do that, you can customize options</span>
<span class="linecomment">;;  `icicle-apropos-complete-keys', `icicle-key-complete-keys', and</span>
<span class="linecomment">;;  `icicle-previous-candidate-keys'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Three-Key Emacs")</span>
<span class="linecomment">;;  ** Three-Key Emacs **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles key completion piles a lot of stuff into `S-TAB'.  Just as</span>
<span class="linecomment">;;  `M-x' lets you execute any Emacs command, so does `S-TAB'.  But</span>
<span class="linecomment">;;  `S-TAB' also lets you insert characters.  With the exception of</span>
<span class="linecomment">;;  inserting multi-byte characters, you might say that it gives you</span>
<span class="linecomment">;;  all of Emacs in one key binding.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Of course, you need a couple other keys, as well.  How many?</span>
<span class="linecomment">;;  Suppose you had limited accessibility in terms of input devices.</span>
<span class="linecomment">;;  Maybe you use Emacs on a cell phone, without voice recognition -</span>
<span class="linecomment">;;  or whatever.  How many keys, buttons, or whatnot do you need to</span>
<span class="linecomment">;;  use Emacs?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. You need one for `C-g', to interrupt commands.</span>
<span class="linecomment">;;  2. You need one to start telling Emacs what to do.</span>
<span class="linecomment">;;  3. You might need one to choose from a set of possible things to</span>
<span class="linecomment">;;     do.</span>
<span class="linecomment">;;  4. You need one to tell Emacs that you're done telling it what to</span>
<span class="linecomment">;;     do.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (#2 and #3 might be combined somehow.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What does vanilla Emacs offer out of the box in this regard?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can get by with just `mouse-1' and the menu-bar menus, but</span>
<span class="linecomment">;;    they don't cover all of Emacs.  You can't use them to enter</span>
<span class="linecomment">;;    text, for instance.  Of course, you could add more menus, to be</span>
<span class="linecomment">;;    able to do more.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use `M-x' plus `RET' to execute any command.  But how</span>
<span class="linecomment">;;    would you insert text?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Similarly, for `M-:', which lets you evaluate any EmacsLisp</span>
<span class="linecomment">;;    sexp.  You still need a way to type characters.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles key completion lets you do almost anything in Emacs with</span>
<span class="linecomment">;;  three or four keys, buttons, or whatever:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `S-TAB' - Offers every key sequence as a possible choice to</span>
<span class="linecomment">;;              execute.</span>
<span class="linecomment">;;  * `next'  - Cycles among candidates, for choosing.</span>
<span class="linecomment">;;  * `RET'   - Chooses the current candidate.</span>
<span class="linecomment">;;  * And of course `C-g', to cancel the current operation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `S-TAB' includes key `M-x (represented as prefix key `ESC'</span>
<span class="linecomment">;;  followed by `x'), which offers all commands (even those not bound)</span>
<span class="linecomment">;;  as possible choices.  It also includes key `M-:' (`ESC' followed</span>
<span class="linecomment">;;  by `:'), which lets you execute any Emacs-Lisp expression.  That's</span>
<span class="linecomment">;;  almost all of Emacs!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You could even perhaps get away with only three mouse buttons, and</span>
<span class="linecomment">;;  no keyboard:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `mouse-1' - Choose candidates, scroll, and so on (direct access,</span>
<span class="linecomment">;;    no cycling).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `mouse-2' - Do what `S-TAB' does (bind it to</span>
<span class="linecomment">;;    `icicle-complete-keys' and `icicle-apropos-complete').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `mouse-3' - Do what `C-g' does (bind it to `keyboard-quit' and</span>
<span class="linecomment">;;    `icicle-abort-recursive-edit').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here, `mouse-2' and `mouse-3' aren't even used as mouse (pointer)</span>
<span class="linecomment">;;  functions; any keys or buttons would do.  You could use just</span>
<span class="linecomment">;;  `mouse-1' plus a Shift key and a Control key.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Would you want to use Emacs only this way?  Of course not, if you</span>
<span class="linecomment">;;  had a choice.  Typing the character `a' by cycling through every</span>
<span class="linecomment">;;  possible key binding/command combination and hitting `RET' when</span>
<span class="linecomment">;;  you get to `a  =  self-insert-command' would be the epitome of</span>
<span class="linecomment">;;  tedium.  Likewise, doing everything with a single pointer-device</span>
<span class="linecomment">;;  button.  Using only three or four keys or buttons is definitely</span>
<span class="linecomment">;;  not the ideal way to take advantage of Emacs.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But you are probably not limited to just 3 or 4 keys or buttons.</span>
<span class="linecomment">;;  The real point here is that Icicles `S-TAB' opens the door to</span>
<span class="linecomment">;;  almost everything in Emacs.  And if you do have a normal keyboard,</span>
<span class="linecomment">;;  then you can type letters and such to match command names and key</span>
<span class="linecomment">;;  sequences.  Key `next' matches substrings (regexps, actually),</span>
<span class="linecomment">;;  which makes choice even quicker.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Why only "almost" everything in Emacs?  Because you cannot use</span>
<span class="linecomment">;;  Icicles `S-TAB' to input multi-byte characters (e.g. Chinese,</span>
<span class="linecomment">;;  Japanese, Unicode).  Such characters are grouped in Emacs into</span>
<span class="linecomment">;;  character groups called "generic characters", and it is the</span>
<span class="linecomment">;;  generic characters, not the individual multi-byte characters that</span>
<span class="linecomment">;;  are bound to `self-insert-command'.  Icicles excludes these</span>
<span class="linecomment">;;  special key bindings, because you cannot simply execute</span>
<span class="linecomment">;;  `self-insert-command' to insert these characters.  (It is possible</span>
<span class="linecomment">;;  to implement a completion extension to input such characters, but</span>
<span class="linecomment">;;  that feature has not yet been implemented in Icicles.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Enjoy!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Entering Special and Foreign Characters")</span>
<span class="linecomment">;;  ** Entering Special and Foreign Characters **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `self-insert-command' is bound to each key that is</span>
<span class="linecomment">;;  associated with a character that can be inserted in text.  It is</span>
<span class="linecomment">;;  the binding of the key `a' and the key `$'.  It is also the</span>
<span class="linecomment">;;  binding of keys that your keyboard might not even have - keys that</span>
<span class="linecomment">;;  correspond to special or odd characters and characters in other</span>
<span class="linecomment">;;  languages.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To Icicles key completion, these keys are like any other keys, and</span>
<span class="linecomment">;;  `self-insert-command' is like any other command.  However, because</span>
<span class="linecomment">;;  there are many, many keys bound to it, it can be distracting to</span>
<span class="linecomment">;;  allow such keys as completion candidates.  If option</span>
<span class="linecomment">;;  `icicle-complete-keys-self-insert-flag' is nil (the default</span>
<span class="linecomment">;;  value), then such keys are excluded as candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If it is non-nil, then you can use key completion to insert</span>
<span class="linecomment">;;  characters that your keyboard has no keys for.  This provides a</span>
<span class="linecomment">;;  sort of universal input-method feature that works, in principle,</span>
<span class="linecomment">;;  for all characters (but see below, for exceptions).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To use this feature, just choose a character description (name)</span>
<span class="linecomment">;;  with the mouse or by cycling, if you cannot type its description</span>
<span class="linecomment">;;  (name) with your keyboard.  You can even insert characters this</span>
<span class="linecomment">;;  way that your system has no font for - they will be displayed as</span>
<span class="linecomment">;;  empty boxes, but they will be correctly inserted.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There is an exception, however.  You cannot insert some characters</span>
<span class="linecomment">;;  this way, because they don't have a one-to-one relation with keys</span>
<span class="linecomment">;;  that are bound to `self-insert-command'.  In such cases, "keys"</span>
<span class="linecomment">;;  are bound to `self-insert-command' that represent not single</span>
<span class="linecomment">;;  characters but groups of characters.  Icicles filters out these</span>
<span class="linecomment">;;  keys, so they are not available as completion candidates.  The</span>
<span class="linecomment">;;  problematic keys are in Korean, Chinese, Japanese, Ethiopic,</span>
<span class="linecomment">;;  Indian, Tibetan, and some Unicode character sets.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because insertion of special characters is useful, but is a</span>
<span class="linecomment">;;  special case of key completion, there is a separate Icicles</span>
<span class="linecomment">;;  command that you can use just for that: `icicle-insert-char'.  It</span>
<span class="linecomment">;;  is a specialized version of `icicle-complete-keys' that uses</span>
<span class="linecomment">;;  `self-insert-command' as the only possible command for completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Handling Keymaps That Are Inaccessible From the Global Map")</span>
<span class="linecomment">;;  ** Handling Keymaps That Are Inaccessible From the Global Map **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Actually, `S-TAB' is not bound to `icicle-complete-keys' in every</span>
<span class="linecomment">;;  keymap.  That would be inconvenient, in general.  By default, it</span>
<span class="linecomment">;;  is so bound in each keymap that is accessible from the global</span>
<span class="linecomment">;;  keymap, as determined by function `accessible-keymaps'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You've seen, above, how you can navigate through prefix keys,</span>
<span class="linecomment">;;  starting with the global map.  In Dired, for instance, you can use</span>
<span class="linecomment">;;  `S-TAB' at the top level, then choose the prefix key `*' in</span>
<span class="linecomment">;;  `*Completions*', then choose a key, such as `/' (to mark</span>
<span class="linecomment">;;  directories), in the `*' keymap.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, the act of binding of `S-TAB' in keymaps that are</span>
<span class="linecomment">;;  accessible from the global map does not bind it in the `*' prefix</span>
<span class="linecomment">;;  keymap itself.  To handle this case, Icicles explicitly does for</span>
<span class="linecomment">;;  `dired-mode-map' what it does for the global map: it binds `S-TAB'</span>
<span class="linecomment">;;  in each (non-menu) keymap that is accessible from</span>
<span class="linecomment">;;  `dired-mode-map'.  (Menu maps are always skipped.)  Because of</span>
<span class="linecomment">;;  this, you can use `* S-TAB' to show all key completions of `*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This treatment of `dired-mode-map' is done by default.  But you</span>
<span class="linecomment">;;  might have other keymaps that you would like to treat similarly -</span>
<span class="linecomment">;;  keymaps that Icicles might be unaware of.  You do this by</span>
<span class="linecomment">;;  including them in the list value of user option</span>
<span class="linecomment">;;  `icicle-keymaps-for-key-completion'.  The list entries are</span>
<span class="linecomment">;;  Emacs-Lisp symbols that are bound to keymaps, each of which should</span>
<span class="linecomment">;;  define at least one prefix key.  If you add a keymap variable to</span>
<span class="linecomment">;;  this list, then `S-TAB' will be bound so that you can use it to</span>
<span class="linecomment">;;  complete the prefix keys defined by that map.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Notice that there is no keymap variable that corresponds to prefix</span>
<span class="linecomment">;;  key `*' in Dired mode.  You need only provide a keymap (variable</span>
<span class="linecomment">;;  `dired-mode-map') from which the prefix key is accessible; it is</span>
<span class="linecomment">;;  not necessary to also provide a variable that corresponds to the</span>
<span class="linecomment">;;  prefix keymap itself.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If a keymap listed in `icicle-keymaps-for-key-completion' is not</span>
<span class="linecomment">;;  defined when Icicle mode is entered, then it is ignored.  If you</span>
<span class="linecomment">;;  later define that keymap, then just exit and reenter Icicle mode</span>
<span class="linecomment">;;  for the `S-TAB' binding to take effect.  For example, use `M-x</span>
<span class="linecomment">;;  icy-mode' twice after entering Calendar mode, to be able to</span>
<span class="linecomment">;;  complete `calendar-mode' prefix keys such as `t' - `t S-TAB'.</span>
 
<span class="linecomment">;;(@* "Icicles Multi `M-x'")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Multi `M-x'</span>
<span class="linecomment">;;  -------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  How about a multi-command replacement for `M-x'?  Instead of</span>
<span class="linecomment">;;  executing a single command, it would execute any number of</span>
<span class="linecomment">;;  commands.  This section describes two such multi-commands,</span>
<span class="linecomment">;;  `icicle-execute-extended-command' and `icicle-command-abbrev',</span>
<span class="linecomment">;;  which by default are bound in Icicle mode to `M-x' and `C-x SPC',</span>
<span class="linecomment">;;  respectively.  See Also:</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Defining Icicles Multi `M-x'").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Multi `M-x': `icicle-execute-extended-command'")</span>
<span class="linecomment">;;  ** Multi `M-x': `icicle-execute-extended-command' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you use `M-x' in vanilla Emacs, you are actually executing</span>
<span class="linecomment">;;  the standard Emacs command `execute-extended-command'.  That</span>
<span class="linecomment">;;  command prompts you for the name of another command, which you</span>
<span class="linecomment">;;  input.  It uses `completing-read' to do this, which is why you can</span>
<span class="linecomment">;;  take advantage of Icicles features when you use `M-x'.  Nothing</span>
<span class="linecomment">;;  new here.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-execute-extended-command' is simply a</span>
<span class="linecomment">;;  multi-command version of `execute-extended-command'.  It does the</span>
<span class="linecomment">;;  same thing, except that it also lets you execute multiple</span>
<span class="linecomment">;;  commands, one by one, using `C-RET' (or `C-next' and so on),</span>
<span class="linecomment">;;  without ever exiting the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  With the default value of option `icicle-top-level-key-bindings',</span>
<span class="linecomment">;;  `M-x' is bound to `icicle-execute-extended-command' whenever you</span>
<span class="linecomment">;;  are in Icicle mode.  If you never use it as a multi-command, you</span>
<span class="linecomment">;;  won't notice any difference from `execute-extended-command'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Examples of Using Multi `M-x'")</span>
<span class="linecomment">;;  *** Examples of Using Multi `M-x' ***</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Example: Repeat a command multiple times.  Yes, `C-x z' does this</span>
<span class="linecomment">;;  already (and better) - this is just an illustration.  `M-x</span>
<span class="linecomment">;;  forward-ch TAB' completes to `forward-char'.  Then, use `C-RET' to</span>
<span class="linecomment">;;  execute that command.  Repeat as many times as you want.  Use a</span>
<span class="linecomment">;;  prefix arg if you like.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To switch to another command in the same `M-x' invocation: Erase</span>
<span class="linecomment">;;  the minibuffer (`M-k'), complete the second command, then use</span>
<span class="linecomment">;;  `C-RET'.  As long as you haven't yet used `RET', `S-RET', `C-g'</span>
<span class="linecomment">;;  (or, say, `C-]'), you remain within the same invocation of `M-x'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What about executing a command that, itself, reads an input</span>
<span class="linecomment">;;  argument?  That's OK.  And if that command reads its input with</span>
<span class="linecomment">;;  completion, then you can use `C-RET' on the completion candidates</span>
<span class="linecomment">;;  for that input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Example: `M-x describe-fa TAB C-RET' gives you the prompt for</span>
<span class="linecomment">;;  command `describe-face'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Type `ici S-TAB' to see the available Icicles faces.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Hit `next' until face `icicle-complete-input' is highlighted.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Hit `C-RET' to display its documentation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. Type `C-next' a few times to see the doc of other Icicles</span>
<span class="linecomment">;;     faces.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  5. Use `M-k' to erase the minibuffer, then type `search S-TAB' to</span>
<span class="linecomment">;;     see faces about searching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  6. Cycle through them with `next', then use `C-RET' on</span>
<span class="linecomment">;;     `icicle-search-main-regexp-current' to show its documentation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  7. Use `C-next' to do the same for face</span>
<span class="linecomment">;;     `icicle-search-main-regexp-others'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  8. Use `RET' to finish with command `describe-face' - but you're</span>
<span class="linecomment">;;     still in the same invocation of `M-x'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  9. Change the input to `describe-coding-system' and play again,</span>
<span class="linecomment">;;     this time with coding-system names...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Remember, if you get confused or lost: `C-]'</span>
<span class="linecomment">;;  (`abort-recursive-edit') or `M-x top-level' should always</span>
<span class="linecomment">;;  straighten you out.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "What about describe-variable and describe-function?")</span>
<span class="linecomment">;;  *** What about describe-variable and describe-function? ***</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sadly, if you try the last example with `describe-variable' or</span>
<span class="linecomment">;;  `describe-function', you might be in for a surprise.  In Emacs 20,</span>
<span class="linecomment">;;  they both work fine.  In later Emacs versions, `describe-variable'</span>
<span class="linecomment">;;  gives you the message "You did not specify a variable", and</span>
<span class="linecomment">;;  `describe-function' displays a *Help* buffer that says that each</span>
<span class="linecomment">;;  function you choose is really a keyboard macro!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Why?  It's a bit complex, but worth hearing about if you want to</span>
<span class="linecomment">;;  understand multi M-x better.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you choose a command that reads an argument in the minibuffer</span>
<span class="linecomment">;;  and you then hit a multi-command key such as `C-RET' to choose an</span>
<span class="linecomment">;;  argument, Icicles tries to apply the command you chose to the</span>
<span class="linecomment">;;  argument you chose.  However, completion candidates are always</span>
<span class="linecomment">;;  strings, and the command you chose might expect something other</span>
<span class="linecomment">;;  than a string.  That is the case for `describe-variable', for</span>
<span class="linecomment">;;  instance.  The case of describe-function' is special: it</span>
<span class="linecomment">;;  interprets a string argument blindly as a keyboard macro sequence.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles is smart enough to pick up a `wrong-type-argument' error,</span>
<span class="linecomment">;;  if the command you choose barfs on a string argument.  In that</span>
<span class="linecomment">;;  case, Icicles converts the string to a symbol (or a number) and</span>
<span class="linecomment">;;  tries again, using the symbol (or the number).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And that's why `describe-variable' works in Emacs 20 but not in</span>
<span class="linecomment">;;  later versions: In Emacs 20, `describe-variable' (sanely) raises a</span>
<span class="linecomment">;;  type error if you pass it a string, and Icicles is able to save</span>
<span class="linecomment">;;  the day by then passing it the corresponding symbol.  In later</span>
<span class="linecomment">;;  versions of Emacs, however, instead of raising an error with the</span>
<span class="linecomment">;;  message "You did not specify a variable", `describe-variable' just</span>
<span class="linecomment">;;  displays the message - no error, so there is no way for Icicles to</span>
<span class="linecomment">;;  recuperate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I've reported this design misfeature to the Emacs developers, and</span>
<span class="linecomment">;;  I hope it will be fixed in a future Emacs version.  Until then, at</span>
<span class="linecomment">;;  least you know...  The more general lesson is this: Icicles can</span>
<span class="linecomment">;;  turn every command into a multi-command, but multi-command actions</span>
<span class="linecomment">;;  won't work for every command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Multi `M-x' Turns Every Command into a Multi-Command")</span>
<span class="linecomment">;;  *** Multi `M-x' Turns Every Command into a Multi-Command ***</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Most of the time, of course, you do not execute commands</span>
<span class="linecomment">;;  successively by name; instead, you use key bindings.  The point</span>
<span class="linecomment">;;  here is that even if you have a binding for a command, Icicles</span>
<span class="linecomment">;;  `M-x' lets you use any command as a multi-command, which can</span>
<span class="linecomment">;;  sometimes be advantageous.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, Icicles defines and binds a real multi-command to</span>
<span class="linecomment">;;  `C-x 0' in Icicle mode, which lets you delete any number of</span>
<span class="linecomment">;;  windows.  But, even without such a multi-command, you can get a</span>
<span class="linecomment">;;  similar effect by using `M-x delete-windows-on'.  In this way, you</span>
<span class="linecomment">;;  can turn ordinary Emacs commands that use completion into</span>
<span class="linecomment">;;  multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The other point is that you can move from one command to another</span>
<span class="linecomment">;;  within the same execution of `M-x'.  This is a different feature</span>
<span class="linecomment">;;  from being able to use any command that uses completion as a</span>
<span class="linecomment">;;  multi-command.  Both features have their uses.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Multi `M-x' with Abbreviations: `icicle-command-abbrev'")</span>
<span class="linecomment">;;  ** Multi `M-x' with Abbreviations: `icicle-command-abbrev' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The second multi-command that you can use in place of</span>
<span class="linecomment">;;  `execute-extended-command' is `icicle-command-abbrev', bound in</span>
<span class="linecomment">;;  Icicle mode to `C-x SPC'.  It is similar to `M-x'</span>
<span class="linecomment">;;  (`icicle-execute-extended-command'), with the added twist that it</span>
<span class="linecomment">;;  lets you input command abbreviations, as well as commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Emacs partial completion and some other libraries provide ways for</span>
<span class="linecomment">;;  you to enter command abbreviations instead of command names at the</span>
<span class="linecomment">;;  command prompt (`M-x').  Library `exec-abbrev-cmd.el' by Tassilo</span>
<span class="linecomment">;;  Horn &lt;tassilo@member.fsf.org&gt; is an example.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So just what is a command abbreviation?  Hyphens (`-') in command</span>
<span class="linecomment">;;  names divide them into parts.  For example, `find-file' has two</span>
<span class="linecomment">;;  parts: `find' and `file'.  Each character of a command</span>
<span class="linecomment">;;  abbreviation corresponds to one part of each of the commands that</span>
<span class="linecomment">;;  match the abbreviation.  For example, abbreviation `ff' matches</span>
<span class="linecomment">;;  commands `find-file' and `focus-frame', and abbreviation `fg'</span>
<span class="linecomment">;;  matches `find-grep'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If user option `icicle-command-abbrev-match-all-parts-flag' is</span>
<span class="linecomment">;;  nil, then an abbreviation need not match all parts of a command</span>
<span class="linecomment">;;  name; it need match only a prefix.  For example, nil means that</span>
<span class="linecomment">;;  abbreviation `ff' also matches `find-file-other-window' and `fg'</span>
<span class="linecomment">;;  also matches `find-grep-dired'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, you can input both abbreviations and commands at the</span>
<span class="linecomment">;;  same prompt, and you can take advantage of the multi-command</span>
<span class="linecomment">;;  feature to execute multiple commands.  You can thus treat command</span>
<span class="linecomment">;;  abbreviations just like commands.  If an abbreviation matches a</span>
<span class="linecomment">;;  single command name, then that command is invoked immediately.  If</span>
<span class="linecomment">;;  it matches more than one, then you can use completion to choose</span>
<span class="linecomment">;;  one.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One or more, that is - multi-command completion is available for</span>
<span class="linecomment">;;  both abbreviations and commands.  That is, you can invoke any</span>
<span class="linecomment">;;  number of them within the same use of `C-x SPC'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What happens if your input matches a command name but it is also</span>
<span class="linecomment">;;  an abbreviation for other command names?  By default, command</span>
<span class="linecomment">;;  names take precedence: if your input matches a command name then</span>
<span class="linecomment">;;  that command is invoked.  So, for example, by default the command</span>
<span class="linecomment">;;  `cd' takes precedence over `cd' as an abbreviation for commands</span>
<span class="linecomment">;;  such as `compile-defun' and `cancel-debug-on-entry'.  If you</span>
<span class="linecomment">;;  instead want abbreviations to take precedence over command names,</span>
<span class="linecomment">;;  then set option `icicle-command-abbrev-priority-flag' to t.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Abbreviations are completed against the (persistent) list of</span>
<span class="linecomment">;;  abbreviations you have used in the past.  That list is also</span>
<span class="linecomment">;;  directly customizable as option `icicle-command-abbrev-alist'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Besides completing against past abbreviations, you can enter new</span>
<span class="linecomment">;;  abbreviations (the completion is thus lax).  When you exit Emacs,</span>
<span class="linecomment">;;  your abbreviations list is updated and saved, along with the</span>
<span class="linecomment">;;  number of times you've used each abbreviation.  The latter</span>
<span class="linecomment">;;  information is used to sort your abbreviations for completion, so</span>
<span class="linecomment">;;  that those used most frequently are available first.</span>
 
<span class="linecomment">;;(@* "Choose All Completion Candidates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Choose All Completion Candidates</span>
<span class="linecomment">;;  --------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The previous section describes how you can use `C-RET'</span>
<span class="linecomment">;;  (`icicle-candidate-action') to choose (act on) multiple completion</span>
<span class="linecomment">;;  candidates, individually.  If you hold down the Control key while</span>
<span class="linecomment">;;  you cycle through the candidates, you can run through each of</span>
<span class="linecomment">;;  them, one by one.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-all-candidates-action', which is bound to `C-!' in</span>
<span class="linecomment">;;  the minibuffer, is a shorthand way of doing that: act on all</span>
<span class="linecomment">;;  candidates that match the current input.  In many contexts, `C-!'</span>
<span class="linecomment">;;  reports on any objects that were not acted upon successfully (in</span>
<span class="linecomment">;;  buffer *Help*).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  All multi-commands let you use `C-!' in this way.  Whenever a</span>
<span class="linecomment">;;  command defines a special action for `C-RET' to perform on the</span>
<span class="linecomment">;;  current completion candidate, you can use `C-!' to perform it on</span>
<span class="linecomment">;;  all candidates at once.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Perhaps you already use `% m' (command `dired-mark-files-regexp')</span>
<span class="linecomment">;;  in Dired to mark all files that match a given regular expression,</span>
<span class="linecomment">;;  and then operate on all of the marked files in some way (search</span>
<span class="linecomment">;;  with `A', query-replace with `Q', open with `F', delete with `D',</span>
<span class="linecomment">;;  and so on).  When you execute a multi-command, `C-!' lets you do</span>
<span class="linecomment">;;  something similar.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  How does it work?  It applies `icicle-candidate-action-fn' to each</span>
<span class="linecomment">;;  completion candidate that (apropos- or prefix-) matches the</span>
<span class="linecomment">;;  current input in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Most top-level Icicles commands are multi-commands.  Command</span>
<span class="linecomment">;;  `icicle-delete-file' is an example.  Instead of entering a file</span>
<span class="linecomment">;;  name at the prompt (e.g. using completion or cycling), you can</span>
<span class="linecomment">;;  type a regular expression, use `S-TAB' to see all matching files,</span>
<span class="linecomment">;;  and then use `C-!' to delete all of them at once.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You get the idea: Use the minibuffer to determine a set of objects</span>
<span class="linecomment">;;  by pattern matching, and then act on all elements of the set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to `C-!', keys `M-!', `C-|', and `M-|' act similarly:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `M-!' is like `C-!', but it acts on the list of matching</span>
<span class="linecomment">;;    candidates as a whole, rather than acting individually on each</span>
<span class="linecomment">;;    candidate.  For example, with command `icicle-customize-face',</span>
<span class="linecomment">;;    `M-!' opens a single Customize buffer for all of the matching</span>
<span class="linecomment">;;    faces, while `C-!' opens a separate Customize buffer for each</span>
<span class="linecomment">;;    face.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-|' and `M-|' are like `C-!' and `M-!', respectively, but they</span>
<span class="linecomment">;;    apply an alternative action, not the normal action, whenever one</span>
<span class="linecomment">;;    is available.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In the definition of a given multi-command, the appropriate action</span>
<span class="linecomment">;;  functions are bound to variables:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-action-fn' (`C-!') - normal single-candidate</span>
<span class="linecomment">;;    action</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-alt-action-fn' (`C-|') - alternative</span>
<span class="linecomment">;;    single-candidate action</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-all-candidates-list-action-fn' (`M-!') - normal</span>
<span class="linecomment">;;    list-of-candidates action</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-all-candidates-list-alt-action-fn' (`M-|') - alternative</span>
<span class="linecomment">;;    list-of-candidates action</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For most multi-commands, however, only the normal single-candidate</span>
<span class="linecomment">;;  action is defined.  In this case, `M-!'  duplicates what `C-!'</span>
<span class="linecomment">;;  does, and the alternative action keys have no effect.  If the</span>
<span class="linecomment">;;  corresponding function is not available, each of the list-action</span>
<span class="linecomment">;;  keys (`M-!', `M-|') acts the same as the corresponding</span>
<span class="linecomment">;;  single-candidate key (`C-!', `C-|), and vice versa.  So for</span>
<span class="linecomment">;;  instance, if `icicle-candidate-alt-action-fn' is nil, then `M-!'</span>
<span class="linecomment">;;  acts the same as `C-!'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a shortcut, if you have saved completion candidates and they</span>
<span class="linecomment">;;  all belong to the current set of completion candidates, then `C-!'</span>
<span class="linecomment">;;  acts on the saved candidates instead of the complete set of</span>
<span class="linecomment">;;  candidates.  This means that you need not first do `C-M-&lt;' to</span>
<span class="linecomment">;;  retrieve the saved candidates; you can do `C-!' directly to act on</span>
<span class="linecomment">;;  them.  `C-|', `M-!', and `M-|' work the same way.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Dired Enhancements")</span>
<span class="linecomment">;;    for an Icicles alternative to both `A' and `Q' (search and</span>
<span class="linecomment">;;    replace) in Dired.</span>
 
<span class="linecomment">;;(@* "Sets of Completion Candidates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sets of Completion Candidates</span>
<span class="linecomment">;;  -----------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whereas `C-RET' acts on individual objects, `C-!'  acts on an</span>
<span class="linecomment">;;  entire set of objects at once, via their names: the set of all</span>
<span class="linecomment">;;  current completion candidates.  There are additional Icicles</span>
<span class="linecomment">;;  commands that also act, not on individual completion candidates,</span>
<span class="linecomment">;;  but on one or more sets of completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One of these is `M-*', which effectively narrows the set of</span>
<span class="linecomment">;;  completion candidates by taking the intersection of the candidate</span>
<span class="linecomment">;;  sets defined by various input regexps.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section presents some more Icicles commands that act on sets</span>
<span class="linecomment">;;  of completion candidates.  The basic idea is that you can perform</span>
<span class="linecomment">;;  set operations using the current set of completion candidates,</span>
<span class="linecomment">;;  changing it into a different set.  You can, then, for example, use</span>
<span class="linecomment">;;  `C-!' to act on everything in a custom-defined set.  Or you can</span>
<span class="linecomment">;;  define a custom set that you want to use often (for example, a</span>
<span class="linecomment">;;  list of project files), save it persistently, and then retrieve it</span>
<span class="linecomment">;;  later to use for completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Saving and Retrieving Completion Candidates")</span>
<span class="linecomment">;;  ** Saving and Retrieving Completion Candidates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Set operations such as union and difference act on two sets.  The</span>
<span class="linecomment">;;  current set of completion candidates is always one of these sets.</span>
<span class="linecomment">;;  If an operation, such as set complement, acts on a single set,</span>
<span class="linecomment">;;  then it acts on the current set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When two sets are involved, the other set is called the "saved</span>
<span class="linecomment">;;  set".  This just means that at some previous time in your sesssion</span>
<span class="linecomment">;;  you saved some completion candidates as the value of variable</span>
<span class="linecomment">;;  `icicle-saved-completion-candidates'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In buffer `*Completions*', candidates that have been saved are</span>
<span class="linecomment">;;  highlighted using face `icicle-saved-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, the saved set is not persistent; it is saved only</span>
<span class="linecomment">;;  until the next save in the same Emacs session overwrites it or</span>
<span class="linecomment">;;  adds to it.  See (@&gt; "Persistent Sets of Completion Candidates")</span>
<span class="linecomment">;;  for ways to save candidates persistently.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One way you can save candidates is to use</span>
<span class="linecomment">;;  `icicle-candidate-set-save', bound to `C-M-&gt;'.  This saves all of</span>
<span class="linecomment">;;  the current candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Gotcha: If you use progressive completion and you have not yet</span>
<span class="linecomment">;;          typed anything after `M-*' or `S-SPC', then there is not</span>
<span class="linecomment">;;          yet a set of candidates to save.  If you use `C-M-&gt;' at</span>
<span class="linecomment">;;          that point, you will reset the saved candidates to none.</span>
<span class="linecomment">;;          To define the current candidates, either type something or</span>
<span class="linecomment">;;          use `S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another way to save candidates, besides `C-M-&gt;', is to select</span>
<span class="linecomment">;;  candidates in buffer `*Completions*' using the (active) region,</span>
<span class="linecomment">;;  and then use `icicle-candidate-set-save-selected', bound to</span>
<span class="linecomment">;;  `C-M-)'.  This saves any candidates that are at least partially in</span>
<span class="linecomment">;;  the region.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also use `C-M-)' to UNsave all candidates: just select no</span>
<span class="linecomment">;;  candidates before you hit `C-M-)', to reset the set of saved</span>
<span class="linecomment">;;  completions to none.  Think of this as replacing the saved set</span>
<span class="linecomment">;;  with the empty set (no candidates).  And you need not use `TAB' or</span>
<span class="linecomment">;;  `S-TAB' first to use this, since the current set of candidates is</span>
<span class="linecomment">;;  not used in any way when you reset the saved set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-mouse-candidate-set-save', bound to `M-S-mouse-3'</span>
<span class="linecomment">;;  in `*Completions*' combines these two: if the region is active,</span>
<span class="linecomment">;;  then the selected candidates become the saved set; otherwise, all</span>
<span class="linecomment">;;  candidates are saved.  This binding makes it easy to save</span>
<span class="linecomment">;;  candidates using the mouse: select them (e.g. drag or double-click</span>
<span class="linecomment">;;  `mouse-1', or click `mouse-1' then `mouse-3'), then use</span>
<span class="linecomment">;;  `M-S-mouse-3' to save.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can process the list of saved candidates in any way you like</span>
<span class="linecomment">;;  using Emacs Lisp.  For example, you can save a list of file names</span>
<span class="linecomment">;;  that match a regexp, then print the list or process the individual</span>
<span class="linecomment">;;  files in some way.  Here, for instance, is how to save the set of</span>
<span class="linecomment">;;  file names that contain either `dir' or `ici':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-x C-f \(dir\|ici\) S-TAB C-M-&gt; C-g'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can retrieve a set of saved candidates with command</span>
<span class="linecomment">;;  `icicle-candidate-set-retrieve', bound to `C-M-&lt;'.  This replaces</span>
<span class="linecomment">;;  the current set of candidates with those retrieved.  It also acts</span>
<span class="linecomment">;;  like `M-*' by entering a recursive minibuffer, which removes any</span>
<span class="linecomment">;;  saved-candidates highlighting.  Using `TAB' or `S-TAB' restores</span>
<span class="linecomment">;;  the highlighting.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `C-&lt;' to retrieve a set of saved candidates and add</span>
<span class="linecomment">;;  them to the current candidates, instead of replacing those</span>
<span class="linecomment">;;  candidates.  This way, you can build up the current set of</span>
<span class="linecomment">;;  candidates by retrieving (combining) several saved sets.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In the other direction, you can save additional candidates, adding</span>
<span class="linecomment">;;  them to a set of candidates already saved, in these ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-&gt;' (`icicle-candidate-set-save-more') adds all of the current</span>
<span class="linecomment">;;    candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-)' (`icicle-candidate-set-save-more-selected') adds any</span>
<span class="linecomment">;;    candidates that you have selected using the region in</span>
<span class="linecomment">;;    `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `M-mouse-3' (`icicle-mouse-candidate-set-save-more') acts the</span>
<span class="linecomment">;;    same as `C-)' or `C-&gt;', depending on whether or not the region</span>
<span class="linecomment">;;    is active in `*Completions*': it adds selected or all</span>
<span class="linecomment">;;    candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Extending the region with `mouse-3', and then clicking `mouse-3'</span>
<span class="linecomment">;;    again in the same place, acts the same as `C-)'.  That is, click</span>
<span class="linecomment">;;    `mouse-1', then click `mouse-3' twice in another location, to</span>
<span class="linecomment">;;    save all candidates between the `mouse-1' and `mouse-3'</span>
<span class="linecomment">;;    positions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The `insert' key (`icicle-save/unsave-candidate') adds just the</span>
<span class="linecomment">;;    current completion candidate (e.g. during cycling).  Clicking a</span>
<span class="linecomment">;;    candidate in `*Completions*' with `M-S-mouse-2'</span>
<span class="linecomment">;;    (`icicle-mouse-save/unsave-candidate') does the same thing.  If</span>
<span class="linecomment">;;    you do this to a candidate that has already been saved, then it</span>
<span class="linecomment">;;    is UNsaved (no longer saved).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that the `insert' key and `M-S-mouse-2' are toggles for a</span>
<span class="linecomment">;;  given candidate, saving or unsaving it.  In this sense each is its</span>
<span class="linecomment">;;  own opposite.  In another sense, the opposite operation of saving</span>
<span class="linecomment">;;  is simply removing a candidate from the current set of candidates.</span>
<span class="linecomment">;;  You do that using the `delete' key or `S-mouse-2'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Matching, saving, and retrieving candidates is a powerful way to</span>
<span class="linecomment">;;  interact with completion.  One important use is to prepare a list</span>
<span class="linecomment">;;  of candidates on which to act, and then act on them all at once</span>
<span class="linecomment">;;  using `C-!'.  This is a good way to proceed when you want to</span>
<span class="linecomment">;;  double-check what to act on, before you actually act.  This is the</span>
<span class="linecomment">;;  same idea behind marking files in Dired and then operating on the</span>
<span class="linecomment">;;  marked files, using `x'.  It corresponds to what is represented in</span>
<span class="linecomment">;;  some user interfaces by filling out a checklist followed by</span>
<span class="linecomment">;;  clicking `OK'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Different Places for Saving and Retrieving Candidates")</span>
<span class="linecomment">;;  ** Different Places for Saving and Retrieving Candidates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can save completion candidates to a different variable from</span>
<span class="linecomment">;;  `icicle-saved-completion-candidates' by using a numeric prefix</span>
<span class="linecomment">;;  argument to command `icicle-candidate-set-save'; that is, use `C-u</span>
<span class="linecomment">;;  N C-M-&gt;'.  Alternatively, use `C-M-}', which is bound to command</span>
<span class="linecomment">;;  `icicle-candidate-set-save-to-variable'.  You are prompted for the</span>
<span class="linecomment">;;  name of the variable, and you can use completion when inputting</span>
<span class="linecomment">;;  it.  During this completion, the only available candidates are</span>
<span class="linecomment">;;  variables that you have used for saved candidates (but completion</span>
<span class="linecomment">;;  is lax, so you can type a new variable name).  The same behavior</span>
<span class="linecomment">;;  works also for `C-&gt;', `C-M-)', and `C-)'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To retrieve completion candidates that were previously saved to a</span>
<span class="linecomment">;;  variable other than `icicle-saved-completion-candidates', so that</span>
<span class="linecomment">;;  they become the current set of candidates, use `C-u N C-M-&lt;',</span>
<span class="linecomment">;;  where N is an integer, or `C-M-{' (`icicle-candidate-set-retrieve'</span>
<span class="linecomment">;;  or `icicle-candidate-set-retrieve-from-variable').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Using a plain prefix argument (`C-u' without a number) with</span>
<span class="linecomment">;;  `C-M-&gt;' and `C-M-&lt;' saves or retrieves a candidate set using a</span>
<span class="linecomment">;;  cache file, not a variable.  Alternatively, as a shortcut you can</span>
<span class="linecomment">;;  use `C-}' and `C-{' for this.</span>
<span class="linecomment">;;  See (@&gt; "Persistent Sets of Completion Candidates") and</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Support for Projects").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you save candidates to a different variable from</span>
<span class="linecomment">;;  `icicle-saved-completion-candidates', they are not shown in buffer</span>
<span class="linecomment">;;  `*Completions*' using face `icicle-saved-candidate'.  When you</span>
<span class="linecomment">;;  save candidates to a cache file, they are also saved to</span>
<span class="linecomment">;;  `icicle-saved-completion-candidates', so they are shown in</span>
<span class="linecomment">;;  `*Completions*' using face `icicle-saved-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-&gt;' and `C-&lt;' accept the same prefix arguments as `C-M-&gt;' and</span>
<span class="linecomment">;;  `C-M-&lt;' , letting you specify the source or destination (variable,</span>
<span class="linecomment">;;  cache file) when you save or retrieve additional candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Set Operations")</span>
<span class="linecomment">;;  ** Set Operations **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The other available set-operation commands for use with completion</span>
<span class="linecomment">;;  candidates, besides saving and retrieving, are these:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-set-swap', bound to `C-%'.  Swap the saved and</span>
<span class="linecomment">;;    current sets of completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-set-define', bound to `C-:'.  Define the</span>
<span class="linecomment">;;    current set of completion candidates by evaluating an input</span>
<span class="linecomment">;;    sexp.  The sexp must evaluate to a list of strings, such as is</span>
<span class="linecomment">;;    returned by `all-completions'.  You can use this to substitute</span>
<span class="linecomment">;;    any list of strings, and then operate on them as completions,</span>
<span class="linecomment">;;    using any Icicles functionalities.  Keep in mind, however, that</span>
<span class="linecomment">;;    the completions must be of the proper type for the context in</span>
<span class="linecomment">;;    which they are used.  For example, if you are executing a</span>
<span class="linecomment">;;    command, they must be command names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-set-complement', bound to `C-~'.  Complement</span>
<span class="linecomment">;;    the current set of candidates: replace the current candidate set</span>
<span class="linecomment">;;    with its set complement.  This means all possible completions of</span>
<span class="linecomment">;;    the appropriate type that do *not* match the current input.  You</span>
<span class="linecomment">;;    can combine this with progressive completion (`M-*') to</span>
<span class="linecomment">;;    progressively eliminate candidates that match different inputs.</span>
<span class="linecomment">;;    This process-of-elimination matching is a common Icicles usage</span>
<span class="linecomment">;;    idiom.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-set-union', bound to `C-+'.  Replace the</span>
<span class="linecomment">;;    current candidate set by its union with the saved set of</span>
<span class="linecomment">;;    candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-set-difference', bound to `C--'.  Replace the</span>
<span class="linecomment">;;    current candidate set by its set difference with the saved set</span>
<span class="linecomment">;;    of candidates.  That is, the saved candidates are subtracted</span>
<span class="linecomment">;;    from the current candidates, and the result becomes the current</span>
<span class="linecomment">;;    candidate set.  To obtain the opposite set difference,</span>
<span class="linecomment">;;    subtracting the current candidates from the saved candidates,</span>
<span class="linecomment">;;    just use `icicle-candidate-set-swap' followed by</span>
<span class="linecomment">;;    `icicle-candidate-set-difference'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-set-intersection', bound to `C-*'.  Replace</span>
<span class="linecomment">;;    the current candidate set by its intersection with the saved set</span>
<span class="linecomment">;;    of candidates.  Unlike the set intersection provided by `M-*',</span>
<span class="linecomment">;;    `C-*' is, in itself, a one-time operation.  `M-*' can be</span>
<span class="linecomment">;;    repeated, using the previous intersection as one of the sets to</span>
<span class="linecomment">;;    be intersected in a new operation.  Both `C-*' and `M-*' use the</span>
<span class="linecomment">;;    current set of matching candidates as one of the sets being</span>
<span class="linecomment">;;    intersected.  But `M-*' reads another input regexp to define the</span>
<span class="linecomment">;;    other set to be intersected, whereas `C-*' uses the saved</span>
<span class="linecomment">;;    candidates set as the other set.  `M-*' is useful for chaining,</span>
<span class="linecomment">;;    to achieve progressive approximation.  `C-*' is useful to</span>
<span class="linecomment">;;    perform an intersection on a set from a previous input reading.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-set-truncate', bound to `M-$'.  Truncate the</span>
<span class="linecomment">;;    set of completion candidates, so that it includes only the first</span>
<span class="linecomment">;;    N candidates (as displayed in `*Completions*').  You are</span>
<span class="linecomment">;;    prompted for N.  You can use this when the order of candidates</span>
<span class="linecomment">;;    represents priority in some way, so that you are interested only</span>
<span class="linecomment">;;    in the topmost candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can operate on or choose from all input values in the set that</span>
<span class="linecomment">;;  results from any of these set operations.  For example, you can</span>
<span class="linecomment">;;  use `C-~' to see the list of objects that do not match the current</span>
<span class="linecomment">;;  input, to cycle among those objects, or to operate on any or all</span>
<span class="linecomment">;;  of them.  Use `C-~' at any time to switch to the complement of the</span>
<span class="linecomment">;;  current set of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Example: To cycle through all files whose names do not end in</span>
<span class="linecomment">;;           `el', you can do the following:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Use `C-f' to read a file name.</span>
<span class="linecomment">;;  2. Type `el$' to match all file names that end in `el'.</span>
<span class="linecomment">;;  3. Use `S-TAB' to show the matching files.</span>
<span class="linecomment">;;  4. Use `C-~' to flip to the complement: files not ending in `el'.</span>
<span class="linecomment">;;  5. Use `next' or `prior' to cycle among the new set of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A minibuffer message briefly confirms each of the set operations.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When buffer `*Completions*' is displayed, the union, difference,</span>
<span class="linecomment">;;  and intersection commands scroll the buffer when repeated.</span>
<span class="linecomment">;;  Repeating `icicle-candidate-set-complement' complements the</span>
<span class="linecomment">;;  complement, of course, giving the original set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Once you have established a set of completion candidates using any</span>
<span class="linecomment">;;  of the candidate-set commands, you can cycle among the candidates</span>
<span class="linecomment">;;  of that set using either prefix or apropos cycling (that is,</span>
<span class="linecomment">;;  `next'/`prior' or `down'/`up').  However, switching from prefix to</span>
<span class="linecomment">;;  apropos cycling (or completion), or vice versa, establishes a new</span>
<span class="linecomment">;;  completion set of the appropriate type, as usual.  Switching</span>
<span class="linecomment">;;  completion type signifies that you are finished with the specially</span>
<span class="linecomment">;;  defined completion set, and you want to redefine it using apropos</span>
<span class="linecomment">;;  or prefix cycling or completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Prefix icompletion (`icomplete.el' or `icomplete+.el' - see</span>
<span class="linecomment">;;        (@&gt; "Icompletion")) does not take into account the candidate</span>
<span class="linecomment">;;        set resulting from a set operation: it always displays the</span>
<span class="linecomment">;;        normal set of prefix completions in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: You might have noticed that, as a mnemonic device, the keys</span>
<span class="linecomment">;;        bound to the various set operations use the corresponding</span>
<span class="linecomment">;;        binary arithmetic or Boolean operators: `~' (unary negation)</span>
<span class="linecomment">;;        for complement (not); `*' (multiplication) for intersection</span>
<span class="linecomment">;;        (and); `+' (addition) for union (or); and `-' (subtraction)</span>
<span class="linecomment">;;        for difference.  Note too that the `C--' and `C-+' bindings</span>
<span class="linecomment">;;        mean that you cannot use these key sequences for prefix</span>
<span class="linecomment">;;        arguments - you must use `C-u N', or `M-N' instead, where N</span>
<span class="linecomment">;;        is a possibly signed integer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Multi-Commands") for information about `C-RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Choose All Completion Candidates") for information about</span>
<span class="linecomment">;;    `C-!'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Progressive Completion") for information about `M-*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "File-Name Input and Locating Files Anywhere") and</span>
<span class="linecomment">;;    (@&gt; "Persistent Sets of Completion Candidates"), for information</span>
<span class="linecomment">;;    about saving completion candidates persistently and retrieving</span>
<span class="linecomment">;;    them later.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "History Enhancements"), (@&gt; "Google Matching"), and</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;    for examples of other set operations on input candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Dired Enhancements")</span>
<span class="linecomment">;;    for information about saving and reusing sets of file-name</span>
<span class="linecomment">;;    candidates with Dired.</span>
 
<span class="linecomment">;;(@* "Google Matching")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Google Matching</span>
<span class="linecomment">;;  ---------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section presents nothing new - but you might not want to skip</span>
<span class="linecomment">;;  it.  It points out something that you might not have picked up</span>
<span class="linecomment">;;  yet.  You've learned about Icicles regexp matching and candidate</span>
<span class="linecomment">;;  set operations, but it can be worthwhile to compare how Icicles</span>
<span class="linecomment">;;  matches inputs against completion candidates with how Google</span>
<span class="linecomment">;;  matches search strings against Web pages.  Summary: You can do</span>
<span class="linecomment">;;  pretty much the same things, but the way you accomplish them is</span>
<span class="linecomment">;;  different.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Domain of Discourse")</span>
<span class="linecomment">;;  ** Domain of Discourse **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Google, the domain of discourse, that is, the possible set of</span>
<span class="linecomment">;;  search hits, is the set of Web pages.  There are also search</span>
<span class="linecomment">;;  fields that limit the domain of discourse by file type, page</span>
<span class="linecomment">;;  number, update date, page position, freedom of use, and even</span>
<span class="linecomment">;;  morality ("Safe Search").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles (Emacs), the domain of discourse changes automatically,</span>
<span class="linecomment">;;  depending on the current context.  For command-name input, it is</span>
<span class="linecomment">;;  the set of all named commands; for variable-name input, it is the</span>
<span class="linecomment">;;  set of variable names; and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Global Filtering")</span>
<span class="linecomment">;;  ** Global Filtering **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Google, you can limit searching to specific Web sites, or</span>
<span class="linecomment">;;  exclude certain Web sites from searching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, you can add extra completion candidates, using</span>
<span class="linecomment">;;  variable `icicle-extra-candidates', and you can filter out (other)</span>
<span class="linecomment">;;  candidates globally, using filter variables</span>
<span class="linecomment">;;  `icicle-must-match-regexp', `icicle-must-not-match-regexp', and</span>
<span class="linecomment">;;  `icicle-must-pass-predicate'.  These are internal Icicles</span>
<span class="linecomment">;;  variables.  Normally, you do not change them directly; instead, a</span>
<span class="linecomment">;;  command can use them to limit or extend the effective domain of</span>
<span class="linecomment">;;  discourse.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc2.el" :to "Global Filters").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Variable `icicle-must-pass-predicate' applies to the textual</span>
<span class="linecomment">;;  candidates that are displayed in buffer `*Completions*'.  You can</span>
<span class="linecomment">;;  also apply a predicate to the full alist-entry candidates that are</span>
<span class="linecomment">;;  supplied to `completing-read' or `read-file-name'.  As a</span>
<span class="linecomment">;;  programmer, you can of course do that when your code calls these</span>
<span class="linecomment">;;  functions.  As an Icicles user, you can use `M-&' to define and</span>
<span class="linecomment">;;  apply predicates to such alist-entry candidates on the fly, while</span>
<span class="linecomment">;;  completing.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Word Matching and String Matching")</span>
<span class="linecomment">;;  ** Word Matching and String Matching **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Google matches words, by default, but you can specify an "exact</span>
<span class="linecomment">;;  phrase" to get literal string matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, Icicles (apropos-)matches regexps, but you can use</span>
<span class="linecomment">;;  `\b' in a regexp to perform word matching, and you can use `C-`'</span>
<span class="linecomment">;;  (`icicle-toggle-regexp-quote') to perform exact (literal)</span>
<span class="linecomment">;;  matching.  See (@&gt; "What About Special-Character Conflicts?").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "AND Matching and OR Matching")</span>
<span class="linecomment">;;  ** AND Matching and OR Matching **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Google has search fields for AND matching ("with all of the</span>
<span class="linecomment">;;  words") and OR matching ("with at least one of the words").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, you can use progressive completion to perform AND</span>
<span class="linecomment">;;  matching: use `M-*' to introduce each term to match.</span>
<span class="linecomment">;;  Alternatively, you can use `C-*'</span>
<span class="linecomment">;;  (`icicle-candidate-set-intersection').  You can use `C-+'</span>
<span class="linecomment">;;  (`icicle-candidate-set-union') to perform OR matching.  Note that,</span>
<span class="linecomment">;;  by definition, unordered AND matching is not possible using a</span>
<span class="linecomment">;;  single regexp.  See (@&gt; "Progressive Completion") and</span>
<span class="linecomment">;;  (@&gt; "Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "NOT Matching")</span>
<span class="linecomment">;;  ** NOT Matching **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Google has a search field for terms that must not occur in search</span>
<span class="linecomment">;;  hits: "without the words".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, you can use `C-~' (`icicle-candidate-set-complement')</span>
<span class="linecomment">;;  to exclude matching completion candidates.  You can combine this</span>
<span class="linecomment">;;  with progressive completion, to exclude any number of terms: `toto</span>
<span class="linecomment">;;  C-~ M-* titi C-~ M-* foobar' excludes all candidates matching</span>
<span class="linecomment">;;  toto, titi, or foobar.  Use this process-of-eliminiation technique</span>
<span class="linecomment">;;  to progressively pare down the set of possible candidates.  Note</span>
<span class="linecomment">;;  that such generalized complementing (as opposed to complementing a</span>
<span class="linecomment">;;  character set) is not possible using a single regexp -- you cannot</span>
<span class="linecomment">;;  use a regular expression to say "Show me everything that does</span>
<span class="linecomment">;;  *not* match this".  See (@&gt; "Sets of Completion Candidates") and</span>
<span class="linecomment">;;  (@&gt; "Progressive Completion").</span>
 
<span class="linecomment">;;(@* "File-Name Input and Locating Files Anywhere")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  File-Name Input and Locating Files Anywhere</span>
<span class="linecomment">;;  -------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Emacs offers two main functions for reading minibuffer input with</span>
<span class="linecomment">;;  completion: `completing-read' and `read-file-name'.  Icicles uses</span>
<span class="linecomment">;;  both of these, and it enhances each of them in various ways for</span>
<span class="linecomment">;;  use in your own Emacs-Lisp code.  These two functions can each be</span>
<span class="linecomment">;;  used to read file-name input, but they do so in very different</span>
<span class="linecomment">;;  ways.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: In addition to the usual Icicles key bindings, during</span>
<span class="linecomment">;;  file-name completion you can use `C-backspace'</span>
<span class="linecomment">;;  (`icicle-up-directory') to navigate up the directory hierarchy.</span>
<span class="linecomment">;;  It removes the last directory component (and any partial file</span>
<span class="linecomment">;;  name) from your minibuffer input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Whether a command supports file-name globbing wildcards such</span>
<span class="linecomment">;;  as `*' is independent of whether it uses `read-file-name' or</span>
<span class="linecomment">;;  `completing-read'.  It is the command itself that offers such</span>
<span class="linecomment">;;  support or not.  Globbing takes place only after the file name</span>
<span class="linecomment">;;  (with wildcards) is read.  All Icicles commands that visit files</span>
<span class="linecomment">;;  (all of the commands mentioned in this section) let you use</span>
<span class="linecomment">;;  globbing wildcards.  Remember also that file-name globbing, with</span>
<span class="linecomment">;;  its special wildcards, has nothing to do with regexp completion</span>
<span class="linecomment">;;  matching.  See (@&gt; "What About Special-Character Conflicts?") for</span>
<span class="linecomment">;;  more information about file-name globbing.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Function `read-file-name'")</span>
<span class="linecomment">;;  ** Function `read-file-name' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Function `read-file-name' is specialized for file-name input with</span>
<span class="linecomment">;;  completion.  It knows about files and file names for your current</span>
<span class="linecomment">;;  platform.  It knows about Emacs remote file name syntax (Tramp,</span>
<span class="linecomment">;;  ange-ftp).  Using `read-file-name' is the most flexible way to</span>
<span class="linecomment">;;  read a file name in Emacs, and it is the traditional way.  Unless</span>
<span class="linecomment">;;  stated otherwise, "file-name completion", even in the Icicles doc,</span>
<span class="linecomment">;;  refers to `read-file-name' completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When `read-file-name' reads input, only the file name itself, not</span>
<span class="linecomment">;;  the directory portion, is used for matching.  The directory is</span>
<span class="linecomment">;;  understood to be the value of variable `default-directory' (which</span>
<span class="linecomment">;;  you can change using command `cd', for instance).  The behavior is</span>
<span class="linecomment">;;  thus the same whether or not the directory name is present in the</span>
<span class="linecomment">;;  minibuffer.  If you prefer, you can delete the directory name</span>
<span class="linecomment">;;  first, using `M-k'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  With `read-file-name', you can thus use apropos completion to</span>
<span class="linecomment">;;  match a file-name substring, without needing to prefix the</span>
<span class="linecomment">;;  substring with `.*' in the minibuffer.  For example, to match the</span>
<span class="linecomment">;;  file named `favorite-foo-file.bar' in directory</span>
<span class="linecomment">;;  `/some/path/to/my/', you need not use `/some/path/to/my/.*foo'; it</span>
<span class="linecomment">;;  is sufficient to use either `foo' or `/some/path/to/my/foo'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  An additional feature of `read-file-name' in Icicle mode is that</span>
<span class="linecomment">;;  candidates that are directory names are highlighted in buffer</span>
<span class="linecomment">;;  `*Completions*' using face `icicle-special-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Function `completing-read'")</span>
<span class="linecomment">;;  ** Function `completing-read' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Function `completing-read' is a general function for reading input</span>
<span class="linecomment">;;  with completion.  It is not specially designed for reading file</span>
<span class="linecomment">;;  names.  It knows nothing about files and file names. It knows</span>
<span class="linecomment">;;  nothing about remote file-name syntax.  When `completing-read'</span>
<span class="linecomment">;;  reads input, it makes no use of `default-directory'.  The</span>
<span class="linecomment">;;  completion candidates are treated as simple strings; they are not</span>
<span class="linecomment">;;  really treated as file names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles commands that use `completing-read' to read a file name</span>
<span class="linecomment">;;  typically read an absolute name, that is, a name that includes the</span>
<span class="linecomment">;;  directory portion.  This means that you can match against any part</span>
<span class="linecomment">;;  of the full name, including any directory components.  The</span>
<span class="linecomment">;;  directory portions of the candidate file names need not be the</span>
<span class="linecomment">;;  same - you can thus complete against a set of files in multiple</span>
<span class="linecomment">;;  directories.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicles Commands that Read File Names")</span>
<span class="linecomment">;;  ** Icicles Commands that Read File Names **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles commands that use `read-file-name' include all</span>
<span class="linecomment">;;  multi-commands, such as `icicle-find-file', that are defined using</span>
<span class="linecomment">;;  `icicle-define-file-command'.  Vanilla Emacs command `find-file'</span>
<span class="linecomment">;;  is another example of a command that uses `read-file-name'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles commands that use `completing-read' to read file names</span>
<span class="linecomment">;;  include the multi-commands `icicle-find-file-absolute',</span>
<span class="linecomment">;;  `icicle-recent-file', and `icicle-locate-file'.  These are defined</span>
<span class="linecomment">;;  using `icicle-define-command', not `icicle-define-file-command'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are also `-other-window' versions of all of the Icicles</span>
<span class="linecomment">;;  commands that read file names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The Icicles commands that read absolute file names have an</span>
<span class="linecomment">;;  additional feature: you can use a prefix argument to tell them to</span>
<span class="linecomment">;;  combine the last modification date with the file name, as a</span>
<span class="linecomment">;;  multi-completion - see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Multi-Completions").</span>
<span class="linecomment">;;  This means that you can easily look up files whose modification</span>
<span class="linecomment">;;  time or date matches some (regexp) criterion, such as being</span>
<span class="linecomment">;;  sometime in July 2008.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When using a command that reads an absolute file name, remember</span>
<span class="linecomment">;;  that, to save space, you can use `C-M-.' to toggle hiding of the</span>
<span class="linecomment">;;  common match portions of the candidates in `*Completions*'.  This</span>
<span class="linecomment">;;  portion is often a long directory substring.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-file' is bound, by default, to `C-x C-f' in Icicle</span>
<span class="linecomment">;;  mode, thus taking the place of `find-file'.  It combines</span>
<span class="linecomment">;;  `icicle-find-file' and `icicle-find-file-absolute'.  With no</span>
<span class="linecomment">;;  prefix argument, it matches relative file names; with a prefix</span>
<span class="linecomment">;;  argument, it matches absolute names (as ordinary strings).  With a</span>
<span class="linecomment">;;  negative prefix argument, you can match also the modification</span>
<span class="linecomment">;;  date.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  An additional feature of `icicle-find-file-absolute' and</span>
<span class="linecomment">;;  `icicle-find-file-absolute-other-window' is that candidates that</span>
<span class="linecomment">;;  are directory names are highlighted in buffer `*Completions*'</span>
<span class="linecomment">;;  using face `icicle-special-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `icicle-recent-file' to open any file that you have</span>
<span class="linecomment">;;  visited recently, perhaps in a previous Emacs session.  You can</span>
<span class="linecomment">;;  use `icicle-locate-file' to find a file when you do not know what</span>
<span class="linecomment">;;  directory it is in.  It looks throughout a given directory,</span>
<span class="linecomment">;;  including throughout all of its subdirectories.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, the target directory for `icicle-locate-file' is the</span>
<span class="linecomment">;;  current directory, but if you supply a non-negative numeric prefix</span>
<span class="linecomment">;;  argument (non-positive means include the date), then you are</span>
<span class="linecomment">;;  prompted for the directory to search.  If you use the root of your</span>
<span class="linecomment">;;  file system as the search directory, then the locate-file commands</span>
<span class="linecomment">;;  will match completion candidates anywhere in your file system.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This can be quite useful.  It gives you much of the power of the</span>
<span class="linecomment">;;  Unix `find' command just for completing input!  And with</span>
<span class="linecomment">;;  incremental completion (see (@&gt; "Icompletion")), you can see what</span>
<span class="linecomment">;;  matches your input as you type.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Obviously, if you use your entire file system as the set of</span>
<span class="linecomment">;;  completion candidates, then gathering and matching such a large</span>
<span class="linecomment">;;  set of file names can take some time.  On my hard drive, for</span>
<span class="linecomment">;;  instance, there are 36 GB full of files, and it takes about 40</span>
<span class="linecomment">;;  seconds to gather all of the file names.  In spite of this</span>
<span class="linecomment">;;  inconvenience, this functionality can be useful.  And of course</span>
<span class="linecomment">;;  searching a shallower directory tree presents less of a</span>
<span class="linecomment">;;  performance penalty - you pay for what you get.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There is a way, however, of having your cake and eating it too.</span>
<span class="linecomment">;;  You can gather all of the file names in your file system once, and</span>
<span class="linecomment">;;  save that list of completion candidates to a cache file on disk,</span>
<span class="linecomment">;;  as a snapshot.</span>
<span class="linecomment">;;  See (@&gt; "Persistent Sets of Completion Candidates"), for how to do</span>
<span class="linecomment">;;  this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Absolute File Names and Different Directories")</span>
<span class="linecomment">;;  ** Absolute File Names and Different Directories **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Since `completing-read' has no understanding of file-name syntax,</span>
<span class="linecomment">;;  including remote file-name syntax, `icicle-find-file-absolute'</span>
<span class="linecomment">;;  (`C-u C-x C-f') and similar commands are similarly ignorant.  (You</span>
<span class="linecomment">;;  can nevertheless use `C-.' with these Icicles commands, to toggle</span>
<span class="linecomment">;;  respect of `completion-ignored-extensions'.)  In particular, these</span>
<span class="linecomment">;;  commands will not let you complete to a remote file name if the</span>
<span class="linecomment">;;  current directory is local.  They also will not let you complete</span>
<span class="linecomment">;;  to a file name in a different local directory.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because all Icicles commands that read file names use lax</span>
<span class="linecomment">;;  completion, you can nevertheless visit a file in a different</span>
<span class="linecomment">;;  directory (remote or local) from the current one, even though you</span>
<span class="linecomment">;;  cannot complete your input to such a name.  That is, you can</span>
<span class="linecomment">;;  always use `RET' with any file name as minibuffer input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So how can you complete your input to an absolute file-name in a</span>
<span class="linecomment">;;  different directory?  By retrieving a saved candidate set that has</span>
<span class="linecomment">;;  such absolute names and then completing against that set.  For</span>
<span class="linecomment">;;  example, you can retrieve a set that represents files on a remote</span>
<span class="linecomment">;;  machine and complete to their names even from a local directory.</span>
<span class="linecomment">;;  All that counts for `completing-read' is that your input can match</span>
<span class="linecomment">;;  candidates, where that matching is ordinary (apropos or prefix)</span>
<span class="linecomment">;;  string matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To create such a saved set of names, you can visit the directory</span>
<span class="linecomment">;;  (perhaps remote) that contains the files and then use `C-u C-x</span>
<span class="linecomment">;;  C-f' and `C-}' to save the candidates.  You can later retrieve</span>
<span class="linecomment">;;  this saved set for completion, no matter what the current</span>
<span class="linecomment">;;  directory is.  As another example, you can use</span>
<span class="linecomment">;;  `icicle-locate-file' in a remote directory to create a saved set</span>
<span class="linecomment">;;  that includes remote files that are all somewhere under that</span>
<span class="linecomment">;;  remote directory.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, you can add more file names to an existing saved set</span>
<span class="linecomment">;;  using `C-&gt;', `C-)', `M-mouse-3', `insert', or `M-S-mouse-2' - see</span>
<span class="linecomment">;;  (@&gt; "Sets of Completion Candidates"). The added names can come</span>
<span class="linecomment">;;  from a different directory than files already in the saved set. In</span>
<span class="linecomment">;;  this way, you can build up a saved set that includes files from</span>
<span class="linecomment">;;  any directories, some of which can be local and some remote, some</span>
<span class="linecomment">;;  remote from one host, some remote from another, and so on. You can</span>
<span class="linecomment">;;  create a saved set with any mix of absolute file names from any</span>
<span class="linecomment">;;  locations.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Remember this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * To create and add to a saved set of absolute file names, use a</span>
<span class="linecomment">;;    command that expects absolute file names, and do this from the</span>
<span class="linecomment">;;    directory that contains the files you want to add.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * When you retrieve a saved set of file-name candidates for</span>
<span class="linecomment">;;    completion, use a command that expects the same kind of file</span>
<span class="linecomment">;;    names, relative or absolute, as the saved names.  For example,</span>
<span class="linecomment">;;    if you save a set of project files that are spread over</span>
<span class="linecomment">;;    different directories (and hence are absolute), then retrieve</span>
<span class="linecomment">;;    that candidate set using, say, `C-u C-x C-f' (absolute), not</span>
<span class="linecomment">;;    `C-x C-f' (relative).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Persistent Sets of Completion Candidates") for information</span>
<span class="linecomment">;;    about saving a set of file names persistently</span>
<span class="linecomment">;;  * (@&gt; "Sets of Completion Candidates") for information about</span>
<span class="linecomment">;;    creating, saving, and retrieving sets of file names</span>
<span class="linecomment">;;  * (@&gt; "Dealing With Large Candidate Sets") for ways to deal with a</span>
<span class="linecomment">;;    large number of candidates</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Multi-Completions")</span>
 
<span class="linecomment">;;(@* "Persistent Sets of Completion Candidates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Persistent Sets of Completion Candidates</span>
<span class="linecomment">;;  ----------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Section (@&gt; "Sets of Completion Candidates") describes how you can</span>
<span class="linecomment">;;  save the current set of completion candidates and reuse it later.</span>
<span class="linecomment">;;  This is not a persistent save, however; the candidates are simply</span>
<span class="linecomment">;;  saved in variable `icicle-saved-completion-candidates' for the</span>
<span class="linecomment">;;  duration of your Emacs session (or until you save candidates</span>
<span class="linecomment">;;  again).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can save the current set of completions (whatever it is)</span>
<span class="linecomment">;;  persistently by supplying a plain prefix argument (`C-u') when you</span>
<span class="linecomment">;;  use `C-M-&gt;' (`icicle-candidate-set-save') during completion.</span>
<span class="linecomment">;;  Alternatively, you can use `C-}', bound to</span>
<span class="linecomment">;;  `icicle-candidate-set-save-persistently', which does the same</span>
<span class="linecomment">;;  thing.  To retrieve completion candidates that were previously</span>
<span class="linecomment">;;  saved to a cache file, so that they become the current set of</span>
<span class="linecomment">;;  candidates, use either `C-u C-M-&lt;' or `C-{'</span>
<span class="linecomment">;;  (`icicle-candidate-set-retrieve' or</span>
<span class="linecomment">;;  `icicle-candidate-set-retrieve-persistent').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Tip: Suppose you have already saved a set of candidates, but not</span>
<span class="linecomment">;;       persistently, and you now want to write this saved set to a</span>
<span class="linecomment">;;       cache file.  Use `C-M-&lt;' followed by `TAB' or `S-TAB',</span>
<span class="linecomment">;;       followed by `C-}'.  That is, retrieve the saved candidates</span>
<span class="linecomment">;;       and then save the retrieved candidates persistently.  (You</span>
<span class="linecomment">;;       use `TAB' or `S-TAB' because retrieval opens a recursive</span>
<span class="linecomment">;;       minibuffer.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that using a numeric prefix argument (`C-u' with a number)</span>
<span class="linecomment">;;  with `C-M-&gt;' and `C-M-&lt;' saves or retrieves a</span>
<span class="linecomment">;;  completion-candidates set using a variable that you name, not a</span>
<span class="linecomment">;;  cache file.  See (@&gt; "Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Saving Candidates in Cache Files")</span>
<span class="linecomment">;;  ** Saving Candidates in Cache Files **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you have used the Emacs file-name cache (see the Emacs manual,</span>
<span class="linecomment">;;  node "File Name Cache"), then you have already used a cache file</span>
<span class="linecomment">;;  of (file-name) completion candidates.  In vanilla Emacs, you use</span>
<span class="linecomment">;;  `C-TAB' during file-name input to complete to a cached file name.</span>
<span class="linecomment">;;  In Icicles, you use `C-{'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, the cached candidates are not limited to file names,</span>
<span class="linecomment">;;  and you can have any number of cache files, to save different sets</span>
<span class="linecomment">;;  of completion candidates.  Each cache file saves the set of</span>
<span class="linecomment">;;  candidates that was current when you created (saved) the set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The fact that a cache file can contain just those candidates that</span>
<span class="linecomment">;;  were current when you saved it is a considerable advantage, when</span>
<span class="linecomment">;;  combined with Icicles features for sculpting the current set of</span>
<span class="linecomment">;;  matching candidates.  As far as I know, Icicles is the only</span>
<span class="linecomment">;;  package to offer this feature.  You spend a few moments to</span>
<span class="linecomment">;;  fine-tune a set of candidates, using, for example, `M-*', `C-~',</span>
<span class="linecomment">;;  and `delete', and then save it for later use.  From then on, you</span>
<span class="linecomment">;;  can match against exactly those candidates anytime you want.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, you might have a software project that involves only</span>
<span class="linecomment">;;  certain directories and perhaps only certain kinds of files in</span>
<span class="linecomment">;;  those directories are of interest as completion candidates.  Those</span>
<span class="linecomment">;;  directories and files can even be in disparate locations.  Start</span>
<span class="linecomment">;;  with command `icicle-locate-file'.  Then use progressive</span>
<span class="linecomment">;;  completion to match the directories and files you want and chip</span>
<span class="linecomment">;;  away at those you don't want.  Once you get just the set you need</span>
<span class="linecomment">;;  for your project, save that set using `C-}'.  You can have any</span>
<span class="linecomment">;;  number of saved sets, for different projects or different purposes</span>
<span class="linecomment">;;  in the same project.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You name the sets of saved candidates, and these names are</span>
<span class="linecomment">;;  associated with the cache files in user option</span>
<span class="linecomment">;;  `icicle-saved-completion-sets'.  This is an alist of entries, each</span>
<span class="linecomment">;;  of which is of the form (SET-NAME . CACHE-FILE-NAME).  You can</span>
<span class="linecomment">;;  customize this option, or set it in your init file (~/.emacs).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use command `icicle-add/update-saved-completion-set' to</span>
<span class="linecomment">;;  add a new set to `icicle-saved-completion-sets' or update</span>
<span class="linecomment">;;  (replace) an existing such set.  You can use command</span>
<span class="linecomment">;;  `icicle-remove-saved-completion-set' to remove a saved set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an alternative to customizing `icicle-saved-completion-sets' or</span>
<span class="linecomment">;;  using command `icicle-add/update-saved-completion-set', you can</span>
<span class="linecomment">;;  simply try to save a set of completion candidates persistently,</span>
<span class="linecomment">;;  using `C-u C-M-&gt;' or `C-}'.  You are then prompted for the names</span>
<span class="linecomment">;;  of the candidate set and cache file to use, and the names you</span>
<span class="linecomment">;;  enter are automatically entered in option</span>
<span class="linecomment">;;  `icicle-saved-completion-sets'.  That option is automatically</span>
<span class="linecomment">;;  saved to your custom file, so the next time you use Emacs you can</span>
<span class="linecomment">;;  retrieve any saved set of candidates that you like.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you try to retrieve a persistent set of completion</span>
<span class="linecomment">;;  candidates, you are similarly prompted for the candidate-set name</span>
<span class="linecomment">;;  and the cache-file name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to saving the current set of completion candidates to</span>
<span class="linecomment">;;  a cache file, you can add individual strings as future completion</span>
<span class="linecomment">;;  candidates to any cache file, and you can remove candidates from a</span>
<span class="linecomment">;;  cache file individually.  You do this using commands</span>
<span class="linecomment">;;  `icicle-add-entry-to-saved-completion-set' and</span>
<span class="linecomment">;;  `icicle-remove-entry-from-saved-completion-set'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Adding an individual candidate is similar to using the Emacs</span>
<span class="linecomment">;;  file-name cache commands that add file names to the cache, but it</span>
<span class="linecomment">;;  adds only a single candidate.  For file names, adding a directory</span>
<span class="linecomment">;;  name effectively provides completion for all of its files as well,</span>
<span class="linecomment">;;  so there is no need to add each file name as well as the directory</span>
<span class="linecomment">;;  name.  Alternatively, you can always use `C-}' to add all file</span>
<span class="linecomment">;;  names that match your current input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Filesets and Icicles Saved Completion Sets")</span>
<span class="linecomment">;;  ** Filesets and Icicles Saved Completion Sets **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Starting with release 22, GNU Emacs includes a filesets feature</span>
<span class="linecomment">;;  that lets you create named sets of file names, called "filesets".</span>
<span class="linecomment">;;  It is a powerful feature, letting you define such sets by</span>
<span class="linecomment">;;  intension, using regexp patterns, as well as by extension, listing</span>
<span class="linecomment">;;  file names explicitly.  You can easily use a fileset to define a</span>
<span class="linecomment">;;  project of files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles lets you use an Emacs fileset any time you can use an</span>
<span class="linecomment">;;  Icicles saved completion set, provided that option</span>
<span class="linecomment">;;  `icicle-filesets-as-saved-completion-sets-flag' is non-nil.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That is, you can retrieve fileset file names as the current set of</span>
<span class="linecomment">;;  completion candidates or save the current completion candidates to</span>
<span class="linecomment">;;  a fileset.  Provided</span>
<span class="linecomment">;;  `icicle-filesets-as-saved-completion-sets-flag' is non-nil, you</span>
<span class="linecomment">;;  can always choose a fileset as the set to retrieve.  To save to a</span>
<span class="linecomment">;;  fileset, use a prefix arg with `C-}' or a zero prefix arg with</span>
<span class="linecomment">;;  `C-M-&gt;'.  Saving candidates to a fileset gives you an alternative</span>
<span class="linecomment">;;  to customizing option `filesets-data'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Being able to use an Emacs fileset in place of an Icicles saved</span>
<span class="linecomment">;;  set lets you use filesets in additional ways.  For example, it</span>
<span class="linecomment">;;  lets you open Dired on only the files in a fileset, for easy</span>
<span class="linecomment">;;  manipulation of the member files.  Conversely, you can save all of</span>
<span class="linecomment">;;  the marked files in a Dired buffer as a fileset. See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Dired Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Beyond letting you use a fileset in place of a persistent Icicles</span>
<span class="linecomment">;;  saved completion set, you can include filesets in such saved</span>
<span class="linecomment">;;  Icicles sets.  That is, you can save one or more filesets of any</span>
<span class="linecomment">;;  kind (`:files', `:tree', etc.) in an Icicles persistent saved set</span>
<span class="linecomment">;;  (cache file).  When you then retrieve such a saved set, all of the</span>
<span class="linecomment">;;  file names specified by all of the included filesets become</span>
<span class="linecomment">;;  completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, this could be a saved Icicles set that combines a</span>
<span class="linecomment">;;  `:tree' fileset with an explicit `:files' fileset and with two</span>
<span class="linecomment">;;  additional files:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  ((:fileset "set1" (:tree "~/my/dir" "^ici.+\\.el$"))</span>
<span class="linecomment">;;   (:fileset "set2" (:files "dired+.el" "c:/my/dir/buff-menu+.el"))</span>
<span class="linecomment">;;   "c:/some/other/dir/foobar.el"</span>
<span class="linecomment">;;   "c:/somewhere/else/toto.el")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is a great way to put together a project of files from</span>
<span class="linecomment">;;  different directory trees.  And even aside from the use of such a</span>
<span class="linecomment">;;  saved set for completion, this combining of filesets is something</span>
<span class="linecomment">;;  that you cannot do with Emacs filesets alone, as far as I know -</span>
<span class="linecomment">;;  you cannot combine different filesets into super filesets, and a</span>
<span class="linecomment">;;  given fileset can specify files in only one way (`:files',</span>
<span class="linecomment">;;  `:tree', etc.).  Icicles gives you a way to associate related</span>
<span class="linecomment">;;  filesets and use them together as a single set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use commands</span>
<span class="linecomment">;;  `icicle-remove-entry-from-saved-completion-set' and</span>
<span class="linecomment">;;  `icicle-add-entry-to-saved-completion-set' to remove a fileset</span>
<span class="linecomment">;;  from an Icicles saved set or add a fileset to a saved set.  To</span>
<span class="linecomment">;;  add, use a prefix arg to tell</span>
<span class="linecomment">;;  `icicle-add-entry-to-saved-completion-set' that you are adding a</span>
<span class="linecomment">;;  fileset and not a single completion candidate.  To add a single</span>
<span class="linecomment">;;  file (default: the current buffer's file) to a fileset, use</span>
<span class="linecomment">;;  command `icicle-add-file-to-fileset'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Use the right type of saved candidates (persistent or not)</span>
<span class="linecomment">;;  for a given command.  It is the particular command that determines</span>
<span class="linecomment">;;  whether or not a given type of saved candidate is appropriate.</span>
<span class="linecomment">;;  For example, you can save search hits when you use</span>
<span class="linecomment">;;  `icicle-search-file' (same as `icicle-search' with a negative</span>
<span class="linecomment">;;  prefix arg), and those saved search-hit candidates effectively</span>
<span class="linecomment">;;  reference files and positions in those files.  And you can later</span>
<span class="linecomment">;;  retrieve and reuse such saved candidates to visit the search</span>
<span class="linecomment">;;  positions.  But those candidates are not merely file names, so</span>
<span class="linecomment">;;  they cannot be used with a command such as `find-file' or</span>
<span class="linecomment">;;  `icicle-file' that expects a file name.  Conversely, you cannot</span>
<span class="linecomment">;;  use a saved set of file names with a command such as</span>
<span class="linecomment">;;  `icicle-search-file' that expects `icicle-search' candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Improving Performance with Persistent Sets")</span>
<span class="linecomment">;;  ** Improving Performance with Persistent Sets **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are two independent reasons that using a persistent set of</span>
<span class="linecomment">;;  file names can improve performance:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Avoiding remote file-name completion.  You can complete your</span>
<span class="linecomment">;;    input against remote file names without using Tramp and thus</span>
<span class="linecomment">;;    without accessing the remote file system.  (Once you have chosen</span>
<span class="linecomment">;;    the file you want, visiting it of course makes a remote access.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Avoiding generation of a large completion set.  Retrieving a</span>
<span class="linecomment">;;    list of file names is much, much faster than generating such a</span>
<span class="linecomment">;;    list.  So generate once and retrieve often, from a cache.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These are covered in the next two sections.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Avoid Remote File-Name Completion")</span>
<span class="linecomment">;;  *** Avoid Remote File-Name Completion ***</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you complete the name of a remote file, Tramp accesses the</span>
<span class="linecomment">;;  remote file system to see which matching files exist.  This takes</span>
<span class="linecomment">;;  time.  The completion itself is complicated - it involves parsing</span>
<span class="linecomment">;;  the remote file name and calling upon various file handlers.  But</span>
<span class="linecomment">;;  the greatest time spent is in accessing the remote machine.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you retrieve a (persistently) saved set of file names during</span>
<span class="linecomment">;;  completion, you are telling Emacs that these are the candidates</span>
<span class="linecomment">;;  you want to complete against.  You are not asking Emacs (Tramp) to</span>
<span class="linecomment">;;  tell you what the possible candidates are; you are telling it.</span>
<span class="linecomment">;;  (Obviously you will want to save the completions in a file on the</span>
<span class="linecomment">;;  local machine, so retrieval itself takes no time.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  After retrieving the saved candidates as the only possible ones,</span>
<span class="linecomment">;;  you might type some input and complete it (`TAB' or `S-TAB') to</span>
<span class="linecomment">;;  narrow your choices.  Or you might not bother with completion but</span>
<span class="linecomment">;;  instead pick one of the candidates using `mouse-2' or by cycling</span>
<span class="linecomment">;;  to it and using `RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use either relative or absolute file-name completion with</span>
<span class="linecomment">;;  remote file names.  Relative name completion as provided by</span>
<span class="linecomment">;;  `read-file-name' (via `C-x C-f', for example) always involves</span>
<span class="linecomment">;;  Tramp (or ange-ftp, prior to Emacs 22).  When using relative name</span>
<span class="linecomment">;;  completion, you can save time in these ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Turn off incremental completion (using `C-#'), so that Tramp is</span>
<span class="linecomment">;;    used only when you hit `TAB' or `S-TAB', not with each character</span>
<span class="linecomment">;;    you type or delete!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Use `mouse-2', or cycle and use `RET', so that you avoid</span>
<span class="linecomment">;;    completion altogether.  Tramp is then used only to access the</span>
<span class="linecomment">;;    chosen file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use absolute file-name completion as provided by</span>
<span class="linecomment">;;  `completing-read' (via `C-u C-x C-f', for example), then you need</span>
<span class="linecomment">;;  not worry about turning off incremental completion or avoiding</span>
<span class="linecomment">;;  completion by cycling or using `mouse-2'.  This is because</span>
<span class="linecomment">;;  completion is entirely local - `completing-read' has no notion of</span>
<span class="linecomment">;;  files, let alone remote files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, if you use absolute file-name completion then you</span>
<span class="linecomment">;;  need not bother to type the (long) remote file-name prefix to get</span>
<span class="linecomment">;;  into the right directory for completion.  Again, `completing-read'</span>
<span class="linecomment">;;  has no notion of files or directories - it just completes an input</span>
<span class="linecomment">;;  pattern against string candidates.  Just type a substring or other</span>
<span class="linecomment">;;  regexp and then hit `S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In general, using absolute file names (`C-u C-x C-f') is the way</span>
<span class="linecomment">;;  to go when dealing with remote files.  There is no need to forego</span>
<span class="linecomment">;;  the advantages of Icicles completion.  On the other hand, if you</span>
<span class="linecomment">;;  are going to work in a directory on a remote machine for some time</span>
<span class="linecomment">;;  using files other than those in some saved completion set, then</span>
<span class="linecomment">;;  you might want to use relative file names (`C-x C-f').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Avoid Generating A Large Completion Set")</span>
<span class="linecomment">;;  *** Avoid Generating A Large Completion Set ***</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Section (@&gt; "File-Name Input and Locating Files Anywhere") tells</span>
<span class="linecomment">;;  you how you can locate any file in your file system.  If you save</span>
<span class="linecomment">;;  the set of all file names persistently, you will increase the</span>
<span class="linecomment">;;  performance of using it - it is much faster to retrieve the list</span>
<span class="linecomment">;;  of all file names than it is to generate it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  With 36 GB of files in my file system, my all-file-system cache</span>
<span class="linecomment">;;  file is 20 MB, and retrieving the file-name completions from it</span>
<span class="linecomment">;;  takes only a few seconds.  With this feature, Icicles essentially</span>
<span class="linecomment">;;  gives you the functionality of the Unix `locate' command, but with</span>
<span class="linecomment">;;  the addition of real-time regexp matching.  Here is all you do:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-locate-file RET</span>
<span class="linecomment">;;    C-#        ; Once or twice: turn off incremental completion.</span>
<span class="linecomment">;;    C-{        ; Retrieve all file names from your cache file.</span>
<span class="linecomment">;;               ; You are prompted for the set name and file name.</span>
<span class="linecomment">;;    foo.*bar   ; Regexp to match names with `foo' followed by `bar'.</span>
<span class="linecomment">;;    S-TAB      ; Update `*Completions*' display (because of `C-#').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Of course, once you have retrieved a set of candidates from your</span>
<span class="linecomment">;;  cache file, you can access them again without re-reading the file.</span>
<span class="linecomment">;;  When they are retrieved from your cache they are saved in variable</span>
<span class="linecomment">;;  `icicle-saved-completion-candidates', so the next time you want to</span>
<span class="linecomment">;;  use them, just retrieve them from this variable with `C-M-&lt;'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "File-Name Input and Locating Files Anywhere") for</span>
<span class="linecomment">;;    information about relative vs absolute file names and about</span>
<span class="linecomment">;;    finding files located anywhere in your file system</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icompletion") for information about `C-#' (toggle</span>
<span class="linecomment">;;    incremental completion)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Sets of Completion Candidates") for information about</span>
<span class="linecomment">;;    `C-M-&gt;' (save current candidates)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Dealing With Large Candidate Sets")</span>
 
<span class="linecomment">;;(@* "Dealing With Large Candidate Sets")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Dealing With Large Candidate Sets</span>
<span class="linecomment">;;  ---------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One of the advantages Icicles provides is the ability to deal with</span>
<span class="linecomment">;;  large sets of completion candidates with ease.  There are other</span>
<span class="linecomment">;;  libraries that also let you cycle among various choices of</span>
<span class="linecomment">;;  different kinds (buffers, files, and so on), but cycling quickly</span>
<span class="linecomment">;;  loses its effectiveness as the number of candidates increases.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles apropos matching lets you work with a large initial set of</span>
<span class="linecomment">;;  candidates by filtering them, quickly reducing the number</span>
<span class="linecomment">;;  candidates to cycle through.  Filtering by a prefix only (vanilla</span>
<span class="linecomment">;;  Emacs) is not very potent.  Until you get used to Icicles, you</span>
<span class="linecomment">;;  will be surprised at your ability to manipulate even humongous</span>
<span class="linecomment">;;  sets of choices.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Nevertheless, there can be times when a candidate set is so large</span>
<span class="linecomment">;;  that you need to use a few tricks to deal with it efficiently.</span>
<span class="linecomment">;;  There are two main things that take time when dealing with a large</span>
<span class="linecomment">;;  set: computing the set and displaying it (with highlighting) in</span>
<span class="linecomment">;;  buffer `*Completions*'.  In particular, incremental completion</span>
<span class="linecomment">;;  display is costly because it does both of these, recompute the set</span>
<span class="linecomment">;;  and redisplay it, each time you type or delete a character in the</span>
<span class="linecomment">;;  minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here are some tips to improve performance with a large set of</span>
<span class="linecomment">;;  candidates:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Turn off incremental completion display in buffer</span>
<span class="linecomment">;;    `*Completions*'.  You can do this on the fly at any time by</span>
<span class="linecomment">;;    using `C-#' in the minibuffer - use `C-#' again to turn it back</span>
<span class="linecomment">;;    on.  See (@&gt; "Icompletion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Compute a large candidate set only once, cache the result, and</span>
<span class="linecomment">;;    reuse it later by reading the cache instead of recomputing.</span>
<span class="linecomment">;;    This is useful, for instance, for the candidate set of all files</span>
<span class="linecomment">;;    on your file system.  You can cache a set of candidates in</span>
<span class="linecomment">;;    either a variable (quickest, but not persistent) or a disk file</span>
<span class="linecomment">;;    (slower, persistent).</span>
<span class="linecomment">;;    See (@&gt; "Persistent Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Compute a large candidate set (and perhaps cache it or filter</span>
<span class="linecomment">;;    it) without displaying it in `*Completions*', by using `C-M-TAB'</span>
<span class="linecomment">;;    or `C-M-S-TAB' instead of `TAB' or `S-TAB', respectively.  These</span>
<span class="linecomment">;;    are bound to commands `icicle-prefix-complete-no-display' and</span>
<span class="linecomment">;;    `icicle-apropos-complete-no-display'.  For example, when</span>
<span class="linecomment">;;    initially computing the set of all files on your file system for</span>
<span class="linecomment">;;    `C-u M-x icicle-locate-file', use `C-M-S-TAB' to compute the</span>
<span class="linecomment">;;    set, then use `C-}' to save it to a cache file - you need never</span>
<span class="linecomment">;;    display it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (The documentation refers to the keys that do this as</span>
<span class="linecomment">;;    `C-M-S-TAB' and `C-M-TAB'.  Actually, this is only by default.</span>
<span class="linecomment">;;    You can customize this, using options</span>
<span class="linecomment">;;    `icicle-apropos-complete-no-display-keys' and</span>
<span class="linecomment">;;    `icicle-prefix-complete-no-display-keys'.)</span>
 
<span class="linecomment">;;(@* "History Enhancements")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  History Enhancements</span>
<span class="linecomment">;;  --------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is about accessing and reusing previous input that</span>
<span class="linecomment">;;  you have typed in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "What Input, What History?")</span>
<span class="linecomment">;;  ** What Input, What History? **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  First, what is meant by "input" and "input history"?  In vanilla</span>
<span class="linecomment">;;  Emacs and in this doc, "minibuffer history" and "input history"</span>
<span class="linecomment">;;  generally refer to input that you have typed (or cycled or</span>
<span class="linecomment">;;  completed) in the minibuffer and then entered using `RET' (or</span>
<span class="linecomment">;;  `S-RET').  Emacs provides different history lists for this,</span>
<span class="linecomment">;;  depending on the kind of input.  The most general such list is the</span>
<span class="linecomment">;;  value of variable `minibuffer-history'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But what about input that you type in the minibuffer (e.g. during</span>
<span class="linecomment">;;  completion) but you do not enter with `RET'?  That is not recorded</span>
<span class="linecomment">;;  in any standard history list, so you cannot recall it using `M-p'</span>
<span class="linecomment">;;  and `M-n'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The Icicles doc speaks ambiguously of "minibuffer input".  This</span>
<span class="linecomment">;;  always refers to something that you type in the minibuffer, but</span>
<span class="linecomment">;;  sometimes it means input that you enter with `RET' and sometimes</span>
<span class="linecomment">;;  it does not.  The context and the use of phrases such as "entered"</span>
<span class="linecomment">;;  and "entered with `RET'" should make clear what is meant.  Input</span>
<span class="linecomment">;;  that you type during completion but that you do not necessarily</span>
<span class="linecomment">;;  enter is sometimes referred to in the Icicles doc as "completion</span>
<span class="linecomment">;;  input".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because completion is so important to Icicles, because cycling</span>
<span class="linecomment">;;  replaces the input you type in the minibuffer, and because you</span>
<span class="linecomment">;;  sometimes need to retrieve such typed input that was never</span>
<span class="linecomment">;;  entered, Icicles also records this input.  You can retrieve it</span>
<span class="linecomment">;;  during completion using `C-l' (`icicle-retrieve-previous-input')</span>
<span class="linecomment">;;  and `C-S-l', that is, `C-L', (`icicle-retrieve-next-input').  Use</span>
<span class="linecomment">;;  these commands to cycle among your past completion inputs</span>
<span class="linecomment">;;  (backward and forward, respectively).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  User option `icicle-completion-history-max-length' limits the</span>
<span class="linecomment">;;  number of completion inputs to save.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you customize user option `icicle-C-l-uses-completion-flag' to</span>
<span class="linecomment">;;  non-nil, then, instead of cycling, `C-l' lets you use Icicles</span>
<span class="linecomment">;;  completion to retrieve a past completion input (`C-L' does the</span>
<span class="linecomment">;;  same thing).  Using completion to retrieve a past input does not</span>
<span class="linecomment">;;  also choose that input as the candidate for the main completion;</span>
<span class="linecomment">;;  it just replaces your current minibuffer input with it.  Because</span>
<span class="linecomment">;;  `C-l' completion uses a recursive minibuffer, you can also use</span>
<span class="linecomment">;;  `C-g' to cancel this completion and return to the main completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can temporarily reverse the effect of</span>
<span class="linecomment">;;  `icicle-C-l-uses-completion-flag' by using a prefix argument</span>
<span class="linecomment">;;  (`C-u') with `C-l'.  Thus, `C-u C-l' uses completion if</span>
<span class="linecomment">;;  `icicle-C-l-uses-completion-flag' is nil and cycles if it is</span>
<span class="linecomment">;;  non-nil.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The other sections here describe Icicles enhancements for</span>
<span class="linecomment">;;  minibuffer histories.  They are thus concerned only with inputs</span>
<span class="linecomment">;;  that you enter, not with completion inputs that are not entered.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Overview of Minibuffer History Enhancements")</span>
<span class="linecomment">;;  ** Overview of Minibuffer History Enhancements **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles enhances the minibuffer history in these independent ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Command `icicle-insert-history-element' (bound to `M-o' in the</span>
<span class="linecomment">;;     minibuffer) lets you use (lax) completion to insert a history</span>
<span class="linecomment">;;     element in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Candidates displayed in `*Completions*' are highlighted using</span>
<span class="linecomment">;;     face `icicle-historical-candidate' (blue foreground, by</span>
<span class="linecomment">;;     default), when they have been used previously, so you can more</span>
<span class="linecomment">;;     easily recognize them.  This highlighting is controlled by</span>
<span class="linecomment">;;     option `icicle-highlight-historical-candidates-flag'.  You can</span>
<span class="linecomment">;;     toggle this from the minibuffer at any time using `C-pause'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Command `icicle-toggle-alternative-sorting', (`C-M-,' in the</span>
<span class="linecomment">;;     minibuffer) re-sorts completion candidates, placing previously</span>
<span class="linecomment">;;     used candidates first.  This is a toggle: repeat it to return</span>
<span class="linecomment">;;     to the original order.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. Command `icicle-keep-only-past-inputs' (`M-pause' in the</span>
<span class="linecomment">;;     minibuffer) restricts the current set of completion candidates</span>
<span class="linecomment">;;     to those that you have used previously.  In other words, it</span>
<span class="linecomment">;;     keeps only those candidates that are highlighted in blue.  To</span>
<span class="linecomment">;;     use `M-pause', you must first have used `TAB' or `S-TAB' to</span>
<span class="linecomment">;;     establish an explicit candidate set.  If you use `C-u M-pause',</span>
<span class="linecomment">;;     then the previously used candidates are ordered</span>
<span class="linecomment">;;     chronologically, most recent first.  Without `C-u', the normal</span>
<span class="linecomment">;;     sort order is used (`icicle-sort-function').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  5. Command `icicle-history' (`M-h' in the minibuffer) matches the</span>
<span class="linecomment">;;     current input against the minibuffer history directly.  It can</span>
<span class="linecomment">;;     be used during completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  6. Commands `icicle-clear-history' and</span>
<span class="linecomment">;;     `icicle-clear-current-history' (`M-i' in the minibuffer)</span>
<span class="linecomment">;;     provide a general way to clean up histories.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  7. When you cycle among previously entered inputs using `M-p' and</span>
<span class="linecomment">;;     `M-n', you can use `M-k' (command</span>
<span class="linecomment">;;     `icicle-erase-minibuffer-or-history-element') to delete the</span>
<span class="linecomment">;;     current occurrence from the history list.  This is a quick and</span>
<span class="linecomment">;;     handy way to clean up list entries that you are no longer</span>
<span class="linecomment">;;     interested in.  Only the occurrence that you have cycled to is</span>
<span class="linecomment">;;     deleted; if there are identical entries elsewhere in the</span>
<span class="linecomment">;;     history, they remain.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Enhancements 1-6 are described below in more detail.  Each of 1-5</span>
<span class="linecomment">;;  lets you see the complete list of previous inputs that match your</span>
<span class="linecomment">;;  current input.  In vanilla Emacs, the history lists are never</span>
<span class="linecomment">;;  shown as such; you can access previous inputs only one at a time,</span>
<span class="linecomment">;;  in order (with `M-p').  In vanilla Emacs, you can use a regexp to</span>
<span class="linecomment">;;  search the history list (via `M-r'), but the regexp matching is</span>
<span class="linecomment">;;  not dynamic, and the first match found is the (only) one you get.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Displaying previous inputs that match the current input sounds</span>
<span class="linecomment">;;  like a minor advantage, but it is actually quite helpful in</span>
<span class="linecomment">;;  practice.  Among other things, it means that you can work with</span>
<span class="linecomment">;;  long history lists in a practical way.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using Completion to Insert Previous Inputs: `M-o'")</span>
<span class="linecomment">;;  ** Using Completion to Insert Previous Inputs: `M-o' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Unlike the other minibuffer history enhancements, described below,</span>
<span class="linecomment">;;  which are available only during minibuffer completion, you can use</span>
<span class="linecomment">;;  `M-o' (`icicle-insert-history-element') anytime you are asked for</span>
<span class="linecomment">;;  minibuffer input.  It provides a recursive minibuffer in which you</span>
<span class="linecomment">;;  can match a previous input using completion.  After you hit `RET'</span>
<span class="linecomment">;;  to accept your choice, it is inserted in the minibuffer just as if</span>
<span class="linecomment">;;  you had typed it.  This has the advantage over cycling with `M-n'</span>
<span class="linecomment">;;  or `M-p' and searching with `M-s' or `M-r', that you can use</span>
<span class="linecomment">;;  Icicles completion and cycling to quickly access a previous input,</span>
<span class="linecomment">;;  no matter how long ago you entered it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When completion is available for reading input, if you use `M-o'</span>
<span class="linecomment">;;  to choose a previously entered input, this just inserts that input</span>
<span class="linecomment">;;  in the minibuffer.  What is in the minibuffer after you use `M-o'</span>
<span class="linecomment">;;  is not automatically chosen for the main completion - you can edit</span>
<span class="linecomment">;;  the minibuffer contents before entering it with `RET'.  You can</span>
<span class="linecomment">;;  also use `C-g' during the `M-o' completion to cancel it and return</span>
<span class="linecomment">;;  to the main completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Putting Previous Candidates First: `C-M-,'")</span>
<span class="linecomment">;;  ** Putting Previous Candidates First: `C-M-,' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  At any time, two of the Icicles sort orders are immediately</span>
<span class="linecomment">;;  available.  These are the values of user options</span>
<span class="linecomment">;;  `icicle-sort-function' and `icicle-alternative-sort-function'.  By</span>
<span class="linecomment">;;  default, the former sorts alphabetically, and the latter puts all</span>
<span class="linecomment">;;  previously used inputs first, before the candidates you have not</span>
<span class="linecomment">;;  yet used.  Each of these groups, used and unused candidates, is</span>
<span class="linecomment">;;  then sorted alphabetically, separately.  So, with the default</span>
<span class="linecomment">;;  alternative sort, you can see all matching candidates (used and</span>
<span class="linecomment">;;  unused), but you privilege those used previously - they are the</span>
<span class="linecomment">;;  first listed in `*Completions*' and the first available for</span>
<span class="linecomment">;;  cycling.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you prefer, by customizing these user options, you can use</span>
<span class="linecomment">;;  `icicle-historical-alphabetic-p' as the main sort function (option</span>
<span class="linecomment">;;  `icicle-sort-function') and some other sort function</span>
<span class="linecomment">;;  (e.g. `icicle-case-string-less-p') as the alternative sort</span>
<span class="linecomment">;;  function.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can toggle at any time between normal sorting and alternative</span>
<span class="linecomment">;;  sorting, using command `icicle-toggle-alternative-sorting'.</span>
<span class="linecomment">;;  During completion, this is bound to `C-M-,'.  Together with</span>
<span class="linecomment">;;  toggling between normal sorting and not sorting at all, which is a</span>
<span class="linecomment">;;  sort-order choice available through `C-,', this gives you quite a</span>
<span class="linecomment">;;  lot of flexibility.  Some commands, such as `icicle-complete-keys'</span>
<span class="linecomment">;;  (bound to `S-TAB' except during completion), use different sort</span>
<span class="linecomment">;;  orders.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Matching Only Historical Candidates: `M-h' and `M-pause'")</span>
<span class="linecomment">;;  ** Matching Only Historical Candidates: `M-h' and `M-pause' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Both `M-h' and `M-pause' can be used toward the same end.  They</span>
<span class="linecomment">;;  both work for all input types.  They both use the appropriate</span>
<span class="linecomment">;;  history list for the current command.  They both provide apropos</span>
<span class="linecomment">;;  completion and cycling for the minibuffer history (as well as</span>
<span class="linecomment">;;  prefix completion, of course).  Use them as another way to search</span>
<span class="linecomment">;;  through a history list or complete to one of its elements.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, If you use `C-x C-f' to find a file, and then use</span>
<span class="linecomment">;;  `M-h' or `M-pause', the completion candidates will be the names of</span>
<span class="linecomment">;;  files that you have previously accessed (file names you have input</span>
<span class="linecomment">;;  in the minibuffer), and which match the current minibuffer input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `M-h' lets you complete your input against the minibuffer input</span>
<span class="linecomment">;;  history.  `M-pause' lets you restrict the current explicit set of</span>
<span class="linecomment">;;  completion candidates to those that are also in the minibuffer</span>
<span class="linecomment">;;  history.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  They provide similar functionality in different ways.  The</span>
<span class="linecomment">;;  difference is that `M-pause' takes the current set of matching</span>
<span class="linecomment">;;  candidates into account.  It is a completion-candidates set</span>
<span class="linecomment">;;  operation, similar to those described in section</span>
<span class="linecomment">;;  (@&gt; "Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This means, in particular, that with `M-pause' you can first</span>
<span class="linecomment">;;  perform set operations on the set of candidates, and then use that</span>
<span class="linecomment">;;  result to restrict the history search.  For example, you can first</span>
<span class="linecomment">;;  complement the candidate set using `C-~', then use `M-pause' to</span>
<span class="linecomment">;;  restrict those candidates to matches in the history list.  In this</span>
<span class="linecomment">;;  way, you avoid including matches from the original match set when</span>
<span class="linecomment">;;  searching the history.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Example: You are in a directory with lots of files that have the</span>
<span class="linecomment">;;  prefix `foo' and lots of C-language source files.  You happen to</span>
<span class="linecomment">;;  be interested in another file, however.  One way to get to that</span>
<span class="linecomment">;;  file is to use Dired's ability to mark files by matching a regexp</span>
<span class="linecomment">;;  and then use Dired's ability to omit the marked files from view.</span>
<span class="linecomment">;;  You can scan through those that remain, and pick the one you want.</span>
<span class="linecomment">;;  However, it turns out that even then there are many files to scan.</span>
<span class="linecomment">;;  You accessed the one you want now just the other day, but the file</span>
<span class="linecomment">;;  date is unfortunately not significant.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, you use regexp matching and take the set complement of</span>
<span class="linecomment">;;  the hits, just like in Dired: `C-x C-f foo.*\.c$' defines the</span>
<span class="linecomment">;;  candidate set as all files whose names start with `foo' and have</span>
<span class="linecomment">;;  extension `c'.  `C-~' then defines the candidate set as all files</span>
<span class="linecomment">;;  whose names are not like that.  Finally, you use `M-pause' to</span>
<span class="linecomment">;;  restrict the file-name candidates to names that you have used</span>
<span class="linecomment">;;  before.  You've accessed many, many files recently, so just</span>
<span class="linecomment">;;  cycling through the history with `M-p' would be tedious.  You</span>
<span class="linecomment">;;  could match a regexp against the file history, but how can you</span>
<span class="linecomment">;;  come up with a regexp that finds anti-matches?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A consequence of this difference between `M-h' and `M-pause' is</span>
<span class="linecomment">;;  that using `TAB' or `S-TAB' after `M-pause' abandons use of the</span>
<span class="linecomment">;;  minibuffer history and starts a new set of completion candidates.</span>
<span class="linecomment">;;  It simply completes the current input in the context of the</span>
<span class="linecomment">;;  current command; `TAB' and `S-TAB' have nothing to do with the</span>
<span class="linecomment">;;  minibuffer history in this case.  Using `TAB' or `S-TAB' after</span>
<span class="linecomment">;;  `M-h', however, re-completes your input against the current</span>
<span class="linecomment">;;  history list.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another consequence is that you can use `down' or `C-down' on the</span>
<span class="linecomment">;;  candidates displayed by `M-h', but not on those displayed by</span>
<span class="linecomment">;;  `M-pause'.  For example, to cycle through the doc for each</span>
<span class="linecomment">;;  variable that starts with `icicle-' which you have previously</span>
<span class="linecomment">;;  input, you can use `C-h v icicle- M-h', then repeatedly use</span>
<span class="linecomment">;;  `C-down'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Also, file-name and directory-name completion works differently in</span>
<span class="linecomment">;;  these two commands.  By default, the current directory is (as</span>
<span class="linecomment">;;  always) inserted into the minibuffer by commands such as</span>
<span class="linecomment">;;  `find-file', so either `M-h' or `M-pause' after `C-x C-f' will</span>
<span class="linecomment">;;  match previously input file names from the current directory.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, in the case of `M-h', the entire minibuffer input is</span>
<span class="linecomment">;;  matched against the history list, which is a list of absolute file</span>
<span class="linecomment">;;  names.  `M-pause' works only with the current candidate set,</span>
<span class="linecomment">;;  which, if you have already used `TAB' or `S-TAB' in the current</span>
<span class="linecomment">;;  directory, is a set of relative file names in that directory.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This difference has a consequence for apropos (regexp) completion</span>
<span class="linecomment">;;  with `M-h'.  It means that to match a file name using a substring</span>
<span class="linecomment">;;  you must, in the minibuffer, either not specify a directory (erase</span>
<span class="linecomment">;;  it) or explicitly use `.*' before the file-name substring.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, with `M-h', `/foo/bar/lph' will not apropos-match the</span>
<span class="linecomment">;;  previously input file name `/foo/bar/alphabet-soup.el'; you should</span>
<span class="linecomment">;;  use either `/foo/bar/.*lph' or `lph' (no directory).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In the case of `M-pause', however, the input is matched against</span>
<span class="linecomment">;;  the history list as restricted by the existing completion list.</span>
<span class="linecomment">;;  And, since apropos file-name completion uses only the relative</span>
<span class="linecomment">;;  file name, without the directory name, as a regexp, the candidate</span>
<span class="linecomment">;;  list that is restricted has already matched the input regexp.  The</span>
<span class="linecomment">;;  action of `M-pause' is simply to filter the list of candidates,</span>
<span class="linecomment">;;  keeping those that are in the history list.  This means that, with</span>
<span class="linecomment">;;  `M-pause', the input `/foo/bar/lph' will match against the</span>
<span class="linecomment">;;  previously input file name `/foo/bar/alphabet-soup.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If this all sounds confusing, just give it a try; it is much</span>
<span class="linecomment">;;  harder to describe than it is to experience.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Cleaning Up History Lists")</span>
<span class="linecomment">;;  ** Cleaning Up History Lists **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Besides the use of `M-k' during history cycling (`M-p', `M-n') to</span>
<span class="linecomment">;;  remove individual input occurrences from the current history list,</span>
<span class="linecomment">;;  you can use commands `icicle-clear-history' and</span>
<span class="linecomment">;;  `icicle-clear-current-history' to clean minibuffer histories</span>
<span class="linecomment">;;  entirely of selected entries.  Command</span>
<span class="linecomment">;;  `icicle-clear-current-history' is bound to `M-i' in the</span>
<span class="linecomment">;;  minibuffer.  It is `icicle-clear-history' specialized to work on</span>
<span class="linecomment">;;  just the current history list.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These commands prompt you for a history entry to delete from a</span>
<span class="linecomment">;;  history list.  These are multi-commands, so you can delete</span>
<span class="linecomment">;;  multiple entries.  For each entry you choose, all of its</span>
<span class="linecomment">;;  occurrences are deleted from the history.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-clear-history' first prompts you for a history</span>
<span class="linecomment">;;  list to act on.  This too is multi-command input, so you can use</span>
<span class="linecomment">;;  `icicle-clear-history' to remove entries from multiple histories.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use a prefix argument with these commands, then the</span>
<span class="linecomment">;;  histories are emptied entirely (upon confirmation).  Thus, for</span>
<span class="linecomment">;;  instance, you can use `C-u M-i' at any time during minibuffer</span>
<span class="linecomment">;;  input to completely empty the current history list.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: (@&gt; "More about Multi-Commands") for information about</span>
<span class="linecomment">;;  using `S-delete' to delete objects associated with completion</span>
<span class="linecomment">;;  candidates.</span>
 
<span class="linecomment">;;(@* "Isearch Enhancements")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Isearch Enhancements</span>
<span class="linecomment">;;  --------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles provides two different enhancements for searching:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - Icicles search: Top-level Icicles commands that provide an</span>
<span class="linecomment">;;    entirely new and different way for you to search.</span>
<span class="linecomment">;;    This is described in section</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - Extensions to standard Emacs incremental search, Isearch.</span>
<span class="linecomment">;;    These are described in this section.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    * Search string completion against previous search strings.</span>
<span class="linecomment">;;    * Occur mode interface for Isearch hits.</span>
<span class="linecomment">;;    * Icicles search (`icicle-search') interface, reusing the</span>
<span class="linecomment">;;      Isearch search string (by default).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Support for Projects")</span>
<span class="linecomment">;;    for information about using `grep' to search all of the files in</span>
<span class="linecomment">;;    a project.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Isearch Completion Against the Search History")</span>
<span class="linecomment">;;  ** Isearch Completion Against the Search History **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you search incrementally (`C-s'), Emacs lets you use `M-TAB'</span>
<span class="linecomment">;;  to complete your input to a string that you have sought</span>
<span class="linecomment">;;  previously, that is, a string in the current search history</span>
<span class="linecomment">;;  (`search-ring' or `regexp-search-ring').  In Icicle mode, this</span>
<span class="linecomment">;;  feature is enhanced so that you can use all of the completion</span>
<span class="linecomment">;;  enhancements provided by Icicles: `M-TAB' is bound to</span>
<span class="linecomment">;;  `icicle-isearch-complete' during Isearch.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  On MS Windows, the operating system itself grabs `M-TAB' (by</span>
<span class="linecomment">;;  default), making it unavailable for Emacs.  For this reason, on</span>
<span class="linecomment">;;  Windows, Icicles binds `C-M-TAB' also to</span>
<span class="linecomment">;;  `icicle-isearch-complete'.  But note that you can also use</span>
<span class="linecomment">;;  (w32-register-hot-key [M-tab]) to enable Emacs to use `M-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles users are in the habit of using `M-o' to complete the</span>
<span class="linecomment">;;  current minibuffer input against previously entered inputs.</span>
<span class="linecomment">;;  Because of the similarity, you can likewise use `M-o' during</span>
<span class="linecomment">;;  Isearch to complete the current search string: `M-o' is equivalent</span>
<span class="linecomment">;;  to `M-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The keys bound by default to `icicle-isearch-complete' in</span>
<span class="linecomment">;;  `isearch-mode-map' are thus `M-o' and `M-TAB' (and `C-M-TAB' on MS</span>
<span class="linecomment">;;  Windows).  But you can change the keys to use for this by</span>
<span class="linecomment">;;  customizing option `icicle-isearch-complete-keys'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you use `M-o' (or `M-TAB') while searching, Isearch exits</span>
<span class="linecomment">;;  momentarily, giving way to Icicles completion in the minibuffer</span>
<span class="linecomment">;;  (Isearch actually uses the echo area, not the minibuffer).  You</span>
<span class="linecomment">;;  can then use either `S-TAB' or `TAB' to complete your search</span>
<span class="linecomment">;;  string.  After you finish completing (e.g. by hitting `RET'),</span>
<span class="linecomment">;;  Isearch resumes with the new, completed search string.  It's</span>
<span class="linecomment">;;  pretty seamless, and easier to try than to describe.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Reminder: Using `S-TAB' vs `TAB' for regexp vs non-regexp</span>
<span class="linecomment">;;  completion against previous search strings has nothing to do with</span>
<span class="linecomment">;;  regexp vs non-regexp searching.  You can of course use either kind</span>
<span class="linecomment">;;  of searching before or after having used either kind of</span>
<span class="linecomment">;;  completion.  Isearch uses different search rings for regexp and</span>
<span class="linecomment">;;  non-regexp searching.  The kind of search in progress (regexp or</span>
<span class="linecomment">;;  not) at the moment you ask Isearch for completion determines which</span>
<span class="linecomment">;;  search ring provides the candidates for completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Launch Occur using the Isearch Search String")</span>
<span class="linecomment">;;  ** Launch Occur using the Isearch Search String **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use library `color-moccur.el' or library</span>
<span class="linecomment">;;  `occur-schroeder.el', then `C-o' is bound during Isearch to</span>
<span class="linecomment">;;  `isearch-moccur', which provides an Occur buffer interface for</span>
<span class="linecomment">;;  search hits.  This has nothing per se to do with Icicles, but you</span>
<span class="linecomment">;;  might find it useful.  (Library `color-moccur.el' itself binds</span>
<span class="linecomment">;;  `M-o' for this, but `M-o' is used in Icicles for search-string</span>
<span class="linecomment">;;  completion.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Launch Icicles Search using the Isearch Search String")</span>
<span class="linecomment">;;  ** Launch Icicles Search using the Isearch Search String **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles search is described in section</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can start Icicles search from Isearch: Hit `S-TAB' to choose</span>
<span class="linecomment">;;  the Icicles search initial regexp - the default value is the</span>
<span class="linecomment">;;  current Isearch search string, but you can edit that.  Completion</span>
<span class="linecomment">;;  is available for your input - completion against your previous</span>
<span class="linecomment">;;  Isearch regexp search strings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, use `C-s C-w C-w S-TAB' to pick up the next two words</span>
<span class="linecomment">;;  at the cursor, then type `.*' before and after them and hit `RET'.</span>
<span class="linecomment">;;  That puts you in Icicles search with the completion candidates</span>
<span class="linecomment">;;  being all of the lines in the buffer that contain that two-word</span>
<span class="linecomment">;;  phrase.  Type some more text to narrow the candidate lines to</span>
<span class="linecomment">;;  those that match what you type.  Then use `C-next' to visit search</span>
<span class="linecomment">;;  hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The key to initiate Icicles search from Isearch is `S-TAB' only by</span>
<span class="linecomment">;;  default.  You can change this key by customizing option</span>
<span class="linecomment">;;  `icicle-search-from-isearch-keys'.</span>
 
<span class="linecomment">;;  The Icicles doc is continued in file `icicles-doc2.el'.</span>
 
<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; This program is free software; you can redistribute it and/or</span>
<span class="linecomment">;; modify it under the terms of the GNU General Public License as</span>
<span class="linecomment">;; published by the Free Software Foundation; either version 2, or (at</span>
<span class="linecomment">;; your option) any later version.</span>

<span class="linecomment">;; This program is distributed in the hope that it will be useful,</span>
<span class="linecomment">;; but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="linecomment">;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="linecomment">;; GNU General Public License for more details.</span>

<span class="linecomment">;; You should have received a copy of the GNU General Public License</span>
<span class="linecomment">;; along with this program; see the file COPYING.  If not, write to</span>
<span class="linecomment">;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth</span>
<span class="linecomment">;; Floor, Boston, MA 02110-1301, USA.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;; Code:</span>

<span class="linecomment">;; You need not load this file.  It contains only documentation.</span>

(provide 'icicles-doc1)

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;; icicles-doc1.el ends here</span></span></pre></div><div class="wrapper close"></div></div><div class="footer"><hr /><span class="gotobar bar"><a class="local" href="http://www.emacswiki.org/emacs/SiteMap">SiteMap</a> <a class="local" href="http://www.emacswiki.org/emacs/Search">Search</a> <a class="local" href="http://www.emacswiki.org/emacs/ElispArea">ElispArea</a> <a class="local" href="http://www.emacswiki.org/emacs/HowTo">HowTo</a> <a class="local" href="http://www.emacswiki.org/emacs/RecentChanges">RecentChanges</a> <a class="local" href="http://www.emacswiki.org/emacs/News">News</a> <a class="local" href="http://www.emacswiki.org/emacs/Problems">Problems</a> <a class="local" href="http://www.emacswiki.org/emacs/Suggestions">Suggestions</a> </span><span class="translation bar"><br />  <a class="translation new" rel="nofollow" href="http://www.emacswiki.org/emacs?action=translate;id=icicles-doc1.el;missing=de_es_fr_it_ja_ko_pt_ru_se_zh">Add Translation</a></span><span class="edit bar"><br /> <a class="edit" accesskey="e" title="Click to edit this page" rel="nofollow" href="http://www.emacswiki.org/emacs?action=edit;id=icicles-doc1.el">Edit this page</a> <a class="history" rel="nofollow" href="http://www.emacswiki.org/emacs?action=history;id=icicles-doc1.el">View other revisions</a> <a class="admin" rel="nofollow" href="http://www.emacswiki.org/emacs?action=admin;id=icicles-doc1.el">Administration</a></span><span class="time"><br /> Last edited 2009-02-28 20:35 UTC by <a class="author" title="from inet-bc01-o.oracle.com" href="http://www.emacswiki.org/emacs/DrewAdams">DrewAdams</a> <a class="diff" rel="nofollow" href="http://www.emacswiki.org/emacs?action=browse;diff=2;id=icicles-doc1.el">(diff)</a></span><div style="float:right; margin-left:1ex;">
<!-- Creative Commons License -->
<a href="http://creativecommons.org/licenses/GPL/2.0/"><img alt="CC-GNU GPL" style="border:none" src="/pics/cc-GPL-a.png" /></a>
<!-- /Creative Commons License -->
</div>

<!--
<rdf:RDF xmlns="http://web.resource.org/cc/"
 xmlns:dc="http://purl.org/dc/elements/1.1/"
 xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="">
   <license rdf:resource="http://creativecommons.org/licenses/GPL/2.0/" />
  <dc:type rdf:resource="http://purl.org/dc/dcmitype/Software" />
</Work>

<License rdf:about="http://creativecommons.org/licenses/GPL/2.0/">
   <permits rdf:resource="http://web.resource.org/cc/Reproduction" />
   <permits rdf:resource="http://web.resource.org/cc/Distribution" />
   <requires rdf:resource="http://web.resource.org/cc/Notice" />
   <permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
   <requires rdf:resource="http://web.resource.org/cc/ShareAlike" />
   <requires rdf:resource="http://web.resource.org/cc/SourceCode" />
</License>
</rdf:RDF>
-->

<p class="legal">
This work is licensed to you under version 2 of the
<a href="http://www.gnu.org/">GNU</a> <a href="/GPL">General Public License</a>.
Alternatively, you may choose to receive this work under any other
license that grants the right to use, copy, modify, and/or distribute
the work, as long as that license imposes the restriction that
derivative works have to grant the same rights and impose the same
restriction. For example, you may choose to receive this work under
the
<a href="http://www.gnu.org/">GNU</a>
<a href="/FDL">Free Documentation License</a>, the
<a href="http://creativecommons.org/">CreativeCommons</a>
<a href="http://creativecommons.org/licenses/sa/1.0/">ShareAlike</a>
License, the XEmacs manual license, or
<a href="/OLD">similar licenses</a>.
</p>
</div>
</body>
</html>
