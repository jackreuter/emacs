<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>EmacsWiki: icicles-doc2.el</title><link rel="alternate" type="application/wiki" title="Edit this page" href="http://www.emacswiki.org/emacs?action=edit;id=icicles-doc2.el" /><link type="text/css" rel="stylesheet" href="/emacs/wiki.css" /><meta name="robots" content="INDEX,FOLLOW" /><link rel="alternate" type="application/rss+xml" title="EmacsWiki" href="http://www.emacswiki.org/emacs?action=rss" /><link rel="alternate" type="application/rss+xml" title="EmacsWiki: icicles-doc2.el" href="http://www.emacswiki.org/emacs?action=rss;rcidonly=icicles-doc2.el" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki with page content"
      href="http://www.emacswiki.org/emacs/full.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki with page content and diff"
      href="http://www.emacswiki.org/emacs/full-diff.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki including minor differences"
      href="http://www.emacswiki.org/emacs/minor-edits.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Changes for icicles-doc2.el only"
      href="http://www.emacswiki.org/emacs?action=rss;rcidonly=icicles-doc2.el" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body class="http://www.emacswiki.org/emacs"><div class="header"><a class="logo" href="http://www.emacswiki.org/emacs/SiteMap"><img class="logo" src="/emacs_logo.png" alt="[Home]" /></a><span class="gotobar bar"><a class="local" href="http://www.emacswiki.org/emacs/SiteMap">SiteMap</a> <a class="local" href="http://www.emacswiki.org/emacs/Search">Search</a> <a class="local" href="http://www.emacswiki.org/emacs/ElispArea">ElispArea</a> <a class="local" href="http://www.emacswiki.org/emacs/HowTo">HowTo</a> <a class="local" href="http://www.emacswiki.org/emacs/RecentChanges">RecentChanges</a> <a class="local" href="http://www.emacswiki.org/emacs/News">News</a> <a class="local" href="http://www.emacswiki.org/emacs/Problems">Problems</a> <a class="local" href="http://www.emacswiki.org/emacs/Suggestions">Suggestions</a> </span>
<!-- Google CSE Search Box Begins  -->
<form class="tiny" action="http://www.google.com/cse" id="searchbox_004774160799092323420:6-ff2s0o6yi"><p>
<input type="hidden" name="cx" value="004774160799092323420:6-ff2s0o6yi" />
<input type="text" name="q" size="25" />
<input type="submit" name="sa" value="Search" />
</p></form>
<script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=searchbox_004774160799092323420%3A6-ff2s0o6yi"></script>
<!-- Google CSE Search Box Ends -->
<h1><a title="Click to search for references to this page" rel="nofollow" href="http://www.google.com/cse?cx=004774160799092323420:6-ff2s0o6yi&amp;q=%22icicles-doc2.el%22">icicles-doc2.el</a></h1></div><div class="wrapper"><div class="content browse"><p><a href="http://www.emacswiki.org/emacs/download/icicles-doc2.el">Download</a></p><pre class="code"><span class="linecomment">;;; icicles-doc2.el --- Minibuffer input completion and cycling.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; Filename: icicles-doc2.el</span>
<span class="linecomment">;; Description: Minibuffer completion and cycling.</span>
<span class="linecomment">;; Author: Drew Adams</span>
<span class="linecomment">;; Maintainer: Drew Adams</span>
<span class="linecomment">;; Copyright (C) 1996-2009, Drew Adams, all rights reserved.</span>
<span class="linecomment">;; Created: Tue Aug  1 14:21:16 1995</span>
<span class="linecomment">;; Version: 22.0</span>
<span class="linecomment">;; Last-Updated: Sat Feb 28 12:39:33 2009 (-0800)</span>
<span class="linecomment">;;           By: dradams</span>
<span class="linecomment">;;     Update #: 25001</span>
<span class="linecomment">;; URL: http://www.emacswiki.org/cgi-bin/wiki/icicles-doc2.el</span>
<span class="linecomment">;; Keywords: internal, extensions, help, abbrev, local, minibuffer,</span>
<span class="linecomment">;;           keys, apropos, completion, matching, regexp, command</span>
<span class="linecomment">;; Compatibility: GNU Emacs 20.x, GNU Emacs 21.x, GNU Emacs 22.x</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; Features that might be required by this library:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   None</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;; Commentary:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles documentation, part 2.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Files `icicles-doc1.el' and `icicles-doc2.el' contain the doc for</span>
<span class="linecomment">;;  Icicles, including how to install and use Icicles.  You can also</span>
<span class="linecomment">;;  read the Icicles doc, in formatted form, on the Emacs-Wiki Web</span>
<span class="linecomment">;;  site: http://www.emacswiki.org/cgi-bin/wiki/Icicles.  Emacs Wiki</span>
<span class="linecomment">;;  also has a few addtional pages about Icicles.  In particular, if</span>
<span class="linecomment">;;  you are new to Emacs, as well as Icicles, see this page:</span>
<span class="linecomment">;;  http://www.emacswiki.org/cgi-bin/wiki/EmacsNewbieWithIcicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This file continues the Icicles documentation, which starts in</span>
<span class="linecomment">;;  file `icicles-doc1.el'.</span>
 
<span class="linecomment">;;(@* "Index")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Index</span>
<span class="linecomment">;;  -----</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you have library `linkd.el' and Emacs 22 or later, load</span>
<span class="linecomment">;;  `linkd.el' and turn on `linkd-mode' now.  It lets you easily</span>
<span class="linecomment">;;  navigate around the sections of this doc.  Linkd mode will</span>
<span class="linecomment">;;  highlight this Index and render it more readable.  Likewise, for</span>
<span class="linecomment">;;  the cross-references and section headings throughout this file.</span>
<span class="linecomment">;;  You can get `linkd.el' here:</span>
<span class="linecomment">;;  http://www.emacswiki.org/cgi-bin/wiki/linkd.el.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Documentation in File `icicles-doc1.el'")</span>
<span class="linecomment">;;  -----------------------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Nutshell View of Icicles")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "README for Non-Readers")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Toggle Options on the Fly")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Cycle Completion Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Display Completion Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Prefix Completion and Apropos Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Chains of Simple Match Patterns - Progressive Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Chip Away the Non-Elephant")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Choose Before You Act")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Help on Completion Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Perform Multiple Operations In One Command")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Completion Status Indicators")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Icicles Search")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Complete Key Sequences Too")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Available for Almost Any Input")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Component Icicles Libraries")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "If You Are an Emacs-Lisp Programmer")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Inserting Text Found Near the Cursor")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Background on Vanilla Emacs Input Completion")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Cycling Completions")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Traversing Minibuffer Histories")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Apropos Completions")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Expanded-Common-Match Completion")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Progressive Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "`M-*': Matching Additional Regexps")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Successive Approximation...")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "`M-&': Satisfying Additional Predicates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Regressive Completion")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Inserting a Regexp from a Variable")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Special Characters in Input Patterns")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Alternative Libraries: Other Methods of Choosing Default Values")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Exiting the Minibuffer Without Confirmation")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "*Completions* Display")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Icompletion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "icomplete+.el Displays the Number of Other Prefix Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Icicles Highlights the Input that Won't Complete")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Icompletion in *Completions*: Apropos and Prefix Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Sorting Candidates and Removing Duplicates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Changing the Sort Order")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Defining New Sort Orders")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Different Sorts for Different Sorts of Uses")</span>

<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Get Help on Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Use Candidate Help Like You Use Emacs Command `apropos'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Other Icicles Apropos Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "What Is a Multi-Command?")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "How Does a Multi-Command Work?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "More about Multi-Commands")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Alternative Actions")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Deleting Objects")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Icicles Tripping")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Highlighting the Destination")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Key Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Completing Keys")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "`S-TAB' Is Everywhere - Start With It")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Completing Keys By Name")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Completing Prefix Keys")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Meta Key Bindings")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Navigate the Key-Binding Hierarchy")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Local Bindings Are Highlighted")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Completing Keys By Just Hitting Them")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Key and Command Help")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "`S-TAB' Is a Multi-Command")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Possible Source of Confusion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Three-Key Emacs")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Entering Special and Foreign Characters")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Handling Keymaps That Are Inaccessible From the Global Map")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Icicles Multi `M-x'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Examples of Using Multi `M-x'")</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc1.el" :to "What about describe-variable and describe-function?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Multi `M-x' Turns Every Command into a Multi-Command")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Choose All Completion Candidates")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Sets of Completion Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Saving and Retrieving Completion Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Different Places for Saving and Retrieving Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Set Operations")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Google Matching")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Domain of Discourse")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Global Filtering")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Word Matching and String Matching")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "AND Matching and OR Matching")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "NOT Matching")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "File-Name Input and Locating Files Anywhere")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Function `read-file-name'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Function `completing-read'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Icicles Commands that Read File Names")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Absolute File Names and Different Directories")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Persistent Sets of Completion Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Saving Candidates in Cache Files")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Filesets and Icicles Saved Completion Sets")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Improving Performance with Persistent Sets")</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc1.el" :to "Avoid Remote File-Name Completion")</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc1.el" :to "Avoid Generating A Large Completion Set")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Dealing With Large Candidate Sets")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "History Enhancements")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "What Input, What History?")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Overview of Minibuffer History Enhancements")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Using Completion to Insert Previous Inputs: `M-o'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Putting Previous Candidates First: `C-M-,'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Matching Only Historical Candidates: `M-h' and `M-pause'")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Isearch Enhancements")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Launch Occur using the Isearch Search String")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Launch Icicles Search using the Isearch Search String")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@* "Documentation in File `icicles-doc2.el'")</span>
<span class="linecomment">;;  ----------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;    (@&gt; "Introduction: On Beyond Occur...")</span>
<span class="linecomment">;;    (@&gt; "How Icicles Search Works")</span>
<span class="linecomment">;;    (@&gt; "Why Use 2 Search Patterns?")</span>
<span class="linecomment">;;    (@&gt; "Search Multiple Buffers, Files, and Saved Regions")</span>
<span class="linecomment">;;    (@&gt; "User Options for Icicles Searching")</span>
<span class="linecomment">;;    (@&gt; "Using Regexps With Icicles Search")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Search and Replace")</span>
<span class="linecomment">;;  (@&gt; "Other Icicles Search Commands")</span>
<span class="linecomment">;;    (@&gt; "Icicles Imenu")</span>
<span class="linecomment">;;      (@&gt; "`icicle-imenu' Combines Benefits of Imenu and Emacs Tags")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (@&gt; "Compile/Grep Search")</span>
<span class="linecomment">;;    (@&gt; "Input Reuse in Interactive Interpreter Modes")</span>
<span class="linecomment">;;    (@&gt; "Define Your Own Icicles Search Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Multiple Regions")</span>
<span class="linecomment">;;  (@&gt; "Icicles Tags Enhancements")</span>
<span class="linecomment">;;    (@&gt; "`icicle-find-tag': Find Tags in All Tags Tables")</span>
<span class="linecomment">;;    (@&gt; "`icicle-find-first-tag': Find First Tag in Current Table")</span>
<span class="linecomment">;;    (@&gt; "`icicle-tags-search': Search and Replace Using Tags")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Icicles Shell-Command Enhancements")</span>
<span class="linecomment">;;  (@&gt; "Icicles Dired Enhancements")</span>
<span class="linecomment">;;    (@&gt; "Shell Commands on Marked Files")</span>
<span class="linecomment">;;    (@&gt; "Search-and-Replace Marked Files")</span>
<span class="linecomment">;;    (@&gt; "Save Marked Files as Completion Candidates")</span>
<span class="linecomment">;;    (@&gt; "Open Dired for a Set of File Names")</span>
<span class="linecomment">;;    (@&gt; "Marked Files as a Project")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Icicles Info Enhancements")</span>
<span class="linecomment">;;    (@&gt; "Icicles Completion for Info")</span>
<span class="linecomment">;;    (@&gt; "Using Icicle-Search With Info")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Support for Projects")</span>
<span class="linecomment">;;    (@&gt; "Defining and Saving Sets of Files, Buffers, Regions")</span>
<span class="linecomment">;;    (@&gt; "Navigating Among Code Definitions")</span>
<span class="linecomment">;;    (@&gt; "Searching Project Files")</span>
<span class="linecomment">;;    (@&gt; "Retrieving and Reusing a Saved Project")</span>
<span class="linecomment">;;    (@&gt; "Semantics? Roll Your Own?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Using Complex Completion Candidates")</span>
<span class="linecomment">;;  (@&gt; "Icicles OO: Object-Action Interaction")</span>
<span class="linecomment">;;    (@&gt; "Apropos Completion as OO")</span>
<span class="linecomment">;;    (@&gt; "M-RET")</span>
<span class="linecomment">;;    (@&gt; "`icicle-object-action' and `icicle-anything'")</span>
<span class="linecomment">;;    (@&gt; "Icicles with Anything")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Multi-Completions")</span>
<span class="linecomment">;;    (@&gt; "Icicles Multi-Completion Commands")</span>
<span class="linecomment">;;    (@&gt; "How Multi-Completions Work")</span>
<span class="linecomment">;;    (@&gt; "Multi-Completions vs `completing-read-multiple'")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Fuzzy Completion")</span>
<span class="linecomment">;;    (@&gt; "Scatter-Match Completion")</span>
<span class="linecomment">;;    (@&gt; "Fuzzy-Match Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Completion in Other Buffers")</span>
<span class="linecomment">;;    (@&gt; "Dynamic Abbreviation")</span>
<span class="linecomment">;;    (@&gt; "BBDB Completion")</span>
<span class="linecomment">;;    (@&gt; "Thesaurus Completion")</span>
<span class="linecomment">;;    (@&gt; "Completion in Comint Modes")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Customization and General Tips")</span>
<span class="linecomment">;;    (@&gt; "Using Icicles with Delete Selection Mode")</span>
<span class="linecomment">;;    (@&gt; "Icicles User Options and Faces")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "File-Name and Directory-Name Completion Tips")</span>
<span class="linecomment">;;  (@&gt; "Key Bindings")</span>
<span class="linecomment">;;    (@&gt; "Global Bindings")</span>
<span class="linecomment">;;    (@&gt; "Icicles-Mode Bindings")</span>
<span class="linecomment">;;    (@&gt; "Minibuffer Bindings")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Customizing Key Bindings")</span>
<span class="linecomment">;;    (@&gt; "Customizing Global Bindings")</span>
<span class="linecomment">;;    (@&gt; "Customizing Icicle Mode Bindings")</span>
<span class="linecomment">;;    (@&gt; "Customizing Minibuffer Bindings")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Icicles Redefines Some Standard Commands")</span>
<span class="linecomment">;;  (@&gt; "Programming with Fancy Candidates")</span>
<span class="linecomment">;;  (@&gt; "Programming Multi-Completions")</span>
<span class="linecomment">;;    (@&gt; "Variable icicle-list-use-nth-parts")</span>
<span class="linecomment">;;    (@&gt; "Variable icicle-candidate-properties-alist")</span>
<span class="linecomment">;;    (@&gt; "What You See Is Not What You Get")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Candidates with Text Properties")</span>
<span class="linecomment">;;    (@&gt; "Using Property icicle-special-candidate")</span>
<span class="linecomment">;;    (@&gt; "Applying Text Properties to a Candidate String")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Defining Icicles Commands (Including Multi-Commands)")</span>
<span class="linecomment">;;    (@&gt; "Nothing To It!")</span>
<span class="linecomment">;;    (@&gt; "Multi-Commands Are Easy To Define Too")</span>
<span class="linecomment">;;    (@&gt; "Are Users Dependent on Icicles To Use Multi-Commands?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Defining Icicles Tripping Commands")</span>
<span class="linecomment">;;  (@&gt; "Defining Multiple-Choice Menus")</span>
<span class="linecomment">;;  (@&gt; "Defining Icicles Multi `M-x'")</span>
<span class="linecomment">;;    (@&gt; "How Multi `M-x' is Defined")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Defining Multi-Commands the Hard Way")</span>
<span class="linecomment">;;  (@&gt; "Global Filters")</span>
<span class="linecomment">;;  (@&gt; "Specifying Match Functions for Commands")</span>
<span class="linecomment">;;  (@&gt; "Defining Buffer-Text Completion for Comint Modes")</span>
<span class="linecomment">;;  (@&gt; "Note to Programmers")</span>
<span class="linecomment">;;  (@&gt; "La Petite Histoire")</span>
<span class="linecomment">;;  (@&gt; "Note on Non-nil `pop-up-frames' on MS Windows")</span>
 
<span class="linecomment">;;(@* "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Search Commands, Overview</span>
<span class="linecomment">;;  ---------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section provides an overview of Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The doc string (`C-h f') of command `icicle-search'; it provides</span>
<span class="linecomment">;;    general information about Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Other Icicles Search Commands") for specialized Icicles</span>
<span class="linecomment">;;    search commands, including search in particular buffers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Info Enhancements") for information about using</span>
<span class="linecomment">;;    Icicles to search in Info mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Multiple Regions") for information about searching</span>
<span class="linecomment">;;    multiple regions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Support for Projects") for information about using `grep'</span>
<span class="linecomment">;;    to search all of the files in a project.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Introduction: On Beyond Occur...")</span>
<span class="linecomment">;;  ** Introduction: On Beyond Occur... **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You've no doubt used standard Emacs command `occur'.  It finds all</span>
<span class="linecomment">;;  lines in a buffer that match a regexp that you enter.  It displays</span>
<span class="linecomment">;;  the matching lines as links in buffer *Occur* - you can click a</span>
<span class="linecomment">;;  link to navigate to the corresponding line in the original buffer.</span>
<span class="linecomment">;;  Using buffer *Occur* is similar to using the output of the Emacs</span>
<span class="linecomment">;;  `grep' command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-occur' is similar to `occur', but instead of</span>
<span class="linecomment">;;  entering a regexp (with `RET') you type a regexp and then use</span>
<span class="linecomment">;;  `S-TAB' to show the matching lines in buffer `*Completions*'.  As</span>
<span class="linecomment">;;  usual in Icicles, you can complete to a single candidate, or cycle</span>
<span class="linecomment">;;  among candidates to choose one.  To navigate to a match in the</span>
<span class="linecomment">;;  original buffer, use `C-RET', `C-mouse-2', `C-next', or `C-prior'.</span>
<span class="linecomment">;;  One advantage of `icicle-occur' over `occur' is that you can</span>
<span class="linecomment">;;  change the regexp on the fly to match different sets of lines.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another, major advantage is that you can use progressive</span>
<span class="linecomment">;;  completion to find lines that match multiple regexps.  A similar,</span>
<span class="linecomment">;;  but less interactive, effect can be had using chained `grep'</span>
<span class="linecomment">;;  commands, but it is otherwise not possible with other search</span>
<span class="linecomment">;;  methods such as regexp Isearch.  A regexp simply cannot express</span>
<span class="linecomment">;;  intersection ("and") except in the limited form of "followed by".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-search' is a generalization of `icicle-occur'.</span>
<span class="linecomment">;;  You enter an initial, search-context regexp (using `RET'), which</span>
<span class="linecomment">;;  defines a set of completion candidates: all of the matching</span>
<span class="linecomment">;;  strings in the current buffer (by default).  These candidates are</span>
<span class="linecomment">;;  called "search contexts".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-occur' is really `icicle-search' with an implicit</span>
<span class="linecomment">;;  initial regexp of `.*' (which you do not enter, however).  That</span>
<span class="linecomment">;;  is, the initial completion candidates for `icicle-occur' are all</span>
<span class="linecomment">;;  of the lines of the buffer (`.' matches any character except a</span>
<span class="linecomment">;;  newline).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  With `icicle-search', the candidates need not be single, complete</span>
<span class="linecomment">;;  lines; they can be any strings in the buffer, including</span>
<span class="linecomment">;;  multiple-line strings.  Your initial regexp is used over and over</span>
<span class="linecomment">;;  to find the set of matching strings in the region or buffer that</span>
<span class="linecomment">;;  you search.  These strings then serve as the completion</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, you might use a search-context regexp of "[^^L]*[^L]"</span>
<span class="linecomment">;;  to search pages or "[^.?!]+[.?!][]\"')}]*[ ^I^J]*" to search</span>
<span class="linecomment">;;  sentences.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (`^L' is the page-separator character.  This assumes that `.',</span>
<span class="linecomment">;;  `?', and `!' end sentences, and it allows for quoted sentences and</span>
<span class="linecomment">;;  sentences inside parentheses, brackets, and braces.  You input</span>
<span class="linecomment">;;  `^L', `^I', and `^J' using `C-q l', `C-q TAB', and `C-j'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Again, you can use progressive completion (`M-*') to match several</span>
<span class="linecomment">;;  different regexps within the same page or the same sentence.  For</span>
<span class="linecomment">;;  example, you could find all sentences that contain `character',</span>
<span class="linecomment">;;  `delete', and `backward', in any order, as follows:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-` [^.?!]+[.?!][]\"')}]*[ C-q TAB C-j]* RET</span>
<span class="linecomment">;;    character M-* delete M-* backward</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you visit a search context, both `icicle-occur' and</span>
<span class="linecomment">;;  `icicle-search' highlight that hit.  For `icicle-occur', the</span>
<span class="linecomment">;;  search context is the current line.  For `icicle-search', it is</span>
<span class="linecomment">;;  whatever your search-context regexp matches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "How Icicles Search Works")</span>
<span class="linecomment">;;  ** How Icicles Search Works **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are several Icicles search commands, some of which are bound</span>
<span class="linecomment">;;  to keys in Icicle mode:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-c '',  `icicle-occur' - An `occur' with icompletion.</span>
<span class="linecomment">;;  `C-c `'   `icicle-search' - Seach buffer areas that match regexp.</span>
<span class="linecomment">;;            `icicle-search-buffer' - Search selected buffers.</span>
<span class="linecomment">;;            `icicle-search-file' - Search selected files.</span>
<span class="linecomment">;;            `icicle-search-region' - Search selected saved regions.</span>
<span class="linecomment">;;            `icicle-search-all-regions' - Search all saved regions.</span>
<span class="linecomment">;;  `C-c $'   `icicle-search-word' - Search for a whole word.</span>
<span class="linecomment">;;  `C-c ^'   `icicle-search-keywords' - Search with regexp keywords.</span>
<span class="linecomment">;;  `C-c `'   `icicle-compilation-search' - Search compilation hits</span>
<span class="linecomment">;;                                          (e.g `grep' hits).</span>
<span class="linecomment">;;  `C-c "'   ["] `icicle-search-char-property' -</span>
<span class="linecomment">;;               Search for a given character property value.</span>
<span class="linecomment">;;  `C-c ='   `icicle-imenu' - Navigate among Imenu entries.</span>
<span class="linecomment">;;            `icicle-imenu-command' -</span>
<span class="linecomment">;;               Navigate among Emacs command definitions.</span>
<span class="linecomment">;;            `icicle-imenu-non-interactive-function' -</span>
<span class="linecomment">;;               Navigate among Emacs non-interactive function</span>
<span class="linecomment">;;               definitions.</span>
<span class="linecomment">;;  `C-c TAB' `icicle-comint-command' - Retrieve a past shell command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  All operate in the same general way:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Unlike standard incremental search, Icicles search commands</span>
<span class="linecomment">;;     search the entire buffer, not just the part that follows the</span>
<span class="linecomment">;;     cursor.  If the region is active, however, then the search is</span>
<span class="linecomment">;;     confined to the region.  Some Icicles search commands let you</span>
<span class="linecomment">;;     search across multiple buffers, multiple files, or multiple</span>
<span class="linecomment">;;     saved regions.  Searching within one or more regions of text is</span>
<span class="linecomment">;;     a first way to limit the context of a search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. You limit the search context in a second way, by providing some</span>
<span class="linecomment">;;     information, such as a regexp or a character property (text or</span>
<span class="linecomment">;;     overlay property), that defines zones of text that you want to</span>
<span class="linecomment">;;     search.  You can use (lax) completion against previous input to</span>
<span class="linecomment">;;     enter the regexp or the character property.  In some cases, the</span>
<span class="linecomment">;;     information (e.g. regexp) to define the search context is</span>
<span class="linecomment">;;     provided automatically by the search command; for example,</span>
<span class="linecomment">;;     `icicle-occur' assumes that you want to search lines.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. If you use a regexp to define the search context, and if that</span>
<span class="linecomment">;;     regexp has subgroups, that is, subexpressions of the form</span>
<span class="linecomment">;;     `\(...\)', then you are prompted for the subgroup to use to</span>
<span class="linecomment">;;     define the search context.  0 means the entire regexp match is</span>
<span class="linecomment">;;     used as a context.  1 means that whatever the first subgroup</span>
<span class="linecomment">;;     matches is used as a context, and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     Using a subgroup thus limits the search context in a third way.</span>
<span class="linecomment">;;     It lets you find a search match within a larger search-match</span>
<span class="linecomment">;;     context.  For example, you might choose a Lisp argument list as</span>
<span class="linecomment">;;     the search context, specifying that it must follow `(defun ':</span>
<span class="linecomment">;;     `(defun [^(]*\(([^(]*)\)'.  Subgroup 1 is the argument list.</span>
<span class="linecomment">;;     Specifying a subgroup search context helps you become more</span>
<span class="linecomment">;;     familiar with regexps.  Icicles search highlighting (see below)</span>
<span class="linecomment">;;     shows you the subgroup matches instantly.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. You can limit the set of search contexts in a fourth way by</span>
<span class="linecomment">;;     using `M-&' to provide predicates that search-context</span>
<span class="linecomment">;;     candidates must satisfy.  Command `icicle-search' and its</span>
<span class="linecomment">;;     derivative functions use candidates of the form (CONTEXT</span>
<span class="linecomment">;;     . MARKER), where CONTEXT is a string, the search hit (search</span>
<span class="linecomment">;;     context), and MARKER is a buffer marker that locates the</span>
<span class="linecomment">;;     CONTEXT.  Predicates you supply to the `M-&' prompt must expect</span>
<span class="linecomment">;;     such candidates.  Only contexts that satisfy the predicate are</span>
<span class="linecomment">;;     found.  For example, if the predicate is (lambda (x) (commandp</span>
<span class="linecomment">;;     (intern-soft (car x)))), then only contexts that name Emacs</span>
<span class="linecomment">;;     commands are found.  Or, if you have a predicate `verbp' that</span>
<span class="linecomment">;;     tests whether a word is an English verb form, then you can use</span>
<span class="linecomment">;;     that to limit word matches to verbs.  In this way, you can</span>
<span class="linecomment">;;     combine purely syntactic searching (regexp or text-property</span>
<span class="linecomment">;;     match) with more semantic search criteria.  After building up a</span>
<span class="linecomment">;;     complex predicate by using `M-&', you can save it to a variable</span>
<span class="linecomment">;;     with `C-M-&' and then reuse it later with `C-='.  In addition</span>
<span class="linecomment">;;     to, or instead of, using `M-&', you can set user option</span>
<span class="linecomment">;;     `icicle-search-context-match-predicate' to a predicate that</span>
<span class="linecomment">;;     takes a CONTEXT as argument (the match string only, no MARKER).</span>
<span class="linecomment">;;     See also (@file :file-name "icicles-doc1.el" :to "Progressive Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  5. Icicles finds all of the qualified search contexts, and</span>
<span class="linecomment">;;     presents them to you as completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  6. You can navigate among the source-buffer search contexts, using</span>
<span class="linecomment">;;     the multi-command action keys (`C-next', `C-prior', `C-RET',</span>
<span class="linecomment">;;     `C-mouse-2').  The contexts are highlighted in the source</span>
<span class="linecomment">;;     buffer(s).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  7. As always in Icicles, your current minibuffer input filters the</span>
<span class="linecomment">;;     set of current candidates - the search contexts, so that only</span>
<span class="linecomment">;;     those that contain matches to your input remain as candidates.</span>
<span class="linecomment">;;     This is a second level of matching: looking for a refinement</span>
<span class="linecomment">;;     pattern within the search contexts. And this constitutes a</span>
<span class="linecomment">;;     fifth way you can limit the set of search contexts.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  8. As always in Icicles, this input can be a regexp.  This is</span>
<span class="linecomment">;;     ordinary apropos completion, applied to searching.  You don't</span>
<span class="linecomment">;;     type `RET' to enter this regexp, and you can change it on the</span>
<span class="linecomment">;;     fly to change the set of search hits.  Icicles searching is</span>
<span class="linecomment">;;     thus incremental, in the sense that changing your input</span>
<span class="linecomment">;;     dynamically changes the set of matching search hits.  Icicles</span>
<span class="linecomment">;;     searching is not incremental with respect to the initial,</span>
<span class="linecomment">;;     context matching, however.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  9. As always in Icicles, you can type some input and then hit</span>
<span class="linecomment">;;     `C-~' to remove all candidates that match that input.  Then</span>
<span class="linecomment">;;     type some other input and hit `C-~' again to remove those</span>
<span class="linecomment">;;     matches.  Or you can use `M-&' to define a predicate, and then</span>
<span class="linecomment">;;     hit `C-~' to remove all candidates that satisfy that predicate.</span>
<span class="linecomment">;;     And so on.  And you can use `S-mouse-2' or the `delete' key to</span>
<span class="linecomment">;;     remove individual search hits.  These techniques let you chip</span>
<span class="linecomment">;;     away at the search set, removing hits that are uninteresting.</span>
<span class="linecomment">;;     This is a very powerful technique for both searching and</span>
<span class="linecomment">;;     search-and-replace (see next), and it constitutes a sixth way</span>
<span class="linecomment">;;     to limit the set of search contexts.  See also</span>
<span class="linecomment">;;     (@file :file-name "icicles-doc1.el" :to "Chip Away the Non-Elephant").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  10. You can replace text while you search, forward, backward, or</span>
<span class="linecomment">;;     randomly.  You can replace entire search contexts or just the</span>
<span class="linecomment">;;     parts that match your current input.  You can use any</span>
<span class="linecomment">;;     replacement string that is allowed by `query-replace-regexp'.</span>
<span class="linecomment">;;     In Emacs 22 or later, this includes `\,', to substitute the</span>
<span class="linecomment">;;     result of a Lisp evaluation.  Use the alternative-action keys</span>
<span class="linecomment">;;     for replacement: `C-S-RET', `C-S-mouse-2', `C-S-next',</span>
<span class="linecomment">;;     `C-S-prior', `C-S-down', and `C-S-up'.  At the first use, you</span>
<span class="linecomment">;;     are prompted for the replacement string; it is used thereafter.</span>
<span class="linecomment">;;     You can use `C-|' (`icicle-all-candidates-alt-action') to</span>
<span class="linecomment">;;     replace all matches.  See (@&gt; "Search and Replace").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  11. When you visit a search context (using `C-mouse-2' or</span>
<span class="linecomment">;;     `C-next', for example), the part of the candidate that matches</span>
<span class="linecomment">;;     your input is highlighted.  An entire search context is</span>
<span class="linecomment">;;     highlighted in face `icicle-search-main-regexp-current', and</span>
<span class="linecomment">;;     the part that matches your input is highlighted in face</span>
<span class="linecomment">;;     `icicle-search-current-input'.  All other search contexts are</span>
<span class="linecomment">;;     also highlighted (in face `icicle-search-main-regexp-others').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  12. User option `icicle-search-highlight-all-current-flag'</span>
<span class="linecomment">;;     controls whether the input matches are highlighted within each</span>
<span class="linecomment">;;     search context or only within the current context.  It,</span>
<span class="linecomment">;;     together with `icicle-expand-input-to-common-match-flag',</span>
<span class="linecomment">;;     control whether the input-match highlighting covers an expanded</span>
<span class="linecomment">;;     common match among all matches or just the exact input match.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  13. If you do not use a subgroup to define the search context (as</span>
<span class="linecomment">;;     in #3, above), that is, if the search context corresponds to</span>
<span class="linecomment">;;     the entire search regexp, then up to eight context levels</span>
<span class="linecomment">;;     (subgroups) are each highlighted differently, using faces</span>
<span class="linecomment">;;     `icicle-search-context-level-1' through</span>
<span class="linecomment">;;     `icicle-search-context-level-8'.  This context-level</span>
<span class="linecomment">;;     highlighting is not done if user option</span>
<span class="linecomment">;;     `icicle-search-highlight-context-levels-flag' is nil.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You might have noticed that out of these 13 search features, 6</span>
<span class="linecomment">;;  constitute independent ways in which you can narrow or limit the</span>
<span class="linecomment">;;  set of search hits among which you can navigate.  Restricting the</span>
<span class="linecomment">;;  search space is in fact what search is all about, and Icicles</span>
<span class="linecomment">;;  offers you some unique tools to do this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For several Icicles search commands, including `icicle-search'</span>
<span class="linecomment">;;  (`C-c `'), you provide an initial regexp to define the search</span>
<span class="linecomment">;;  contexts (step 1, above).  Why use two regexps to search (steps 1</span>
<span class="linecomment">;;  and 4, above)?  To make things simpler.  Regular expressions are</span>
<span class="linecomment">;;  powerful for searching, but they can also be cumbersome sometimes.</span>
<span class="linecomment">;;  Why not use one simple regexp to set up a set of candidates and</span>
<span class="linecomment">;;  then, optionally, use a second simple regexp to filter those</span>
<span class="linecomment">;;  candidates?  This is the same idea as that behind progressive</span>
<span class="linecomment">;;  completion with `M-*'.  (Using `M-*' together with the search</span>
<span class="linecomment">;;  commands serves no purpose; its filtering is not cumulative in</span>
<span class="linecomment">;;  this context.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Like `icicle-occur' (`C-c ''), `icicle-search-word' (`C-c $') and</span>
<span class="linecomment">;;  `icicle-search-keywords' (`C-c ^') are variants of `icicle-search'</span>
<span class="linecomment">;;  that differ only in the regexp used.  Each accepts your input and</span>
<span class="linecomment">;;  converts it to a regexp that does the right thing.</span>
<span class="linecomment">;;  `icicle-search-word' just adds `\b' before and after the word you</span>
<span class="linecomment">;;  type, so that it matches at word boundaries.</span>
<span class="linecomment">;;  `icicle-search-keywords' wraps the keywords you provide as input</span>
<span class="linecomment">;;  with regexp grouping (`\(...\)') and alternative (`\|') syntax, so</span>
<span class="linecomment">;;  that search looks for any of the keywords.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  "Keywords" here is an understatement. Each keyword is actually a</span>
<span class="linecomment">;;  regexp and is treated as such, unless you use `C-`' to turn on</span>
<span class="linecomment">;;  escaping of regexp special characters.  In that case, each keyword</span>
<span class="linecomment">;;  is matched as a substring.  At the `C-c $' prompt, you can use</span>
<span class="linecomment">;;  completion to choose keywords that you have already entered, or</span>
<span class="linecomment">;;  you can use `C-RET' to enter new keywords.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a shortcut, you can use the search string during incremental</span>
<span class="linecomment">;;  search (Isearch) as the initial regexp for `icicle-search'.  You</span>
<span class="linecomment">;;  do this by hitting `S-TAB' during Isearch.  This ends Isearch and</span>
<span class="linecomment">;;  passes its search string to `icicle-search'.  This can be a handy</span>
<span class="linecomment">;;  way to start `icicle-search', picking up its search pattern by</span>
<span class="linecomment">;;  using, say, `C-s C-w C-w...'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Search Multiple Buffers, Files, and Saved Regions")</span>
<span class="linecomment">;;  ** Search Multiple Buffers, Files, and Saved Regions **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you provide a plain prefix argument (only `C-u') to most</span>
<span class="linecomment">;;  Icicles search functions, then you can search multiple regions,</span>
<span class="linecomment">;;  which can be in multiple buffers.  The regions are those in user</span>
<span class="linecomment">;;  option `icicle-region-alist', which you have previously defined</span>
<span class="linecomment">;;  using command `icicle-add-region'.  See (@&gt; "Multiple Regions").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you provide a non-negative numeric prefix argument (e.g. `C-9')</span>
<span class="linecomment">;;  to most Icicles search functions, then you can search multiple</span>
<span class="linecomment">;;  buffers - you are prompted for the buffers to search.  If the</span>
<span class="linecomment">;;  prefix argument is 99, then only buffers that are visiting files</span>
<span class="linecomment">;;  are candidates.  You can use `C-RET' and so on to choose</span>
<span class="linecomment">;;  individual buffers with completion.  You can use `C-!' to choose</span>
<span class="linecomment">;;  all buffers or all buffers that match a regexp.</span>
<span class="linecomment">;;  (See (@file :file-name "icicles-doc1.el" :to "Multi-Commands").)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: You can use `M-s i' in Ibuffer or Buffer Menu to search all</span>
<span class="linecomment">;;  marked buffers using Icicles search.  In Ibuffer, menu item</span>
<span class="linecomment">;;  `Icicles Search (and Replace)...' does the same thing as `M-s i'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you provide a negative numeric prefix argument (e.g. `C--') to</span>
<span class="linecomment">;;  most Icicles search functions, then you can search multiple files</span>
<span class="linecomment">;;  in the current directory - you are prompted for the files to</span>
<span class="linecomment">;;  search.  As for multiple-buffer searching, you can use `C-RET' and</span>
<span class="linecomment">;;  so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: You can use `M-s i' in Dired to search all marked files</span>
<span class="linecomment">;;  using Icicles search.  Menu item `Search (and Replace)...' is</span>
<span class="linecomment">;;  added to the Icicles submenu of menu `Multiple' (or `Operate'),</span>
<span class="linecomment">;;  and it does the same thing as `M-s i'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a convenience, some specialized Icicles commands are defined,</span>
<span class="linecomment">;;  corresponding to `icicle-search' with each of the prefix-argument</span>
<span class="linecomment">;;  cases: `icicle-search-all-regions', `icicle-search-buffer', and</span>
<span class="linecomment">;;  `icicle-search-file'.  If you often use `C-c `' with one of the</span>
<span class="linecomment">;;  prefix argument options, then you might want to bind one or more</span>
<span class="linecomment">;;  of these commands.  These commands are also available in the</span>
<span class="linecomment">;;  Icicles menu-bar menu (or the Search menu, if it exists).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "User Options for Icicles Searching")</span>
<span class="linecomment">;;  ** User Options for Icicles Searching **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can customize the following user options, to control search</span>
<span class="linecomment">;;  and replacement behavior.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If `icicle-add-buffer-name-flag' is non-nil (the default value),</span>
<span class="linecomment">;;    then, whenever you use a prefix argument, Icicles search</span>
<span class="linecomment">;;    functions annotate each candidate with the name of the buffer</span>
<span class="linecomment">;;    where the search hit occurs, highlighted, to help orient you.</span>
<span class="linecomment">;;    The buffer name is actually part of the (multi-completion)</span>
<span class="linecomment">;;    candidate, so you can match against it.  Note that even when the</span>
<span class="linecomment">;;    value of this option is nil, you can use `C-M-mouse-2', and so</span>
<span class="linecomment">;;    on, to see the buffer name, as well as the position of the</span>
<span class="linecomment">;;    search context in the buffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Icicles search functions that use an initial regexp highlight</span>
<span class="linecomment">;;    the first `icicle-search-highlight-threshold' matches for that</span>
<span class="linecomment">;;    regexp at once (using face `icicle-search-main-regexp-others').</span>
<span class="linecomment">;;    The effect is similar to the Emacs 22+ lazy search highlighting</span>
<span class="linecomment">;;    of Isearch (except that the highlighting is not in fact lazy).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If `icicle-search-highlight-all-current-flag' is non-nil, then</span>
<span class="linecomment">;;    Icicles search functions highlight your current input match</span>
<span class="linecomment">;;    within *all* search contexts at once.  If it is non-nil and</span>
<span class="linecomment">;;    `icicle-expand-input-to-common-match-flag' is also non-nil, then</span>
<span class="linecomment">;;    what is highlighted for each input match is the expanded common</span>
<span class="linecomment">;;    match among all input matches throughout the search area.  If</span>
<span class="linecomment">;;    either is nil, then only the exact input match is highlighted.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    For example</span>
<span class="linecomment">;;    (see (@file :file-name "icicles-doc1.el" :to "Nutshell View of Icicles")),</span>
<span class="linecomment">;;    if the initial regexp defining the search context is</span>
<span class="linecomment">;;    `.*recursive.*', and your input is `edit', then searching file</span>
<span class="linecomment">;;    `icicles-doc1.el' highlights not `edit' but</span>
<span class="linecomment">;;    ``abort-recursive-edit'', which is the longest common match</span>
<span class="linecomment">;;    among all input matches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If `icicle-expand-input-to-common-match-flag',</span>
<span class="linecomment">;;    `icicle-search-highlight-all-current-flag', and</span>
<span class="linecomment">;;    `icicle-search-replace-common-match-flag' are all non-nil, then</span>
<span class="linecomment">;;    a search replacement replaces the expanded common match;</span>
<span class="linecomment">;;    otherwise, it replaces only the exact match.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The default value of `icicle-search-highlight-all-current-flag'</span>
<span class="linecomment">;;    is nil, because non-nil can impact performance negatively if</span>
<span class="linecomment">;;    there are many search contexts - the highlighting is updated</span>
<span class="linecomment">;;    with each input change.  You can toggle the value at any time</span>
<span class="linecomment">;;    using command `icicle-toggle-highlight-all-current', bound to</span>
<span class="linecomment">;;    `C-^' in the minibuffer during Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If `icicle-search-cleanup-flag' is non-nil (the default value)</span>
<span class="linecomment">;;    then search highlighting is removed after the search.  If you</span>
<span class="linecomment">;;    set this to nil then you can remove search highlighting manually</span>
<span class="linecomment">;;    later using command `icicle-search-highlight-cleanup'.  You can</span>
<span class="linecomment">;;    toggle this search highlight removal at any time using command</span>
<span class="linecomment">;;    `icicle-toggle-search-cleanup', bound to `C-.' in the minibuffer</span>
<span class="linecomment">;;    (except during file-name completion).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    One use of nil `icicle-search-cleanup-flag' is to highlight</span>
<span class="linecomment">;;    regexp matches throughout a region or buffer (or multiple files</span>
<span class="linecomment">;;    or...).  In that capacity, Icicles search functions act like</span>
<span class="linecomment">;;    some of the highlighting commands in my library `highlight.el'.</span>
<span class="linecomment">;;    Note that when `icicle-search-cleanup-flag' is nil, *all*</span>
<span class="linecomment">;;    Icicles search highlighting remains: last-visited search</span>
<span class="linecomment">;;    context, other context matches, current-input matches, and even</span>
<span class="linecomment">;;    regexp subgroups.  The faces for these are, respectively:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - `icicle-search-main-regexp-current'</span>
<span class="linecomment">;;    - `icicle-search-main-regexp-others'</span>
<span class="linecomment">;;    - `icicle-search-highlight-input-matches-here' (everywhere, if</span>
<span class="linecomment">;;      `icicle-search-highlight-all-current-flag' is non-nil)</span>
<span class="linecomment">;;    - `icicle-search-context-level-1' through</span>
<span class="linecomment">;;      `icicle-search-context-level-8'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If `icicle-search-replace-whole-candidate-flag' is nil, then</span>
<span class="linecomment">;;    whatever matches your current input is replaced, within the</span>
<span class="linecomment">;;    current search context, when you perform replacement</span>
<span class="linecomment">;;    (e.g. `C-S-RET').  If the value is non-nil (the default value),</span>
<span class="linecomment">;;    then the entire search context is replaced, instead.  You can</span>
<span class="linecomment">;;    use `C-,' at any time during searching and replacing, to toggle</span>
<span class="linecomment">;;    the value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Command `icicle-search-word' (bound to `C-c $') always searches</span>
<span class="linecomment">;;    for a whole word: your initial search string is matched only</span>
<span class="linecomment">;;    against whole words.  Non-nil `icicle-search-whole-word-flag'</span>
<span class="linecomment">;;    makes other Icicles search commands also perform whole-word</span>
<span class="linecomment">;;    searching.  The search string you type is matched literally, but</span>
<span class="linecomment">;;    matches must start and end at word boundaries.  Because it is</span>
<span class="linecomment">;;    matched literally, all regexp special characters in the search</span>
<span class="linecomment">;;    string are escaped.  This means, for instance, that you can</span>
<span class="linecomment">;;    match `foo-bar' as a word, even in contexts (such as Emacs Lisp)</span>
<span class="linecomment">;;    where `-' is not a word-constituent character.  Similarly, you</span>
<span class="linecomment">;;    can match the literal four-character "word" `f.*g'.  You can use</span>
<span class="linecomment">;;    `M-q' while searching to toggle this option; the new value takes</span>
<span class="linecomment">;;    effect for the next complete search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can toggle `icicle-use-C-for-actions-flag' at any time using</span>
<span class="linecomment">;;    `M-g' in the minibuffer.  This is handy for multi-commands that</span>
<span class="linecomment">;;    browse, such as Icicles search.  It means that you can use</span>
<span class="linecomment">;;    `next' and so on instead of `C-next' and so on to navigate among</span>
<span class="linecomment">;;    search hits.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Option `icicle-use-C-for-actions-flag'").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-search-hook': Functions run after searching and moving</span>
<span class="linecomment">;;    to a match, whether by `RET' or `C-RET' (or `C-next' or</span>
<span class="linecomment">;;    `C-prior').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It can sometimes be useful to highlight all regexp matches using a</span>
<span class="linecomment">;;  large value of `icicle-search-highlight-threshold' and a nil value</span>
<span class="linecomment">;;  of `icicle-search-cleanup-flag', and then set</span>
<span class="linecomment">;;  `icicle-search-highlight-threshold' to zero and use an Icicles</span>
<span class="linecomment">;;  search function again with a different regexp to search through</span>
<span class="linecomment">;;  the same region or buffer.  This lets you see the relation between</span>
<span class="linecomment">;;  the two sets of regexp matches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using Regexps With Icicles Search")</span>
<span class="linecomment">;;  ** Using Regexps With Icicles Search **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use Icicles search to find text entities of a certain kind</span>
<span class="linecomment">;;  - sentences, paragraphs, file names, URLs, and so on.  A</span>
<span class="linecomment">;;  convenient way to do this is to use `C-=' in the minibuffer</span>
<span class="linecomment">;;  (`icicle-insert-string-from-variable') to insert a predefined</span>
<span class="linecomment">;;  regexp that matches a particular kind of text entity.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, suppose you are in a mail client and you want to move</span>
<span class="linecomment">;;  between mail headers.  If you use a regexp that matches the header</span>
<span class="linecomment">;;  field you want (e.g. the sent date or sender) then Icicles search</span>
<span class="linecomment">;;  highlights all such occurrences and lets you navigate among them -</span>
<span class="linecomment">;;  instant mail browser!  Or, suppose you are in a C++ or Perl file</span>
<span class="linecomment">;;  and you want to navigate among function definitions or other</span>
<span class="linecomment">;;  definitions.  If you have a canned regexp that matches the start</span>
<span class="linecomment">;;  of a definition, then you can use `C-=' to quickly turn</span>
<span class="linecomment">;;  `icicle-search' into a code browser.  In a log file, navigate</span>
<span class="linecomment">;;  among date or time entries or IP addresses...  Of course, most</span>
<span class="linecomment">;;  programming modes and mail clients already provide other ways to</span>
<span class="linecomment">;;  navigate, but you get the idea - Icicles search provides a general</span>
<span class="linecomment">;;  way to navigate among things, as long as you can match them with</span>
<span class="linecomment">;;  regexps, and `C-=' lets you quickly access a library of predefined</span>
<span class="linecomment">;;  regexps.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can find useful regexps to store in variables in the standard</span>
<span class="linecomment">;;  Emacs Lisp libraries.  Grep for `font-lock-keywords' or `regexp'</span>
<span class="linecomment">;;  in the Emacs `lisp' directory and its subdirectories.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   See `align.el' for regexps for programming languages.</span>
<span class="linecomment">;;   See `url-dav.el' for regexps matching ISO 8601 dates.</span>
<span class="linecomment">;;   See `rmail.el', `sendmail.el', and `mh-show.el' for regexps</span>
<span class="linecomment">;;   matching mail-header fields.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Imenu regexps occurring as parts of different values of</span>
<span class="linecomment">;;  `imenu-generic-expression' for different buffer types can be used</span>
<span class="linecomment">;;  as variable values for `C-='.  They all work fine with</span>
<span class="linecomment">;;  `icicle-search', turning it into a navigator for the given mode.</span>
<span class="linecomment">;;  See, for example, `generic-x.el' and `lisp-mode.el'.  Here is a</span>
<span class="linecomment">;;  regexp for Javascript function definitions from `generic-x.el':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   "^function\\s-+\\([A-Za-z0-9_]+\\)"</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And `lisp-imenu-generic-expression' (in `lisp-mode.el') provides</span>
<span class="linecomment">;;  regexps for Lisp function, variable, and type definitions.  Here</span>
<span class="linecomment">;;  is the variable-definition regexp:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   "^\\s-*(\\(def\\(c\\(onst\\(ant\\)?\\|ustom\\)\\|ine-symbol-macro</span>
<span class="linecomment">;;   \\|parameter\\|var\\)\\)\\s-+\\(\\(\\sw\\|\\s_\\)+\\)"</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You certainly don't want to type a regexp like that into the</span>
<span class="linecomment">;;  minibuffer (and the function-definition regexp is twice as</span>
<span class="linecomment">;;  complex)!  Put it into a variable once and use `C-=' from then on</span>
<span class="linecomment">;;  to retrieve it - simple.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If it's so simple, then why not let a command do it?  This is</span>
<span class="linecomment">;;  exactly what command `icicle-imenu' (bound to `C-c =') does.  You</span>
<span class="linecomment">;;  don't need to bother looking up Imenu regexps and assigning them</span>
<span class="linecomment">;;  to variables for use with `C-=' and `icicle-search'-</span>
<span class="linecomment">;;  `icicle-imenu' does that for you automatically.</span>
<span class="linecomment">;;  See (@&gt; "Other Icicles Search Commands").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In sum: For complete interactivity, type a regexp dynamically as</span>
<span class="linecomment">;;  input to `icicle-search'.  For isolated special regexps that you</span>
<span class="linecomment">;;  use, save them in variables and use `C-=' with `icicle-search'.</span>
<span class="linecomment">;;  For well-defined sets of regexps, especially if used frequently,</span>
<span class="linecomment">;;  define a command that uses `icicle-search'.  There is a spectrum</span>
<span class="linecomment">;;  of use cases for `icicle-search'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-search' is very general and very powerful.  It</span>
<span class="linecomment">;;  might never replace incremental search - either regexp or literal</span>
<span class="linecomment">;;  string search, but in some cases it can be quite handy.  Think of</span>
<span class="linecomment">;;  it as another tool to add to your search-tool belt.  Admittedly,</span>
<span class="linecomment">;;  it does take a little getting used to.  Remember, in particular,</span>
<span class="linecomment">;;  that the initial, context regexp you enter (with `RET') cannot be</span>
<span class="linecomment">;;  changed without re-executing `icicle-search'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And remember too that `C-l' (`icicle-retrieve-previous-input') is</span>
<span class="linecomment">;;  your friend - it clears the minibuffer during cycling, retrieving</span>
<span class="linecomment">;;  your last real input.  Use it to modify your second and subsequent</span>
<span class="linecomment">;;  regexps on the fly - those that filter the initial candidate list</span>
<span class="linecomment">;;  further.  You can repeat `C-l' to retrieve older completion</span>
<span class="linecomment">;;  inputs, and you can use `C-S-l' (that is, `C-L') to cycle previous</span>
<span class="linecomment">;;  inputs in the other direction.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "History Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Oh - And don't forget that you can do things like take the</span>
<span class="linecomment">;;  complement of your fine-tuning regexp matches, within the context</span>
<span class="linecomment">;;  of your coarse-tuning matches.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, use `^.*defun.*$' as the main regexp, to find all</span>
<span class="linecomment">;;  lines containing `defun'.  Then type `icicle' to match only the</span>
<span class="linecomment">;;  lines with `defun' that also contain `icicle'.  Then complement</span>
<span class="linecomment">;;  (`C-~') that set, to see the lines that contain `defun' but not</span>
<span class="linecomment">;;  `icicle'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And you can then save that set of matches, and then subtract it</span>
<span class="linecomment">;;  from another set of matches in a different search...  You get the</span>
<span class="linecomment">;;  idea.  When performing set operations combined with</span>
<span class="linecomment">;;  `icicle-search', keep in mind that the saved set does not include</span>
<span class="linecomment">;;  any position information - it is only a set of matching strings.</span>
<span class="linecomment">;;  So, in particular, a set-union operation (`C-+') is not useful</span>
<span class="linecomment">;;  with `icicle-search' (adding a saved set of strings without</span>
<span class="linecomment">;;  positions is useless).  Still, you can do things like match lines</span>
<span class="linecomment">;;  that contain `defun' followed somewhere by `()', and then subtract</span>
<span class="linecomment">;;  the (saved) set of lines in the same region that contain `icicle'.</span>
<span class="linecomment">;;  Try it in an Icicles library, using regexps `.*icicle.*$' and</span>
<span class="linecomment">;;  `^*.defun.*().*$'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One more reminder: When you save a set of completion candidates</span>
<span class="linecomment">;;  (`C-M-&gt;'), make sure that you actually have a set of candidates to</span>
<span class="linecomment">;;  save!  It is not enough to just enter a regexp at the</span>
<span class="linecomment">;;  `icicle-search' prompt.  You must also use some Icicles command,</span>
<span class="linecomment">;;  such as `TAB', `S-TAB', `next', or `down' to tell Icicles how to</span>
<span class="linecomment">;;  create the candidate set - how to match the regexp.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The doc string (`C-h f') of command `icicle-search'; it provides</span>
<span class="linecomment">;;    general information about Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Other Icicles Search Commands") for specialized Icicles</span>
<span class="linecomment">;;    search commands `icicle-comint-search',</span>
<span class="linecomment">;;    `icicle-compilation-search', `icicle-imenu',</span>
<span class="linecomment">;;    `icicle-imenu-command', `icicle-imenu-non-interactive-function',</span>
<span class="linecomment">;;    `icicle-search-keywords', `icicle-search-char-property',</span>
<span class="linecomment">;;    `icicle-search-keywords', `icicle-search-overlay-property', and</span>
<span class="linecomment">;;    `icicle-search-text-property'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Search and Replace") for information about replacing search</span>
<span class="linecomment">;;    hits or parts of search hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Customization and General Tips") for information about the</span>
<span class="linecomment">;;    `icicle-search-*' faces, which control Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Progressive Completion")</span>
<span class="linecomment">;;    for information about `M-*' and `M-&'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Multi-Commands") for</span>
<span class="linecomment">;;    information about `C-RET', `C-mouse-2', `C-next', and `C-prior'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Multiple Regions") for information about searching multiple</span>
<span class="linecomment">;;    regions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Inserting a Regexp from a Variable")</span>
<span class="linecomment">;;    for more about `C-='.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Info Enhancements") for information about using</span>
<span class="linecomment">;;    Icicles to search in Info mode.</span>
 
<span class="linecomment">;;(@* "Search and Replace")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Search and Replace</span>
<span class="linecomment">;;  ------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can replace the current search match by using any of the</span>
<span class="linecomment">;;  alternative action keys: `C-S-RET', `C-S-mouse-2' (in</span>
<span class="linecomment">;;  `*Completions*'), `C-S-next', `C-S-prior', `C-S-down', and</span>
<span class="linecomment">;;  `C-S-up'.  You can use `C-|' (`icicle-all-candidates-alt-action')</span>
<span class="linecomment">;;  to replace all matches at once.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  At the first use of any of these, you are prompted for the</span>
<span class="linecomment">;;  replacement string; it is used thereafter, or until you use `M-,'</span>
<span class="linecomment">;;  (`icicle-search-define-replacement').  You can use `M-,' at any</span>
<span class="linecomment">;;  time during searching to change the string for subsequent</span>
<span class="linecomment">;;  replacements.  The replacement string can be anything that is</span>
<span class="linecomment">;;  allowed as a replacement by `query-replace-regexp'.  In Emacs 22</span>
<span class="linecomment">;;  or later, this includes Lisp sexp evaluation via `\,'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Unlike `query-replace', you need not visit each search match - you</span>
<span class="linecomment">;;  can visit and replace selected matches in any order.  Some other</span>
<span class="linecomment">;;  differences from standard `query-replace' and</span>
<span class="linecomment">;;  `query-replace-regexp':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * Replacing matches of your current input provides a contextual</span>
<span class="linecomment">;;     replacement feature: replace `foo' by `fu', but only in zones</span>
<span class="linecomment">;;     that match `toto.*titi'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * Icicles search navigation lets you replace individual search</span>
<span class="linecomment">;;     hits without navigating through each search context in turn:</span>
<span class="linecomment">;;     direct access.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * Replace-all (`C-|') means replace all matches of your current</span>
<span class="linecomment">;;     input, throughout the search space, not just all matches that</span>
<span class="linecomment">;;     follow the cursor.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * You can act across multiple buffers, files, or saved regions -</span>
<span class="linecomment">;;     see information about the prefix arg.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * You can also replace matches within character-property search</span>
<span class="linecomment">;;     contexts - just use `icicle-search-char-property' (`C-c "') ["]</span>
<span class="linecomment">;;     as the search command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Search matches are replaced - but what is meant by a "search</span>
<span class="linecomment">;;  match"?  It can be either an entire search context or whatever</span>
<span class="linecomment">;;  your current minibuffer input matches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During search and replace:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * `M-,' redefines the replacement string.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * `C-`' toggles `icicle-toggle-regexp-quote' (as always).  This</span>
<span class="linecomment">;;     escapes regexp special characters, so that search is literal.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * `M-q' toggles `icicle-search-whole-word-flag'.  By default,</span>
<span class="linecomment">;;     this is nil, meaning that searching is not for whole words</span>
<span class="linecomment">;;     (except for `icicle-search-word', bound to `C-c $').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * `C-M-`' toggles `icicle-search-replace-literally-flag'.  By</span>
<span class="linecomment">;;      default, this is nil, which means that `\' character sequences</span>
<span class="linecomment">;;      in replacement text are intrepreted as for</span>
<span class="linecomment">;;      `query-replace-regexp'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * `C-,' toggles `icicle-search-replace-whole-candidate-flag'.  By</span>
<span class="linecomment">;;     default, this is non-nil, which means that the entire current</span>
<span class="linecomment">;;     search context is replaced.  The search context is whatever</span>
<span class="linecomment">;;     matches the context regexp that you entered initially, using</span>
<span class="linecomment">;;     `RET'.  However, you can use `C-,' at any time during searching</span>
<span class="linecomment">;;     to toggle between this default behavior and replacement of</span>
<span class="linecomment">;;     whatever your current minibuffer input matches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * `M-;' toggles `icicle-search-replace-common-match-flag'.</span>
<span class="linecomment">;;     Together with other options, it controls whether to replace the</span>
<span class="linecomment">;;     expanded common match or just the exact match.  See below.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Remember this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - If `icicle-search-replace-whole-candidate-flag' is non-nil, then</span>
<span class="linecomment">;;    the granularity of replacement is a complete search context.  In</span>
<span class="linecomment">;;    this case, replacement behaves similarly to</span>
<span class="linecomment">;;    `query-replace-regexp'.  You can still use minibuffer input to</span>
<span class="linecomment">;;    filter the set of search contexts, but replacement is on a</span>
<span class="linecomment">;;    whole-context basis.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - If `icicle-search-replace-whole-candidate-flag' is nil, then you</span>
<span class="linecomment">;;    can replace multiple input matches separately within a search</span>
<span class="linecomment">;;    context.  This behavior is unique to Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If `icicle-search-replace-whole-candidate-flag' is non-nil, then</span>
<span class="linecomment">;;  you can use the navigational alternative action keys, `C-S-next',</span>
<span class="linecomment">;;  `C-S-prior', `C-S-down', and `C-S-up', to replace successive</span>
<span class="linecomment">;;  search contexts.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Search traversal using these keys is always by search context, not</span>
<span class="linecomment">;;  by input match.  This means that you cannot use these keys to</span>
<span class="linecomment">;;  replace individual input matches within a search context, except</span>
<span class="linecomment">;;  for the first such match.  That is, if</span>
<span class="linecomment">;;  `icicle-search-replace-whole-candidate-flag' is nil and you use</span>
<span class="linecomment">;;  these keys, then only the first match of your input in each search</span>
<span class="linecomment">;;  context is replaced.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If your input matches multiple parts of the search context, and</span>
<span class="linecomment">;;  you want to replace them in order, then use `C-S-RET' repeatedly.</span>
<span class="linecomment">;;  This replaces successive input matches within a search context,</span>
<span class="linecomment">;;  then moves on to the next context, and so on.  You can traverse</span>
<span class="linecomment">;;  all matches of your input in the order they appear in the buffer</span>
<span class="linecomment">;;  by repeating `C-S-RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Repeated use of `C-S-RET' is generally for the case where you are</span>
<span class="linecomment">;;  replacing input matches, not whole search contexts.  If you repeat</span>
<span class="linecomment">;;  `C-S-RET' when `icicle-search-replace-whole-candidate-flag' is</span>
<span class="linecomment">;;  non-nil, then you will, in effect, just replace the same context</span>
<span class="linecomment">;;  over and over - unless, that is, your current input does not match</span>
<span class="linecomment">;;  the replacement text.  In that case, the replacement is no longer</span>
<span class="linecomment">;;  a matching search context (candidate), and `C-S-RET' moves on to</span>
<span class="linecomment">;;  the next context.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What your input matches depends on a few Icicles options:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - `icicle-regexp-quote-flag' determines whether to use regexp</span>
<span class="linecomment">;;    matching or literal matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - `icicle-search-highlight-all-current-flag',</span>
<span class="linecomment">;;    `icicle-expand-input-to-common-match-flag' and</span>
<span class="linecomment">;;    `icicle-search-replace-common-match-flag' together determine</span>
<span class="linecomment">;;    whether to replace exactly what your input matches in the</span>
<span class="linecomment">;;    current search hit or the expanded common match (ECM) of your</span>
<span class="linecomment">;;    input among all search hits.  If any of these options is nil,</span>
<span class="linecomment">;;    then your exact input match is replaced; otherwise, the ECM is</span>
<span class="linecomment">;;    replaced.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What is meant by a "search match" ... revisited - Here's another</span>
<span class="linecomment">;;  oddity of Icicles search-and-replace: Your search matches remain</span>
<span class="linecomment">;;  defined as the set of search contexts that match your current</span>
<span class="linecomment">;;  input, even after you have made replacements.  And the set of</span>
<span class="linecomment">;;  search contexts that can be matched doesn't change.  It is the</span>
<span class="linecomment">;;  original set of matches of your context regexp - these matches are</span>
<span class="linecomment">;;  not recomputed during an `icicle-search' invocation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, if you empty the minibuffer, then all of the search</span>
<span class="linecomment">;;  contexts are shown in *Completions*.  Their text is updated to</span>
<span class="linecomment">;;  reflect any replacements you have made, but they are all there.</span>
<span class="linecomment">;;  It is only your current input that filters them, as always.  This</span>
<span class="linecomment">;;  means that you can revisit any replacements you have made, in any</span>
<span class="linecomment">;;  order.  You can even use `M-,' to alter some of them, if you like.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Search Commands, Overview") and the doc string of</span>
<span class="linecomment">;;    `icicle-search' for more information about search-and-replace.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Compile/Grep Search") for information about using</span>
<span class="linecomment">;;    search-and-replace with `grep' buffers and compilation buffers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@* "Icicles Dired Enhancements") for information about using</span>
<span class="linecomment">;;    search-and-replace on marked files in Dired.</span>
 
<span class="linecomment">;;(@* "Other Icicles Search Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Other Icicles Search Commands</span>
<span class="linecomment">;;  -----------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Function `icicle-search' is very general.  As is explained in</span>
<span class="linecomment">;;  (@&gt; "Icicles Search Commands, Overview"), command `icicle-occur'</span>
<span class="linecomment">;;  is defined trivially using `icicle-search' - it is basically</span>
<span class="linecomment">;;  `icicle-search' with a regexp of `.*', to match lines.  Similarly,</span>
<span class="linecomment">;;  `icicle-search-word' (`C-c $') uses a regexp of `\bWORD\b', where</span>
<span class="linecomment">;;  `WORD' is the word to look for, and `icicle-search-keywords'</span>
<span class="linecomment">;;  (`C-c ^') uses a regexp of `\(KW1\|KW2\|KW2...\|KWn\)', where the</span>
<span class="linecomment">;;  `KWm' are the keywords (regexps) to look for.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Still other Icicles commands are available that make use of</span>
<span class="linecomment">;;  `icicle-search'.  And you can define your own, specialized search</span>
<span class="linecomment">;;  commands along the same lines.  To do that, it is instructive to</span>
<span class="linecomment">;;  look at the source code of the commands described in this section;</span>
<span class="linecomment">;;  they can serve as a model for defining your own search commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Two of the commands described here, `icicle-compilation-search'</span>
<span class="linecomment">;;  and `icicle-comint-search', are specialized versions of</span>
<span class="linecomment">;;  `icicle-search' that work only in particular buffers where there</span>
<span class="linecomment">;;  is little need for `icicle-search' itself. For this reason, these</span>
<span class="linecomment">;;  commands reuse the key sequence, `C-c `' (backquote), that is</span>
<span class="linecomment">;;  normally bound to `icicle-search'.  This shadow binding occurs if</span>
<span class="linecomment">;;  the current major mode is a compilation mode (for</span>
<span class="linecomment">;;  `icicle-compilation-search') or an interactive interpreter mode</span>
<span class="linecomment">;;  such as `shell-mode' or Lisp interactive mode (for</span>
<span class="linecomment">;;  `icicle-comint-search').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  [Programmer Note: Actually, the way this works is that `C-c `' is</span>
<span class="linecomment">;;  bound to the value of internal variable `icicle-search-generic'.</span>
<span class="linecomment">;;  You can use this mechanism to provide custom Icicles search</span>
<span class="linecomment">;;  commands for particular buffers.]</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Besides the commands described in this section, there are Icicles</span>
<span class="linecomment">;;  search commands for navigating tags-file definitions and searching</span>
<span class="linecomment">;;  their associated source files.  These are described in section</span>
<span class="linecomment">;;  (@&gt; "Icicles Tags Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `M-g' in the minibuffer to toggle option</span>
<span class="linecomment">;;  `icicle-use-C-for-actions-flag', then you can use just `next'</span>
<span class="linecomment">;;  instead of `C-next' to navigate when using any Icicles search</span>
<span class="linecomment">;;  command.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Option `icicle-use-C-for-actions-flag'").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Searching Text with Properties")</span>
<span class="linecomment">;;  ** Searching Text with Properties **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Instead of providing a context regexp, for commands</span>
<span class="linecomment">;;  `icicle-search-char-property' (`C-c "') ["],</span>
<span class="linecomment">;;  `icicle-search-overlay-property', and</span>
<span class="linecomment">;;  `icicle-search-text-property' you provide a character property</span>
<span class="linecomment">;;  (e.g. `face') and its value (e.g. `font-lock-function-name-face').</span>
<span class="linecomment">;;  All zones of text that have that property with that value become</span>
<span class="linecomment">;;  the completion candidates (search hits).  As always, you can</span>
<span class="linecomment">;;  filter this set of candidates by typing input in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By a "character property" is meant either a text property or an</span>
<span class="linecomment">;;  overlay property.  `C-c "' ["] searches both kinds of character</span>
<span class="linecomment">;;  property; `icicle-search-overlay-property' searches only overlay</span>
<span class="linecomment">;;  properties; and `icicle-search-text-property' searches only text</span>
<span class="linecomment">;;  properties.  For example, if you use `C-c "' ["] with a `face'</span>
<span class="linecomment">;;  property value `highlight', then the text searched includes text</span>
<span class="linecomment">;;  with that overlay value and text with that text-property value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If the property chosen is `face', then you can in fact choose</span>
<span class="linecomment">;;  multiple faces, in multi-command fashion (e.g. `C-mouse-2'), and</span>
<span class="linecomment">;;  the text that is searched has at least one of the faces you</span>
<span class="linecomment">;;  choose.  If you choose no face value (empty input), then the</span>
<span class="linecomment">;;  target is text that has any face at all.  The search hits are</span>
<span class="linecomment">;;  zones of text that are distinguished by their `face' values.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As with other Icicles search commands, a prefix argument controls</span>
<span class="linecomment">;;  whether these character-property commands search the current</span>
<span class="linecomment">;;  buffer, saved regions, selected files, or selected buffers.</span>
<span class="linecomment">;;  However, keep in mind that, since in this case you are searching</span>
<span class="linecomment">;;  character properties, you will find search hits only for buffers</span>
<span class="linecomment">;;  that already have such properties, for example, buffers that have</span>
<span class="linecomment">;;  been fontified.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicles Imenu")</span>
<span class="linecomment">;;  ** Icicles Imenu **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-imenu', which is bound to `C-c =', is an Imenu</span>
<span class="linecomment">;;  browser.  It lets you use Icicles completion to navigate among</span>
<span class="linecomment">;;  definitions of functions, variables, types, keys, and so on in a</span>
<span class="linecomment">;;  programming language (in fact, any language that Imenu handles).</span>
<span class="linecomment">;;  As always in Icicles, your current input (e.g. a regexp) filters</span>
<span class="linecomment">;;  the set of available candidates.  That is, you can match against</span>
<span class="linecomment">;;  parts of an Imenu entry - any parts.  That's particularly useful</span>
<span class="linecomment">;;  if there are many entries in the Imenu menu; you don't need to</span>
<span class="linecomment">;;  read/scan the whole list.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you look at the definition of `icicle-imenu' you'll see that it</span>
<span class="linecomment">;;  simply lets you choose an Imenu submenu (Functions, User Options,</span>
<span class="linecomment">;;  and so on) that is appropriate for the current buffer type, and</span>
<span class="linecomment">;;  then it calls `icicle-search', passing it the appropriate Imenu</span>
<span class="linecomment">;;  regexp.  You can similarly define your own specialized search</span>
<span class="linecomment">;;  commands using `icicle-search' to browse regexp matches.  You get</span>
<span class="linecomment">;;  all of the features of `icicle-search' when you do that.  For</span>
<span class="linecomment">;;  example, `icicle-imenu' gives you these advantages over a standard</span>
<span class="linecomment">;;  Imenu menu:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can restrict navigation (search) to a region.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can navigate (browse) among multiple entries, instead of</span>
<span class="linecomment">;;    choosing them one by one from a menu.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can restrict the entries to browse using (regexp) pattern</span>
<span class="linecomment">;;    matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * As for `icicle-search', you can search multiple saved regions,</span>
<span class="linecomment">;;    multiple buffers, or multiple files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, for Emacs-Lisp function definitions, Icicles provides</span>
<span class="linecomment">;;  two specializations of `icicle-imenu', to find only Emacs command</span>
<span class="linecomment">;;  definitions and only non-interactive function (that is,</span>
<span class="linecomment">;;  non-command) definitions: `icicle-imenu-command' and</span>
<span class="linecomment">;;  `icicle-imenu-non-interactive-function'.  The definitions of these</span>
<span class="linecomment">;;  two search commands provide examples of using `icicle-search' with</span>
<span class="linecomment">;;  a predicate argument.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`icicle-imenu' Combines Benefits of Imenu and Emacs Tags")</span>
<span class="linecomment">;;  *** `icicle-imenu' Combines Benefits of Imenu and Emacs Tags ***</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Imenu lets you navigate among definitions in a single buffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Emacs tags let you navigate among definitions in multiple files,</span>
<span class="linecomment">;;    but you must build and update the tags file that identifies the</span>
<span class="linecomment">;;    definitions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Like Emacs tags, `icicle-imenu' lets you navigate among</span>
<span class="linecomment">;;  definitions in multiple files - and also multiple saved regions</span>
<span class="linecomment">;;  and non-file buffers.  Like Imenu, you need not build a tags file.</span>
<span class="linecomment">;;  Unlike Imenu, Icicles provides regexp completion that lets you</span>
<span class="linecomment">;;  filter Imenu hits that you want to visit.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another difference from Emacs tags, besides the need for a tags</span>
<span class="linecomment">;;  file, is that, since Icicles locates definitions using Imenu</span>
<span class="linecomment">;;  regexps, you can only navigate among definitions in buffers that</span>
<span class="linecomment">;;  you are visiting.  This is both an advantage and a disadvantage:</span>
<span class="linecomment">;;  you can narrow the search to certain files, but you must know</span>
<span class="linecomment">;;  which files to search. And if you want to search all files, then</span>
<span class="linecomment">;;  you must open them all (e.g. by matching a project regexp),</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The differences mean that `icicle-imenu' does not provide a</span>
<span class="linecomment">;;  substitute for Emacs tags; it provides some similar</span>
<span class="linecomment">;;  functionality. It is another tool in your belt, handier in some</span>
<span class="linecomment">;;  situations than using tags, and less useful in some other</span>
<span class="linecomment">;;  situations.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: (@&gt; "Icicles Tags Enhancements")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Compile/Grep Search")</span>
<span class="linecomment">;;  ** Compile/Grep Search **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In a compilation-results buffer, such as `*Compilation* or</span>
<span class="linecomment">;;  `*grep*', you can use command `icicle-compilation-search', bound</span>
<span class="linecomment">;;  to `C-c `', to search among the result set (search hits).  This is</span>
<span class="linecomment">;;  similar to `icicle-search', but when you use `C-RET', `C-mouse-2',</span>
<span class="linecomment">;;  `C-prior', `C-next', `C-up', or `C-down', it visits the source</span>
<span class="linecomment">;;  code that corresponds to the current line in the compilation</span>
<span class="linecomment">;;  buffer.  Just as for `icicle-search', you can narrow the set of</span>
<span class="linecomment">;;  search contexts by typing a regexp.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Using `icicle-compilation-search' with `grep' gives you two levels</span>
<span class="linecomment">;;  of regexp searching: 1) the `grep' regexp and 2) your current</span>
<span class="linecomment">;;  input regexp.  And you can of course use progressive completion</span>
<span class="linecomment">;;  (`M-*') to add any number of additional levels.  (And, starting</span>
<span class="linecomment">;;  with Emacs 22, you can pipe to other `grep' commands in the same</span>
<span class="linecomment">;;  `M-x grep'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Emacs 22 and later, you can also replace search-hit text.  You</span>
<span class="linecomment">;;  can replace the entire grep regexp match or just the part of it</span>
<span class="linecomment">;;  that matches your current input, depending on the value of option</span>
<span class="linecomment">;;  `icicle-search-replace-whole-candidate-flag' (which you can toggle</span>
<span class="linecomment">;;  with `C-,').  Replacement acts here just as it does for</span>
<span class="linecomment">;;  `icicle-search'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also use a non-`grep' compilation buffer to perform search</span>
<span class="linecomment">;;  and replace.  Use it, for example, to correct errors in source</span>
<span class="linecomment">;;  files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles thus gives you several ways to perform search-and-replace</span>
<span class="linecomment">;;  throughout multiple files: `grep'/compilation, `icicle-occur', and</span>
<span class="linecomment">;;  `icicle-search'.  The latter is of course not limited to</span>
<span class="linecomment">;;  line-by-line search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: (@&gt; "Search and Replace").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Input Reuse in Interactive Interpreter Modes")</span>
<span class="linecomment">;;  ** Input Reuse in Interactive Interpreter Modes **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In an interactive interpreter mode such as `shell-mode' or</span>
<span class="linecomment">;;  interactive Lisp mode, you can search for and reuse a previous</span>
<span class="linecomment">;;  input, possibly editing it first.  Command `icicle-comint-search',</span>
<span class="linecomment">;;  bound to `C-c `', lets you use Icicles completion and cycling to</span>
<span class="linecomment">;;  access your previous (shell or Lisp) inputs; it uses</span>
<span class="linecomment">;;  `icicle-search', so it highlights your regexp input matches, and</span>
<span class="linecomment">;;  so on.  You can use `C-$' at any time to toggle removal of</span>
<span class="linecomment">;;  duplicate past inputs as completion candidates; by default,</span>
<span class="linecomment">;;  duplicates are removed.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Being a search command, however, `icicle-comint-search' has access</span>
<span class="linecomment">;;  only to the commands that are visible in the buffer.  It does not</span>
<span class="linecomment">;;  use the `comint-input-ring', so it cannot, for instance, give you</span>
<span class="linecomment">;;  access to commands used in a previous session, which might have</span>
<span class="linecomment">;;  been recorded in a history file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another Icicles command, `icicle-comint-command', which is not a</span>
<span class="linecomment">;;  search command, does use `comint-input-ring' and does give you</span>
<span class="linecomment">;;  completion and cycling against previous inputs that might not have</span>
<span class="linecomment">;;  come from the current session.  It is bound to `C-c TAB' in</span>
<span class="linecomment">;;  `comint-mode' and derived modes.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Define Your Own Icicles Search Commands")</span>
<span class="linecomment">;;  ** Define Your Own Icicles Search Commands **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Function `icicle-search' is not only a useful user command; it is</span>
<span class="linecomment">;;  also a framework for you to define your own Icicles search</span>
<span class="linecomment">;;  commands.  Consult the source code for the commands presented</span>
<span class="linecomment">;;  above for models.  And consult the doc string of `icicle-search'</span>
<span class="linecomment">;;  for more information about calling it non-interactively.  In</span>
<span class="linecomment">;;  particular, note that:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can pass a functional argument instead of a regexp to</span>
<span class="linecomment">;;    `icicle-search', and it will use that function to define the</span>
<span class="linecomment">;;    search contexts.  The function is passed, as arguments, the</span>
<span class="linecomment">;;    buffer to search, the beginning and end of the search region in</span>
<span class="linecomment">;;    that buffer, and any additional arguments that you pass to</span>
<span class="linecomment">;;    `icicle-search'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can pass a predicate argument to `icicle-search', in</span>
<span class="linecomment">;;    addition to passing a regexp, and the search contexts will be</span>
<span class="linecomment">;;    only those regexp matches that also satisfy the predicate.  The</span>
<span class="linecomment">;;    predicate takes two arguments, the search-context string and a</span>
<span class="linecomment">;;    marker at the end of the search context.  For information about</span>
<span class="linecomment">;;    this, consult the doc string for function</span>
<span class="linecomment">;;    `icicle-search-regexp-scan'.  For a model of using this feature,</span>
<span class="linecomment">;;    see the code that defines command `icicle-imenu'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By using your own function to define the search contexts, either</span>
<span class="linecomment">;;  from scratch or by limiting regexp matches using a predicate, you</span>
<span class="linecomment">;;  can perform semantic-based searching.  That is, your search</span>
<span class="linecomment">;;  command can use information besides syntax to define search hits.</span>
<span class="linecomment">;;  For instance, commands `icicle-imenu-command' and</span>
<span class="linecomment">;;  `icicle-imenu-non-interactive-function' use the semantic predicate</span>
<span class="linecomment">;;  `commandp' to distinguish Emacs-Lisp commands from non-interactive</span>
<span class="linecomment">;;  functions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Search Commands, Overview") for general information</span>
<span class="linecomment">;;    about Icicles search and the commands `icicle-search' and</span>
<span class="linecomment">;;    `icicle-occur'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Search and Replace") for information about replacing search</span>
<span class="linecomment">;;    hits or parts of search hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Multi-Commands") for</span>
<span class="linecomment">;;    information about using `C-RET', `C-mouse-2', `C-prior',</span>
<span class="linecomment">;;    `C-next', `C-up', and `C-down'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Progressive Completion")</span>
<span class="linecomment">;;    for information about using any number of search regexps with</span>
<span class="linecomment">;;    `M-*' and any number of search predicates with `M-&'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Info Enhancements") for information about using</span>
<span class="linecomment">;;    Icicles with Info mode.</span>
 
<span class="linecomment">;;(@* "Multiple Regions")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Multiple Regions</span>
<span class="linecomment">;;  ----------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles lets you define multiple regions, which you can then act</span>
<span class="linecomment">;;  on individually or together.  The regions can be in any buffers:</span>
<span class="linecomment">;;  any number of regions in any number of buffers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The multiple Icicles regions are saved persistently in user option</span>
<span class="linecomment">;;  `icicle-region-alist'.  You can customize this option directly,</span>
<span class="linecomment">;;  but it is usually easier and less error-prone to define the list</span>
<span class="linecomment">;;  of regions incrementally, using command `icicle-add-region' (`C-N</span>
<span class="linecomment">;;  C-x C-x', for N = 0,1,2,...), which adds the current Emacs region</span>
<span class="linecomment">;;  to `icicle-region-alist'.  You can remove one or more regions from</span>
<span class="linecomment">;;  `icicle-region-alist', using command `icicle-remove-region' or by</span>
<span class="linecomment">;;  customizing the option.  You can remove all regions in a given</span>
<span class="linecomment">;;  buffer, using command `icicle-remove-all-regions-in-buffer'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use multi-command `icicle-select-region' (`C-u C-x C-x) to</span>
<span class="linecomment">;;  choose any region in `icicle-region-alist', navigate to it, and</span>
<span class="linecomment">;;  activate it.  You can use this as a sort of bookmark mechanism,</span>
<span class="linecomment">;;  retrieving saved regions later for operations in different Emacs</span>
<span class="linecomment">;;  sessions.  Unlike Emacs bookmarks, Icicles regions are not limited</span>
<span class="linecomment">;;  to being in file buffers - any buffer can be used.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also think of Icicles region definition and selection as a</span>
<span class="linecomment">;;  kind of tagging mechanism.  You can assign any identifying tag,</span>
<span class="linecomment">;;  and you can assign the same tag to multiple regions, whether they</span>
<span class="linecomment">;;  are in the same buffer or in different buffers.  You can also</span>
<span class="linecomment">;;  assign multiple tags to the same region, but in that case there</span>
<span class="linecomment">;;  will be multiple entries for that region in `icicle-region-alist':</span>
<span class="linecomment">;;  each entry corresponds to a single tag and a single region.  The</span>
<span class="linecomment">;;  default tag proposed when you add a region to</span>
<span class="linecomment">;;  `icicle-region-alist' is the first</span>
<span class="linecomment">;;  `icicle-regions-name-length-max' characters of the region itself.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The tag text is not added to your buffers.  It is recorded,</span>
<span class="linecomment">;;  together with the region limits, the buffer name, and the buffer's</span>
<span class="linecomment">;;  associated file name, in variable `icicle-region-alist'.  Each</span>
<span class="linecomment">;;  region is defined by its recorded limits.  Its tag is used only to</span>
<span class="linecomment">;;  identify it as a completion candidate.  This means that if a</span>
<span class="linecomment">;;  region tag was defined as the text at the beginning of the region</span>
<span class="linecomment">;;  (the default tag value), and you have changed the region's buffer</span>
<span class="linecomment">;;  (inserting or deleting text) since that definition, then the tag</span>
<span class="linecomment">;;  might no longer correspond exactly to the current region prefix.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For commands such as `icicle-select-region' that use</span>
<span class="linecomment">;;  `icicle-region-alist', there is generally little sense in using</span>
<span class="linecomment">;;  regions as completion candidates if they are in buffers that no</span>
<span class="linecomment">;;  longer exist and are not associated with files.  For this reason,</span>
<span class="linecomment">;;  such regions are filtered out for completion.  They remain</span>
<span class="linecomment">;;  recorded in `icicle-region-alist', however, and if a non-existent</span>
<span class="linecomment">;;  buffer is re-created, then it will once again be available as a</span>
<span class="linecomment">;;  completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Buffers associated with files are an important special case: the</span>
<span class="linecomment">;;  files can be opened, re-creating the buffers, and then the regions</span>
<span class="linecomment">;;  can be accessed.  For this reason, buffers associated with files</span>
<span class="linecomment">;;  are always made available as completion candidates.  When you</span>
<span class="linecomment">;;  choose such a candidate, the file is automatically visited,</span>
<span class="linecomment">;;  provided it is readable.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to this automatic opening of individual files on</span>
<span class="linecomment">;;  demand, you can at any time open all of the (readable) files</span>
<span class="linecomment">;;  listed in `icicle-region-alist', using command</span>
<span class="linecomment">;;  `icicle-region-open-all-files'.  And, if user option</span>
<span class="linecomment">;;  `icicle-region-auto-open-files-flag' is non-nil, then all files</span>
<span class="linecomment">;;  listed in `icicle-region-alist' are visited automatically, as soon</span>
<span class="linecomment">;;  as you invoke any Icicles command that uses that alist.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicle mode, `C-x C-x' is bound to command</span>
<span class="linecomment">;;  `icicle-exchange-point-and-mark'.  With no prefix argument, this</span>
<span class="linecomment">;;  is the same as `exchange-point-and-mark': it swaps the position of</span>
<span class="linecomment">;;  the text cursor and the mark and activates the region.  With a</span>
<span class="linecomment">;;  numeric prefix argument, this is the same as `icicle-add-region':</span>
<span class="linecomment">;;  it adds the current region to `icicle-region-alist'.  With a plain</span>
<span class="linecomment">;;  `C-u' prefix argument, this is the same as `icicle-select-region'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can search any region in `icicle-region-alist' using command</span>
<span class="linecomment">;;  `icicle-search-region'.  Because this is a multi-command, you can</span>
<span class="linecomment">;;  search any number of the regions, one at a time.  You can also</span>
<span class="linecomment">;;  search through all of the regions at once, using a special feature</span>
<span class="linecomment">;;  of command `icicle-search' (`C-c `').  Provide a numeric prefix</span>
<span class="linecomment">;;  argument to `icicle-search' (e.g. `C-9 C-c `'), and the regions in</span>
<span class="linecomment">;;  `icicle-region-alist' become the search space.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Commands `icicle-remove-region', `icicle-search-region', and</span>
<span class="linecomment">;;  `icicle-select-region' are multi-commands.  You can act on any</span>
<span class="linecomment">;;  number of regions using `C-RET' and so on.  Help on region</span>
<span class="linecomment">;;  candidates (`C-M-RET' and so on) displays the following</span>
<span class="linecomment">;;  information about the candidate region, in the minibuffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   - its start and end positions in the buffer</span>
<span class="linecomment">;;   - its buffer</span>
<span class="linecomment">;;   - the buffer's associated file, if any</span>
<span class="linecomment">;;   - its length</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (Command `icicle-remove-all-regions-in-buffer' is also a</span>
<span class="linecomment">;;  multi-command, but its completion candidates are buffers, not</span>
<span class="linecomment">;;  regions.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For commands `icicle-select-region' and `icicle-search-region', if</span>
<span class="linecomment">;;  user option `icicle-add-buffer-name-flag' is non-nil (the default</span>
<span class="linecomment">;;  value), then each region-name candidate is annotated with the name</span>
<span class="linecomment">;;  of the region's buffer, highlighted, to help orient you.  The</span>
<span class="linecomment">;;  buffer name is actually part of the (multi-completion) candidate,</span>
<span class="linecomment">;;  so you can match against it.  As mentioned, even when the value of</span>
<span class="linecomment">;;  `icicle-add-buffer-name-flag' is nil, you can use `C-M-mouse-2'</span>
<span class="linecomment">;;  and so on to see the candidate region's buffer name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Search Commands, Overview") for information about</span>
<span class="linecomment">;;    command `icicle-search'.</span>
 
<span class="linecomment">;;(@* "Icicles Tags Enhancements")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Tags Enhancements</span>
<span class="linecomment">;;  -------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Emacs and Icicles, the word "tag" is used in multiple ways.</span>
<span class="linecomment">;;  This section is about tags as identifiers of source-code</span>
<span class="linecomment">;;  definitions.  Emacs uses tags files, typically named `TAGS', to</span>
<span class="linecomment">;;  index these definition locations.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What constitutes a "definition" is determined by the content of</span>
<span class="linecomment">;;  the tags file.  Typically, definition recognition is available for</span>
<span class="linecomment">;;  programming languages, but in fact a tags table can record any</span>
<span class="linecomment">;;  text at all as a definition.  That is, if you create your own tags</span>
<span class="linecomment">;;  table, you can use the Emacs tags feature to navigate among any</span>
<span class="linecomment">;;  "definitions" of your own choosing.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `M-g' in the minibuffer to toggle option</span>
<span class="linecomment">;;  `icicle-use-C-for-actions-flag', then you can use just `next'</span>
<span class="linecomment">;;  instead of `C-next' to navigate when using any of the Icicles tags</span>
<span class="linecomment">;;  browsing commands described here.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Option `icicle-use-C-for-actions-flag'").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`icicle-find-tag': Find Tags in All Tags Tables")</span>
<span class="linecomment">;;  ** `icicle-find-tag': Find Tags in All Tags Tables **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In vanilla Emacs, you use commands such as `find-tag' (`M-.') to</span>
<span class="linecomment">;;  find a tag, `tags-loop-continue' (`M-,') to find another matching</span>
<span class="linecomment">;;  tag, `tags-apropos' to list all tags that match a regexp, and</span>
<span class="linecomment">;;  `list-tags' to show all tags (definitions) in a given source file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, you can use multi-command `icicle-find-tag', bound to</span>
<span class="linecomment">;;  `M-.' in Icicle mode, to do all of this.  It is similar to the</span>
<span class="linecomment">;;  Icicles search commands.  It is a general tags browser, just as</span>
<span class="linecomment">;;  `icicle-imenu' is an Imenu browser.  Being a multicommand, you can</span>
<span class="linecomment">;;  visit any number of tags, in any order, in a single `M-.'</span>
<span class="linecomment">;;  invocation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  With `icicle-find-tag', you enter (using `RET') a regexp to match</span>
<span class="linecomment">;;  the tags you want to visit.  By default, all tags in all tags</span>
<span class="linecomment">;;  files are searched, and the matches become completion candidates</span>
<span class="linecomment">;;  (which you can of course match further by typing another pattern).</span>
<span class="linecomment">;;  As always, you can use progressive completion, chip away the</span>
<span class="linecomment">;;  non-elephant, and so on.  Just as with Icicles search commands,</span>
<span class="linecomment">;;  you use `C-RET', `C-mouse-2', `C-next', and so on, to visit the</span>
<span class="linecomment">;;  search hits.  You can use `M-*' (`icicle-pop-mark') to return to</span>
<span class="linecomment">;;  the place you invoked `M-.'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, the completion candidates are multi-completions: the</span>
<span class="linecomment">;;  source file name is included.  This is an important aid, because</span>
<span class="linecomment">;;  there can be similar, or even identical, tags in different source</span>
<span class="linecomment">;;  files.  Your current input can of course filter the source-file</span>
<span class="linecomment">;;  name also, excluding certain files from the search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A prefix argument  changes the default behavior, as follows:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If non-negative (&gt;= 0), then only the current tag table is used,</span>
<span class="linecomment">;;    instead of all tag tables.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If non-positive (&lt;= 0), then the source file name is not part of</span>
<span class="linecomment">;;    the completion candidate; only the tag itself is used.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Search Commands, Overview") for general information</span>
<span class="linecomment">;;    about Icicles search commmands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Nutshell View of Icicles")</span>
<span class="linecomment">;;    for information about progressive completion and chipping away</span>
<span class="linecomment">;;    the non-elephant.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`icicle-find-first-tag': Find First Tag in Current Table")</span>
<span class="linecomment">;;  ** `icicle-find-first-tag': Find First Tag in Current Table **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sometimes you don't need the full power and flexibility of</span>
<span class="linecomment">;;  `icicle-find-tag'.  If you just want to find the first tag among</span>
<span class="linecomment">;;  several duplicates that match your input, and you just want to use</span>
<span class="linecomment">;;  the current tags table, then you can use `icicle-find-first-tag'</span>
<span class="linecomment">;;  or `icicle-find-first-tag-other-window'.  These commands are like</span>
<span class="linecomment">;;  vanilla `find-tag', but they are multi-commands, so you can visit</span>
<span class="linecomment">;;  any number of tags in one invocation.  Unlike `find-tag', however,</span>
<span class="linecomment">;;  you cannot follow up to find another tag that matches using `M-,'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`icicle-tags-search': Search and Replace Using Tags")</span>
<span class="linecomment">;;  ** `icicle-tags-search': Search and Replace Using Tags **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In vanilla Emacs, you use commands `tags-search',</span>
<span class="linecomment">;;  `tags-query-replace', and `tags-loop-continue' (`M-,') to search</span>
<span class="linecomment">;;  and replace text in source files whose definitions are indexed in</span>
<span class="linecomment">;;  a tags file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, you can use multi-command `icicle-tags-search' to</span>
<span class="linecomment">;;  search and replace.  It is in fact just command `icicle-search'</span>
<span class="linecomment">;;  applied to the relevant source files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also (@&gt; "Icicles Search Commands, Overview") for information</span>
<span class="linecomment">;;  about `icicle-search.</span>
 
<span class="linecomment">;;(@* "Icicles Shell-Command Enhancements")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Shell-Command Enhancements</span>
<span class="linecomment">;;  ----------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles provides completion support for shell commands in these</span>
<span class="linecomment">;;  ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * In Shell mode and related modes, it enhances completion of</span>
<span class="linecomment">;;    commands, previous inputs (commands plus their switches and</span>
<span class="linecomment">;;    arguments), file names, and environment variables.</span>
<span class="linecomment">;;    See (@&gt; "Completion in Comint Modes").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * In Dired mode, it provides completion for `!', and `&'.</span>
<span class="linecomment">;;    See (@&gt; "Shell Commands on Marked Files").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * In any buffer, it provides completion for `M-!' and `M-|'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section describes the completion available for `M-!' and</span>
<span class="linecomment">;;  `M-|'.  It applies also to completion for `!', and `&' in Dired</span>
<span class="linecomment">;;  (but those have additional enhancements).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In vanilla Emacs, when you enter a shell command at the prompt for</span>
<span class="linecomment">;;  `M-!' or `M-|', no completion is available.  In Icicle mode,</span>
<span class="linecomment">;;  file-name completion is available, so you can navigate to the</span>
<span class="linecomment">;;  executable file for the command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Shell-command completion is lax, so you can enter any command you</span>
<span class="linecomment">;;  want, not just a completion candidate, and you can edit completed</span>
<span class="linecomment">;;  input to add switches (options) and arguments.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  BTW - It's also worth reminding here that you can use `M-o'</span>
<span class="linecomment">;;  anytime in the minibuffer to complete against a previous input.</span>
<span class="linecomment">;;  This means that if you have previously entered some complex shell</span>
<span class="linecomment">;;  command (e.g. with various switches), then you can retrieve it for</span>
<span class="linecomment">;;  reuse (possibly editing it) using `M-o'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Though file-name completion is used for shell commands, extra,</span>
<span class="linecomment">;;  shell-command candidates are made available if you set option</span>
<span class="linecomment">;;  `icicle-guess-cmds-in-path-flag' to non-nil.  These extra</span>
<span class="linecomment">;;  candidates are the names of all executable files (or of all files,</span>
<span class="linecomment">;;  if `shell-completion-execonly' is nil) in your search path.  That</span>
<span class="linecomment">;;  is, they name all available program files (commands) in your</span>
<span class="linecomment">;;  current context.  (This list of commands is computed once and</span>
<span class="linecomment">;;  cached.  If your environment changes and you want to update the</span>
<span class="linecomment">;;  cached list, just toggle Icicle mode twice.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The fact that these are Icicles *extra* candidates means that they</span>
<span class="linecomment">;;  are available regardless of the current default-directory - they</span>
<span class="linecomment">;;  are not in fact treated as file-name candidates, even though they</span>
<span class="linecomment">;;  are available during file-name completion.  You can easily</span>
<span class="linecomment">;;  recognize Icicles extra candidates in buffer `*Completions*': they</span>
<span class="linecomment">;;  have face `icicle-extra-candidates'.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc2.el" :to "Global Filters")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, in contexts such as Dired where target (e.g. marked)</span>
<span class="linecomment">;;  files for the shell command are known, the extra candidates</span>
<span class="linecomment">;;  include shell commands (possibly including switches) that Icicles</span>
<span class="linecomment">;;  can guess might be appropriate for the target files.</span>
<span class="linecomment">;;  See (@&gt; "Shell Commands on Marked Files").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During shell-command completion, help is available for individual</span>
<span class="linecomment">;;  candidates, using `C-M-RET', `C-M-mouse-2', and so on.  For an</span>
<span class="linecomment">;;  extra candidate (that is, for a shell-command guess), help is</span>
<span class="linecomment">;;  provided by the `apropos' shell command (if available).  For a</span>
<span class="linecomment">;;  file name, help shows the file's properties.  (See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Get Help on Candidates").)</span>
 
<span class="linecomment">;;(@* "Icicles Dired Enhancements")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Dired Enhancements</span>
<span class="linecomment">;;  --------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles can help with Dired in these ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use completion when you use `!' or `&' to execute a</span>
<span class="linecomment">;;    shell command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use Icicles search-and-replace on the marked files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can save marked file names as completion candidates for</span>
<span class="linecomment">;;    reuse later.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can open Dired on saved file names, that is, names that you</span>
<span class="linecomment">;;    previously saved as a completion candidates set or as an Emacs</span>
<span class="linecomment">;;    fileset.  It does not matter how the file names were saved or</span>
<span class="linecomment">;;    which directories the files are in.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Shell Commands on Marked Files")</span>
<span class="linecomment">;;  ** Shell Commands on Marked Files **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicle mode, `!' and `&' in Dired let you complete a shell</span>
<span class="linecomment">;;  command.  All Icicles completion features are available.  This is</span>
<span class="linecomment">;;  the same program file completion that is available anywhere when a</span>
<span class="linecomment">;;  shell command is read (see</span>
<span class="linecomment">;;  (@&gt; "Icicles Shell-Command Enhancements")), but in Dired the extra</span>
<span class="linecomment">;;  candidate completions include shell commands that Icicles thinks</span>
<span class="linecomment">;;  might be particularly appropriate for the marked files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These extra candidates are not necessarily only command names.</span>
<span class="linecomment">;;  They can include switches (options) that specialize a command.</span>
<span class="linecomment">;;  For example, if PDF files (*.pdf) are marked in Dired, the</span>
<span class="linecomment">;;  completion candidates might include `gv -safer', `pdftotext ?  -',</span>
<span class="linecomment">;;  and `xpdf'.  The first two of these are not just command names</span>
<span class="linecomment">;;  (e.g. `-safer' is a command switch).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Starting with Emacs 23, Icicles uses both of the following methods</span>
<span class="linecomment">;;  to guess extra candidates that are file type-specific:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * MIME-type associations</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The rules defined by user option `dired-guess-shell-alist-user'</span>
<span class="linecomment">;;    and variable `dired-guess-shell-alist-default' (provided you use</span>
<span class="linecomment">;;    Dired X, that is, standard library `dired-x.el')</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Prior to Emacs 23, MIME types are not used.  In the example of PDF</span>
<span class="linecomment">;;  files, candidates `gv -safer' and `pdftotext ? -' are provided by</span>
<span class="linecomment">;;  MIME-type associations, and candidate `xpdf' is provided by the</span>
<span class="linecomment">;;  Dired X rules.  Note that you can customize the rules.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Any candidates that are specific to the marked files are Icicles</span>
<span class="linecomment">;;  *extra* candidates -- see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Global Filters").</span>
<span class="linecomment">;;  These are available regardless of the current default-directory.</span>
<span class="linecomment">;;  They are not treated as file-name candidates, even though they are</span>
<span class="linecomment">;;  available during file-name completion.  Icicles extra candidates</span>
<span class="linecomment">;;  have face `icicle-extra-candidates' in buffer `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Again, everything that is true for shell-command completion</span>
<span class="linecomment">;;  elsewhere is also true for shell-command completion in Dired.  See</span>
<span class="linecomment">;;  (@&gt; "Icicles Shell-Command Enhancements").  This includes adding</span>
<span class="linecomment">;;  all commands from your search path as extra candidates if option</span>
<span class="linecomment">;;  `icicle-guess-cmds-in-path-flag' is non-nil, and providing help on</span>
<span class="linecomment">;;  individual candidates (shell commands or files) during completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Search-and-Replace Marked Files")</span>
<span class="linecomment">;;  ** Search-and-Replace Marked Files **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Dired, `A' searches the marked files using a regexp, and `Q'</span>
<span class="linecomment">;;  launches `query-replace-regexp' on them.  But suppose that you</span>
<span class="linecomment">;;  want to change only a few occurrences in each file, perhaps among</span>
<span class="linecomment">;;  the first occurrences.  Using `Q', you are forced to review each</span>
<span class="linecomment">;;  search hit in turn - all of them; you cannot simply skip the rest</span>
<span class="linecomment">;;  in one file and continue with the next file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  [I suggested that this feature be added to Emacs, and it has been</span>
<span class="linecomment">;;  added in Emacs 23: you can now skip to the next file.]</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One workaround is to use `M-&gt;' to go to the end of a file, and</span>
<span class="linecomment">;;  then `M-,' to resume query-replace.  Or you can quit the command</span>
<span class="linecomment">;;  altogether, unmark the file you're finished searching, and then</span>
<span class="linecomment">;;  hit `Q' again, but that's not very convenient.  A similar problem</span>
<span class="linecomment">;;  applies to searching using `A'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Dired with Icicles, you can use `M-s i'</span>
<span class="linecomment">;;  (`icicle-search-dired-marked') to search the files and possibly</span>
<span class="linecomment">;;  replace search hits.  This runs `icicle-search', so you have</span>
<span class="linecomment">;;  available all of its features, including accessing search hits</span>
<span class="linecomment">;;  directly, in any order.  To skip a whole file, just match its name</span>
<span class="linecomment">;;  with your minibuffer input and then use `C-~' to remove all of its</span>
<span class="linecomment">;;  occurrences from the set of hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: You can similarly use `M-s i' in Ibuffer or Buffer Menu to</span>
<span class="linecomment">;;  search all marked buffers using Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Save Marked Files as Completion Candidates")</span>
<span class="linecomment">;;  ** Save Marked Files as Completion Candidates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Dired with Icicles, you can use `C-M-&gt;'</span>
<span class="linecomment">;;  (`icicle-dired-save-marked') to save the marked file names as a</span>
<span class="linecomment">;;  set of completion candidates, for reuse later.  You can use `C-&gt;'</span>
<span class="linecomment">;;  to add the marked files to an existing saved set of candidates.</span>
<span class="linecomment">;;  These bindings act similarly to `C-M-&gt;' and `C-&gt;' in the</span>
<span class="linecomment">;;  minibuffer: a prefix argument controls whether you save candidates</span>
<span class="linecomment">;;  to a variable or a cache file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use such a saved set of file names as candidates during</span>
<span class="linecomment">;;  file-name completion.  They are saved as absolute names,</span>
<span class="linecomment">;;  which means you can use them with, say, `C-u C-x C-f'.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Absolute File Names and Different Directories").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Open Dired for a Set of File Names")</span>
<span class="linecomment">;;  ** Open Dired for a Set of File Names **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Dired with Icicles you can use `C-M-&lt;'</span>
<span class="linecomment">;;  (`icicle-dired-chosen-files-other-window') to open Dired for a set</span>
<span class="linecomment">;;  of file or directory names that you choose interactively or that</span>
<span class="linecomment">;;  you have previously saved (persistently or not) as completion</span>
<span class="linecomment">;;  candidates or as an Emacs fileset.  The Dired buffer that is</span>
<span class="linecomment">;;  created is named `Icy File Set' (suffixed with &lt;1&gt;, &lt;2&gt;, etc. as</span>
<span class="linecomment">;;  needed), and it contains only the chosen file names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The file names are checked to be sure they reference existing</span>
<span class="linecomment">;;  files.  If any of the names are relative names, those files are</span>
<span class="linecomment">;;  checked for existence in the Dired directory.  If you use a prefix</span>
<span class="linecomment">;;  argument, then you are prompted for the directory to use.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Marked Files as a Project")</span>
<span class="linecomment">;;  ** Marked Files as a Project **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just as `C-}' in the minibuffer is a shortcut for `C-u C-M-&gt;',</span>
<span class="linecomment">;;  which saves the current set of completion candidates persistently,</span>
<span class="linecomment">;;  so `C-}' in Dired saves the marked file names in a cache file or,</span>
<span class="linecomment">;;  with a prefix arg, an Emacs fileset.  Similarly, just as `C-{' in</span>
<span class="linecomment">;;  the minibuffer is a shortcut for `C-u C-M-&lt;', which retrieves</span>
<span class="linecomment">;;  candidates from a persistent set, so `C-{' in Dired retrieves a</span>
<span class="linecomment">;;  persistent set of file names and opens them in a separate Dired</span>
<span class="linecomment">;;  buffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can think of such persistent file-name sets as projects.</span>
<span class="linecomment">;;  `C-}' is bound to command `icicle-dired-save-marked-as-project'</span>
<span class="linecomment">;;  (aka `icicle-dired-save-marked-persistently').  `C-{' is bound to</span>
<span class="linecomment">;;  command `icicle-dired-project-other-window'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Again, you can use such a project as a candidate set for file-name</span>
<span class="linecomment">;;  completion at any time.  In addition, `C-}' and `C-{' can be handy</span>
<span class="linecomment">;;  in Dired for working with projects even without using completion.</span>
<span class="linecomment">;;  The files in a project can be distributed among any directories</span>
<span class="linecomment">;;  anywhere.  This gives you an easy way to open Dired on just the</span>
<span class="linecomment">;;  files you want and operate on them there.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And while in a project in Dired you can use `C-M-&lt;' to mark a</span>
<span class="linecomment">;;  project subset to work on, and then use `C-M-&gt;' to operate on that</span>
<span class="linecomment">;;  subset using Icicles completion.  And you can have any number of</span>
<span class="linecomment">;;  projects - you access each by its name (with completion) and need</span>
<span class="linecomment">;;  not remember its cache file name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Shell-Command Enhancements") for more information</span>
<span class="linecomment">;;    about shell-command completion</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Sets of Completion Candidates")</span>
<span class="linecomment">;;    for information about saved completion candidates</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Chip Away the Non-Elephant")</span>
<span class="linecomment">;;    for the use of `C-~' to remove matching candidates</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Search Commands, Overview") for information about</span>
<span class="linecomment">;;    `icicle-search'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Search and Replace") for how to replace selected search hits</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Persistent Sets of Completion Candidates")</span>
<span class="linecomment">;;    for more information about using persistent sets</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Support for Projects") for more information about working</span>
<span class="linecomment">;;    with projects</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Library `dired+.el', which has related features such as `C-M-*'</span>
<span class="linecomment">;;    to open Dired on just the marked files and `M-g' to `grep' just</span>
<span class="linecomment">;;    the marked files.</span>
 
<span class="linecomment">;;(@* "Icicles Info Enhancements")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Info Enhancements</span>
<span class="linecomment">;;  -------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles can help with Info in these ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Icicles completion is available for any input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use `icicle-search' on part or all of a manual, if you</span>
<span class="linecomment">;;    flatten it first with `Info-merge-subnodes' .</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicles Completion for Info")</span>
<span class="linecomment">;;  ** Icicles Completion for Info **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whenever completion is available for Info commands, such as `g'</span>
<span class="linecomment">;;  (`Info-goto-node'), `i' (`Info-index'), and `m' (`Info-menu'), you</span>
<span class="linecomment">;;  can take advantage of Icicles completion.  For instance, if you</span>
<span class="linecomment">;;  type `g yan', you can use `S-TAB' for apropos completion and</span>
<span class="linecomment">;;  choose node `Isearch Yank', whose name contains `yan' but does not</span>
<span class="linecomment">;;  start with it.  This is an obvious and standard Icicles feature.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Although vanilla Emacs also accepts a substring as input for `i',</span>
<span class="linecomment">;;  it does not provide substring or regexp completion, and it won't</span>
<span class="linecomment">;;  accept a regexp as final input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles binds `g', `i', and `m' to multi-commands</span>
<span class="linecomment">;;  `icicle-Info-goto-node', `icicle-Info-index', and</span>
<span class="linecomment">;;  `icicle-Info-menu', which means that you can also use `g', `i',</span>
<span class="linecomment">;;  and `m' with `C-next', `C-RET', `C-mouse-2', and so on, to browse</span>
<span class="linecomment">;;  among matching Info nodes.  Unlike browsing with repeated use of</span>
<span class="linecomment">;;  `,' after `i' in vanilla Emacs, you can continue to see all of the</span>
<span class="linecomment">;;  matching candidates, in buffer `*Completions*', and you need not</span>
<span class="linecomment">;;  visit the index hits in sequential order.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `M-g' in the minibuffer to toggle</span>
<span class="linecomment">;;  `icicle-use-C-for-actions-flag', then you can use just `next'</span>
<span class="linecomment">;;  instead of `C-next' to navigate.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Option `icicle-use-C-for-actions-flag'").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As usual in Icicles, you can sort completion candidates in various</span>
<span class="linecomment">;;  ways, using `C-,' (`icicle-change-sort-order').  For `g', in</span>
<span class="linecomment">;;  particular, although the default order is alphabetical, you can</span>
<span class="linecomment">;;  choose `in book order', which shows the node candidates in the</span>
<span class="linecomment">;;  same order as in the book.  In that case, using `g' and then</span>
<span class="linecomment">;;  navigating among candidates sequentially using `C-up', `C-down',</span>
<span class="linecomment">;;  `C-next', or `C-prior' visits the nodes in their natural order.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a special case of this, if you use a negative prefix argument</span>
<span class="linecomment">;;  (that is, `M-- g'), then not only are the candidate nodes</span>
<span class="linecomment">;;  presented `in book order', they are also limited to the nodes that</span>
<span class="linecomment">;;  follow your current location in the book - that is, to the</span>
<span class="linecomment">;;  remainder of the book.  (A non-negative prefix argument has the</span>
<span class="linecomment">;;  same meaning as for `Info-goto-node'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, except when you are at the `Top' node, a pseudo-node</span>
<span class="linecomment">;;  `..' is added to the set of completion candidates.  Choosing this</span>
<span class="linecomment">;;  takes you up to the parent of the current node.  You can thus use</span>
<span class="linecomment">;;  `g' in Info not only to explore nodes by name, but also as another</span>
<span class="linecomment">;;  means to traverse the Info menu hierarchy.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using Icicle-Search With Info")</span>
<span class="linecomment">;;  ** Using Icicle-Search With Info **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles searching (`icicle-search') is not Isearch.  It searches</span>
<span class="linecomment">;;  for all matches in the portion of text you tell it to search.</span>
<span class="linecomment">;;  This means that you cannot use it to search an entire manual in</span>
<span class="linecomment">;;  one operation, unless you have the entire manual available in a</span>
<span class="linecomment">;;  single buffer to be searched.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So, when you use `icicle-search' (`C-c `') to search with Info,</span>
<span class="linecomment">;;  you are limited to a few options:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use it normally, to search within a single Info node.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can widen the visible portion of the Info buffer</span>
<span class="linecomment">;;    (`C-x n w'), to use it on an entire Info file.  However:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    1. It is not obvious how a given Info manual is divided into</span>
<span class="linecomment">;;       files.  That is, you need to be aware of the point at which</span>
<span class="linecomment">;;       the manual moves from one file to the next.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    2. Only the nodes in the same file that you have already visited</span>
<span class="linecomment">;;       are highlighted, and lots of ugly Info "plumbing" becomes</span>
<span class="linecomment">;;       visible in the other nodes.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    3. You lose all Info features, such as navigation using links.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * There is another way to search across nodes, which addresses #1</span>
<span class="linecomment">;;    and #2, but still does not give you navigable links and such.</span>
<span class="linecomment">;;    Think of it as a hack that can sometimes be handy.  That is what</span>
<span class="linecomment">;;    is described below.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The idea is to flatten a subtree of Info nodes - possibly an</span>
<span class="linecomment">;;  entire manual, but more typically a node and its children - and</span>
<span class="linecomment">;;  then use `icicle-search' (`C-c `') over that flattened document.</span>
<span class="linecomment">;;  What is needed is a command that flattens Info subtrees.  Library</span>
<span class="linecomment">;;  `info+.el' provides such a command, `Info-merge-subnodes', and</span>
<span class="linecomment">;;  binds it to `+' in Info.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can control how you want the flattening to occur, by using</span>
<span class="linecomment">;;  different values of prefix argument.  For searching, you probably</span>
<span class="linecomment">;;  want complete flattening of the chosen subtree, in a single</span>
<span class="linecomment">;;  buffer, so you use a prefix arg of zero: `C-u 0 +'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This does not replace the *Info* buffer that you started with; it</span>
<span class="linecomment">;;  creates a new buffer, named after the root node of the subtree you</span>
<span class="linecomment">;;  flattened.  A principle use of `Info-merge-subnodes' is to print</span>
<span class="linecomment">;;  out a manual or a portion of it.  Also, I wrote a library</span>
<span class="linecomment">;;  (`mkhtml.el', outdated now) that lets you convert the result to</span>
<span class="linecomment">;;  HTML.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In sum, you can use Icicles search in Info: `C-u 0 +', then</span>
<span class="linecomment">;;  `C-c `'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One caveat, however: You will generally want to limit your search</span>
<span class="linecomment">;;  to a reasonably small subtree of a manual, instead of flattening</span>
<span class="linecomment">;;  and then searching the entire manual.  Flattening a large manual</span>
<span class="linecomment">;;  can take a while: it took me 10 minutes to flatten the Emacs</span>
<span class="linecomment">;;  Manual.  Of course, you could flatten a large manual once, and</span>
<span class="linecomment">;;  save the result in a file for later searches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Obviously, flattening in order to search is less convenient than</span>
<span class="linecomment">;;  using manual-wide incremental search (`C-s') with Info (starting</span>
<span class="linecomment">;;  with Emacs 22), and it is often less convenient than using</span>
<span class="linecomment">;;  `Info-search' (bound to `s' in Info).  Icicles searching is</span>
<span class="linecomment">;;  different from both, and it has its advantages and disadvantages.</span>
<span class="linecomment">;;  When you want the advantages of Icicles searching in Info, the</span>
<span class="linecomment">;;  flattening hack can be useful.  When you don't need those</span>
<span class="linecomment">;;  advantages, other search methods can sometimes be more</span>
<span class="linecomment">;;  appropriate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Multi-Commands") for</span>
<span class="linecomment">;;    information on using multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Search Commands, Overview") for information about</span>
<span class="linecomment">;;    command `icicle-search'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Library `info+.el' for information about `Info-merge-subnodes'.</span>
 
<span class="linecomment">;;(@* "Support for Projects")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Support for Projects</span>
<span class="linecomment">;;  ----------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section presents nothing really new.  It provides pointers to</span>
<span class="linecomment">;;  other sections that describe features that can help you work with</span>
<span class="linecomment">;;  a project that involves multiple files or buffers, or named</span>
<span class="linecomment">;;  regions of text (e.g. code) within files and buffers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Let's assume that you have one or more sets of files or buffers</span>
<span class="linecomment">;;  that you use frequently.  You give these sets names and save the</span>
<span class="linecomment">;;  sets persistently.  Later, you can retrieve a set by name,</span>
<span class="linecomment">;;  bringing you back to the context of working with just those</span>
<span class="linecomment">;;  particular files, buffers, or regions that belong to your project.</span>
<span class="linecomment">;;  You can search these or navigate among their significant parts.</span>
<span class="linecomment">;;  Icicles has a number of features that can help with these tasks.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But before you can name and save such a set, you must define its</span>
<span class="linecomment">;;  members: pick the files, buffers, or regions that you want to</span>
<span class="linecomment">;;  belong to a given project.  Icicles can help with this too.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Defining and Saving Sets of Files, Buffers, Regions")</span>
<span class="linecomment">;;  ** Defining and Saving Sets of Files, Buffers, Regions **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For buffers, use commands `icicle-add-buffer-config' and</span>
<span class="linecomment">;;  `icicle-remove-buffer-config' to define one or more buffer</span>
<span class="linecomment">;;  configurations.  These are named sets of buffers, sort functions,</span>
<span class="linecomment">;;  and other parameters that control completion of buffer names.</span>
<span class="linecomment">;;  Thereafter, you can use command `icicle-buffer-config' to choose a</span>
<span class="linecomment">;;  configuration to be current.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For multiple regions, use `C-N C-x C-x' (`icicle-add-region'),</span>
<span class="linecomment">;;  where N is a whole number, to add the current region to</span>
<span class="linecomment">;;  `icicle-region-alist'.  This user option is saved with your</span>
<span class="linecomment">;;  customizations.  You can later activate a saved region using `C-u</span>
<span class="linecomment">;;  C-x C-x' (`icicle-select-region').  You can search the text in one</span>
<span class="linecomment">;;  or more saved regions using command `icicle-search-region'.  Or</span>
<span class="linecomment">;;  you can search through all of the saved regions at once using `C-N</span>
<span class="linecomment">;;  C-c `' (`icicle-search' with a positive prefix argument).</span>
<span class="linecomment">;;  See Also: (@&gt; "Multiple Regions").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To define a set of files, you use Icicles completion against file</span>
<span class="linecomment">;;  names.  You can use progressive completion, chip away the</span>
<span class="linecomment">;;  non-elephant, and so on, to get just the file names you want.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For this completion, you can use a command that calls</span>
<span class="linecomment">;;  `read-file-name', and so matches relative file names using the</span>
<span class="linecomment">;;  current `default-directory'.  Or you can use a command that calls</span>
<span class="linecomment">;;  `completing-read', and so matches absolute file names - that is,</span>
<span class="linecomment">;;  lets you match not only file names but also directory components.</span>
<span class="linecomment">;;  An example of the former type is `icicle-find-file'.  Examples of</span>
<span class="linecomment">;;  the latter type are `icicle-find-file-absolute',</span>
<span class="linecomment">;;  `icicle-recent-file', and `icicle-locate-file'.  Command</span>
<span class="linecomment">;;  `icicle-file' (bound to `C-x C-f' by default) lets you do both,</span>
<span class="linecomment">;;  depending on the prefix argument.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You save a set of file names the same way you save any set of</span>
<span class="linecomment">;;  completion candidates.  You can save all of the names that match</span>
<span class="linecomment">;;  your current input.  You can add a set of names or individual</span>
<span class="linecomment">;;  names to a set of names that you have already saved.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, you can save the marked files in Dired as a set of</span>
<span class="linecomment">;;  project files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Your project is not only files that are all in the same directory,</span>
<span class="linecomment">;;  of course.  You can save file names from multiple directories in</span>
<span class="linecomment">;;  the same set.  And you can include directory names as well, for</span>
<span class="linecomment">;;  use later with commands that operate on directories.  Finally, you</span>
<span class="linecomment">;;  can also save file names as Emacs filesets and use those the same</span>
<span class="linecomment">;;  way.  An Icicles set of saved file names can include Emacs</span>
<span class="linecomment">;;  filesets - see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Filesets and Icicles Saved Completion Sets").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Sets of Completion Candidates")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Persistent Sets of Completion Candidates")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Progressive Completion")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Chip Away the Non-Elephant")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "File-Name Input and Locating Files Anywhere")</span>
<span class="linecomment">;;  * (@&gt; "Save Marked Files as Completion Candidates") (Dired)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Navigating Among Code Definitions")</span>
<span class="linecomment">;;  ** Navigating Among Code Definitions **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For software projects, you need to be able to navigate among code</span>
<span class="linecomment">;;  definitions.  Imenu and Emacs TAGS features are useful for this,</span>
<span class="linecomment">;;  as are `grep' and compilation buffers.  Icicles improves all of</span>
<span class="linecomment">;;  these.  (A TAGS file is just a saved index for project files.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Imenu")</span>
<span class="linecomment">;;  * (@&gt; "Icicles Tags Enhancements")</span>
<span class="linecomment">;;  * (@&gt; "Compile/Grep Search")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Searching Project Files")</span>
<span class="linecomment">;;  ** Searching Project Files **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Searching within your project is another area where Icicles can</span>
<span class="linecomment">;;  help.  Icicles search is both search and navigation.  Navigating</span>
<span class="linecomment">;;  among TAGS definitions that match a regexp is also really</span>
<span class="linecomment">;;  searching, and the same is true for Imenu and grep navigation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See also (@&gt; "Icicles Search Commands, Overview") and its</span>
<span class="linecomment">;;  subsections for information about the many ways that you can use</span>
<span class="linecomment">;;  Icicles search to access parts of your projects.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See also (@&gt; "Icicles Dired Enhancements") for an easy way to</span>
<span class="linecomment">;;  search marked files in Dired with Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And don't forget that all uses of Icicles search also let you do</span>
<span class="linecomment">;;  search-and-replace on the fly.  This applies to `grep' results,</span>
<span class="linecomment">;;  searching marked files in Dired, tags navigation, and Imenu</span>
<span class="linecomment">;;  navigation.  You can at any time replace the current search hit</span>
<span class="linecomment">;;  or just the part of it that matches your current input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Retrieving and Reusing a Saved Project")</span>
<span class="linecomment">;;  ** Retrieving and Reusing a Saved Project **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section could also be called "Using Retrieved Saved Sets".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You retrieve a set of saved file names (a project) the same way</span>
<span class="linecomment">;;  you retrieve any saved set of completion candidates.  That is, you</span>
<span class="linecomment">;;  access the files defined for your project by retrieving their</span>
<span class="linecomment">;;  names during completion, to serve as the current set of completion</span>
<span class="linecomment">;;  candidates.  This odd feature is unique to Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There's nothing much more to say about this, except that you</span>
<span class="linecomment">;;  should be taking advantage of it now.  Define and save a set of</span>
<span class="linecomment">;;  project files (or buffers), and later use just those files,</span>
<span class="linecomment">;;  staying within the bounds of your project for your navigation,</span>
<span class="linecomment">;;  search, compilation, etc. needs.  Even if the files you use in a</span>
<span class="linecomment">;;  given project are scattered all over your file system, Icicles</span>
<span class="linecomment">;;  lets you access them together as a named unit.  For more</span>
<span class="linecomment">;;  information, see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also open Dired for a project or for a list of file names</span>
<span class="linecomment">;;  saved non-persistently as completion candidates - only those files</span>
<span class="linecomment">;;  are listed in the Dired buffer.</span>
<span class="linecomment">;;  See (@&gt; "Icicles Dired Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also run `grep' directly on a saved list of file names</span>
<span class="linecomment">;;  using command `icicle-grep-saved-file-candidates'.  If you use</span>
<span class="linecomment">;;  library `dired+.el', then you can also `grep' the files in a</span>
<span class="linecomment">;;  project or saved list of file names by opening it in Dired and</span>
<span class="linecomment">;;  then using `M-g' (`diredp-do-grep').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Finally, note that among the sets of completion candidates that</span>
<span class="linecomment">;;  you can save are Icicles search hits.  That's right.  Icicles</span>
<span class="linecomment">;;  search lets you search multiple buffers, files, or buffer regions,</span>
<span class="linecomment">;;  and you can save selected search hits or all matching hits for</span>
<span class="linecomment">;;  later use.  When you save search hits, Icicles records the buffer</span>
<span class="linecomment">;;  or file names and the hit locations within those buffers or files.</span>
<span class="linecomment">;;  When you retrieve such a saved set to access its hits, Icicles</span>
<span class="linecomment">;;  automatically takes you to the proper files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A related feature is being able to filter tags definitions and</span>
<span class="linecomment">;;  then save the filtered hit list.  This works the same way, and it</span>
<span class="linecomment">;;  gives you the equivalent of per-project TAGS files: A saved hit</span>
<span class="linecomment">;;  list acts just like a custom TAGS file when you reuse it.  And</span>
<span class="linecomment">;;  unlike some of your project files, a TAGS file doesn't change</span>
<span class="linecomment">;;  often, so saved hit sets stay accurate longer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Semantics? Roll Your Own?")</span>
<span class="linecomment">;;  ** Semantics? Roll Your Own? **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I no longer develop software.  I just putz around with Emacs Lisp</span>
<span class="linecomment">;;  for my own enjoyment, entertainment, and enlightenment.  So I</span>
<span class="linecomment">;;  don't use things like ECB (Emacs Code Browser) or Semantic</span>
<span class="linecomment">;;  (Bovinator).  I don't use any IDE that has knowledge of a</span>
<span class="linecomment">;;  particular programming language.  The Icicles commands I've</span>
<span class="linecomment">;;  written therefore use little or no semantic or language</span>
<span class="linecomment">;;  information; they rely upon syntax for the most part, and they are</span>
<span class="linecomment">;;  essentially language-agnostic (i.e. ignorant).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But you are a different story.  If you use, say, Semantic, you</span>
<span class="linecomment">;;  could write a little Emacs-Lisp code to take advantage of Icicles</span>
<span class="linecomment">;;  in combination with Semantic's parser information.  With complete</span>
<span class="linecomment">;;  ignorance of Semantic, I dare say it wouldn't be hard.  If you can</span>
<span class="linecomment">;;  get an alist of completion candidates for something from Semantic</span>
<span class="linecomment">;;  in some context, then you can exploit all of the Icicles features:</span>
<span class="linecomment">;;  apropos completion, progressive completion, multi-commands,</span>
<span class="linecomment">;;  Icicles search, and so on.  Likewise for any other IDE that plays</span>
<span class="linecomment">;;  well with Emacs and for any other programming language support.</span>
<span class="linecomment">;;  Think about it.  Others would appreciate your contribution.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles provides lots of features for Emacs-Lisp programmers.  The</span>
<span class="linecomment">;;  end-user commands I've written using some of those features are</span>
<span class="linecomment">;;  really just a demonstration of what you can do.  Try rolling your</span>
<span class="linecomment">;;  own Icicles commands.  See Also: (@&gt; "Note to Programmers").</span>
 
<span class="linecomment">;;(@* "Using Complex Completion Candidates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Using Complex Completion Candidates</span>
<span class="linecomment">;;  -----------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section could also be called "Applying a Function</span>
<span class="linecomment">;;  Interactively" or "Mapping over Sets".  It is about applying a</span>
<span class="linecomment">;;  function to members of a set of completion candidates that you</span>
<span class="linecomment">;;  select interactively.  The candidates can represent arbitrarily</span>
<span class="linecomment">;;  complex data, and the function is applied to the associated data</span>
<span class="linecomment">;;  as well, not just to the displayed (string) candidate that names</span>
<span class="linecomment">;;  the data.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You already know that you can manipulate sets of candidates - see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Sets of Completion Candidates").</span>
<span class="linecomment">;;  The elements of those sets are strings; you choose</span>
<span class="linecomment">;;  candidate names.  Sometimes, however, you need to choose among</span>
<span class="linecomment">;;  named items that are themselves complex, containing more</span>
<span class="linecomment">;;  information than just the name.  That is the idea behind</span>
<span class="linecomment">;;  multi-command `icicle-apply', which this section introduces.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You (or a command that you use) can obtain the information</span>
<span class="linecomment">;;  associated with a name after you choose the name.  This is what</span>
<span class="linecomment">;;  happens, for instance, when you use `find-file'; the command looks</span>
<span class="linecomment">;;  up the file associated with the file name you choose.  Icicles</span>
<span class="linecomment">;;  multi-commands such as `icicle-file' perform this lookup both when</span>
<span class="linecomment">;;  you act on a candidate during completion (e.g. `C-RET') and when</span>
<span class="linecomment">;;  you make a final candidate selection (`RET') - see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Names and their associated information can be available in Emacs</span>
<span class="linecomment">;;  Lisp in the form of an association list (alist), that is, a list</span>
<span class="linecomment">;;  whose items are conses (cons cells).  An alist is often used to</span>
<span class="linecomment">;;  represent a function that maps one set of things to another.  The</span>
<span class="linecomment">;;  conses in the alist represent the tuples (typically pairs) of</span>
<span class="linecomment">;;  related items.  The car of each cons is called its "key"; the cdr</span>
<span class="linecomment">;;  is called its "value".  Different alists have different kinds of</span>
<span class="linecomment">;;  keys and values.  Typical key types include symbols and strings;</span>
<span class="linecomment">;;  typical value types include symbols, strings, numbers, and lists.</span>
<span class="linecomment">;;  There are quite a few standard Emacs-Lisp variables whose value is</span>
<span class="linecomment">;;  an alist.  Most are internal variables, but some are user options.</span>
<span class="linecomment">;;  See the Emacs-Lisp manual for more about alists.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The completion mechanism of Emacs function `completing-read' can</span>
<span class="linecomment">;;  take an alist as input: the keys are the completion-candidate</span>
<span class="linecomment">;;  strings that you choose from.  For Emacs completion, however, the</span>
<span class="linecomment">;;  value (cdr) of each alist key/value entry is completely ignored.</span>
<span class="linecomment">;;  Icicles uses `completing-read', and it works the same way.  If a</span>
<span class="linecomment">;;  command needs to access the value associated with a key</span>
<span class="linecomment">;;  (candidate), then it must somehow do so independently of</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-search' offers an example of this.  The completion</span>
<span class="linecomment">;;  alist contains key/value pairs whose car (key) is a search-hit</span>
<span class="linecomment">;;  string that matches your search string and whose cdr (value) is</span>
<span class="linecomment">;;  the buffer position for the hit.  When you use completion with</span>
<span class="linecomment">;;  this command, you work only with the keys, but `icicle-search'</span>
<span class="linecomment">;;  also keeps track of the corresponding buffer positions for you.</span>
<span class="linecomment">;;  The logic for doing this is coded into the definition of</span>
<span class="linecomment">;;  `icicle-search'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is common to want to do something interesting interactively</span>
<span class="linecomment">;;  with the values also, not just the keys, of a completion alist.</span>
<span class="linecomment">;;  Why lose the important value information when you choose a key?</span>
<span class="linecomment">;;  And instead of requiring the logic of each command to deal with</span>
<span class="linecomment">;;  this need individually, why not provide a general mechanism for</span>
<span class="linecomment">;;  accessing this information - both by program and interactively?</span>
<span class="linecomment">;;  This is what command `icicle-apply' is for.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To make use of completion alist values, you need to access the cdr</span>
<span class="linecomment">;;  of a key/value cons (pair).  Different alists are structured</span>
<span class="linecomment">;;  differently: the cdr can itself be complex (structured - a cons).</span>
<span class="linecomment">;;  In general, you want to access not just the cdr (value) but the</span>
<span class="linecomment">;;  key as well, the key/value pair as a whole, to do what you want</span>
<span class="linecomment">;;  with it - that is, to apply some function to it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Emacs-Lisp programmers sometimes map functions over lists to</span>
<span class="linecomment">;;  obtain a different list.  For example, mapping the function `1+'</span>
<span class="linecomment">;;  over the list (3 1 4 1 5 9) gives the list (4 2 5 2 6 10).  Or if</span>
<span class="linecomment">;;  interested only in the side effects, they apply a function</span>
<span class="linecomment">;;  iteratively over a list without bothering to accumulate the</span>
<span class="linecomment">;;  results as a new list.  The command `icicle-apply' is inspired by</span>
<span class="linecomment">;;  these common practices of mapping and iterating over a list, but</span>
<span class="linecomment">;;  it applies only to alists.  And it lets you choose interactively</span>
<span class="linecomment">;;  which alist elements to act on, instead of always acting on all</span>
<span class="linecomment">;;  elements.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `icicle-apply' lets you apply a function of your choice to any</span>
<span class="linecomment">;;  number of key/value entries in an alist.  As user of the command,</span>
<span class="linecomment">;;  you choose the entries to act on.  The alist is used for</span>
<span class="linecomment">;;  completion; you choose among the keys.  The function is applied to</span>
<span class="linecomment">;;  the corresponding key/value pairs, however, not to the keys alone.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, given the alist `auto-mode-alist' and the function</span>
<span class="linecomment">;;  `cdr', you can choose to apply `cdr' to selected alist entries.</span>
<span class="linecomment">;;  This acts as a simple lookup function, because `cdr' just returns</span>
<span class="linecomment">;;  the value associated with a chosen key.  If you choose, for</span>
<span class="linecomment">;;  example, the candidate (key) "\.el\'", then the (value) result is</span>
<span class="linecomment">;;  the symbol `emacs-lisp-mode'.  In this case, the chosen key/value</span>
<span class="linecomment">;;  pair is ("\\.el\\'" . emacs-lisp-mode).  (A literal backslash must</span>
<span class="linecomment">;;  be doubled in an Emacs-Lisp string.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Function `cdr' returns the value, which is `emacs-lisp-mode' here.</span>
<span class="linecomment">;;  If instead of `cdr' you use the function (lambda (x)</span>
<span class="linecomment">;;  (describe-function (cdr x))), then the result of choosing</span>
<span class="linecomment">;;  candidate "\.el\'" is to display the help for function</span>
<span class="linecomment">;;  `emacs-lisp-mode'.  This function first uses `cdr' to obtain the</span>
<span class="linecomment">;;  value (the mode) and then applies `describe-function' to that</span>
<span class="linecomment">;;  value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A typical use of `icicle-apply' is to define your own</span>
<span class="linecomment">;;  multi-command that you or someone else can use to act on objects</span>
<span class="linecomment">;;  selected by name.  The definition of command `icicle-goto-marker'</span>
<span class="linecomment">;;  provides an example.  It uses an alist whose elements are pairs</span>
<span class="linecomment">;;  composed of a text line (the key) and the marker (the value) in</span>
<span class="linecomment">;;  that line.  It applies a function that moves to the marker.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If called interactively (as opposed to being used to define</span>
<span class="linecomment">;;  another command), `icicle-apply' lets you use completion to choose</span>
<span class="linecomment">;;  not only the objects to act on but also the function to apply to</span>
<span class="linecomment">;;  them and the alist to choose them from.  See the doc string of</span>
<span class="linecomment">;;  `icicle-apply' for more information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that you can type in a lambda expression when prompted for</span>
<span class="linecomment">;;  the function.  You can use any function, provided it targets a</span>
<span class="linecomment">;;  key/value pair (a cons).  This is why you could not simply use</span>
<span class="linecomment">;;  `describe-function' itself as the function to apply in the example</span>
<span class="linecomment">;;  above: `describe-function' expects a symbol argument, not a cons.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So what is `icicle-apply' really for?  Anything you want.  You can</span>
<span class="linecomment">;;  use it to simply browse an alist or to perform actions on complex</span>
<span class="linecomment">;;  things.  The idea is to let you take advantage of Icicles features</span>
<span class="linecomment">;;  to interactively filter and manipulate a set of completion keys,</span>
<span class="linecomment">;;  and then apply any function you like to them - not just to the</span>
<span class="linecomment">;;  keys, but to the keys or their values, or both.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use apropos (regexp) matching or prefix matching to filter</span>
<span class="linecomment">;;  the alist, as always, during completion.  You can use `C-RET' and</span>
<span class="linecomment">;;  so on to act on (that is, apply the function to) selected</span>
<span class="linecomment">;;  key/value pairs that match your current input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also act on *all* such pairs, by using `C-!' or `M-!'.</span>
<span class="linecomment">;;  `C-!' corresponds to iterating over the items in a list, applying</span>
<span class="linecomment">;;  a function to each.  `M-!' applies a function not to each chosen</span>
<span class="linecomment">;;  pair, but to the *list* of all chosen pairs.  By default, the</span>
<span class="linecomment">;;  completion candidates are not sorted, but you can of course sort</span>
<span class="linecomment">;;  them in various ways, either interactively or by program.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an Emacs-Lisp programmer, you can use function `icicle-apply'</span>
<span class="linecomment">;;  programmatically to let users look things up in alists that you</span>
<span class="linecomment">;;  construct or to act on selected alist entries in complex ways.</span>
<span class="linecomment">;;  Icicles just provides the interactive completion features.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The real value of `icicle-apply' comes from what you do with it.</span>
<span class="linecomment">;;  Use it with a database of geographical coordinates to look up</span>
<span class="linecomment">;;  location names provided by users and draw corresponding vicinity</span>
<span class="linecomment">;;  maps.  Use it with a list of hardware configurations to let users</span>
<span class="linecomment">;;  perform diagnostic or maintenance operations on selected</span>
<span class="linecomment">;;  equipment.  You get the idea - use your imagination.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Although completion alists normally require string-valued</span>
<span class="linecomment">;;  keys, `icicle-apply' is designed to work with any alist.</span>
 
<span class="linecomment">;;(@* "Icicles OO: Object-Action Interaction")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles OO: Object-Action Interaction</span>
<span class="linecomment">;;  --------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here's another crazy Icicles feature: Instead of choosing a</span>
<span class="linecomment">;;  function (e.g. command) and then the object to apply it to, choose</span>
<span class="linecomment">;;  the object first and then the function.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The first thing to say about this feature is that Emacs is not</span>
<span class="linecomment">;;  really designed for this, so it's not feasible to do this in a</span>
<span class="linecomment">;;  entirely satisfactory way.  In particular, there is no practical</span>
<span class="linecomment">;;  way, given an object, to find all of the functions that apply to</span>
<span class="linecomment">;;  it, in order to allow those functions as completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The second thing to say is that there are three ways that Icicles</span>
<span class="linecomment">;;  helps you operate on a chosen object of a given type:  </span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * apropos completion - (1) choose an object type by name, (2)</span>
<span class="linecomment">;;    choose a function, (3) choose the target object</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `M-RET' during completion - (1) choose a target object, (2)</span>
<span class="linecomment">;;    choose a function</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-object-action' and `icicle-anything' - (1) choose an</span>
<span class="linecomment">;;    object type by name, (2) choose the target object, (3) choose a</span>
<span class="linecomment">;;    function</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a special case, if you use library Anything (`anything.el'),</span>
<span class="linecomment">;;  then `icicle-object-action' lets you apply one or more Anything</span>
<span class="linecomment">;;  actions defined for the object.  See (@&gt; "Icicles with Anything")</span>
<span class="linecomment">;;  for more information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Apropos Completion as OO")</span>
<span class="linecomment">;;  ** Apropos Completion as OO **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The first way that Icicles helps with object-action interaction is</span>
<span class="linecomment">;;  apropos completion, which you can use to narrow the set of</span>
<span class="linecomment">;;  commands to those that have the object type in their name.  You</span>
<span class="linecomment">;;  still choose the command before the individual object, but you at</span>
<span class="linecomment">;;  least choose the object type first (which narrows the set of</span>
<span class="linecomment">;;  possible objects).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use Icicles, you already use apropos completion this way,</span>
<span class="linecomment">;;  but you might not have thought about it in these terms.  If you</span>
<span class="linecomment">;;  want to invoke some command on a buffer, you might start by typing</span>
<span class="linecomment">;;  `M-x buffer S-TAB' or `M-x buff S-TAB'.  This is simple, but it</span>
<span class="linecomment">;;  really does get you most of the way toward object-action</span>
<span class="linecomment">;;  interaction.  And you can of course then use progressive</span>
<span class="linecomment">;;  completion (`M-*') to filter the matching commands for additional</span>
<span class="linecomment">;;  object-type names; for example `M-* window' keeps only those</span>
<span class="linecomment">;;  commands whose names contain both `buffer' and `window'.  Of</span>
<span class="linecomment">;;  course, this requires the command name to actually advertise</span>
<span class="linecomment">;;  truthfully the object types that it operates on.  There are false</span>
<span class="linecomment">;;  positives and true negatives, but Emacs is generally quite helpful</span>
<span class="linecomment">;;  in this respect.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "M-RET")</span>
<span class="linecomment">;;  ** M-RET **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The second way that Icicles helps with object-action interaction</span>
<span class="linecomment">;;  is the minibuffer binding of `M-RET'</span>
<span class="linecomment">;;  (`icicle-candidate-read-fn-invoke') during completion.  Whenever</span>
<span class="linecomment">;;  you are cycling through completion candidates, `M-RET' enters a</span>
<span class="linecomment">;;  recursive edit that prompts you for a function to apply to the</span>
<span class="linecomment">;;  current candidate.  Regardless of what the initial command was</span>
<span class="linecomment">;;  that you started to execute, if it reads an object name with</span>
<span class="linecomment">;;  completion, just cycle to that name and hit `M-RET'.  `M-mouse-2'</span>
<span class="linecomment">;;  does the same thing, so you don't even have to cycle to get to the</span>
<span class="linecomment">;;  candidate you want.  For example, if the current candidate is a</span>
<span class="linecomment">;;  buffer named `foo.el', then `M-RET' prompts you for a function to</span>
<span class="linecomment">;;  apply to it.  (Actually, the function is applied to the completion</span>
<span class="linecomment">;;  candidate, which is the buffer name in this case, but many</span>
<span class="linecomment">;;  functions accept an object name in place of the object.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The function you enter can be anything; it need not be a command,</span>
<span class="linecomment">;;  and it need not be the name of a function: you can type a lambda</span>
<span class="linecomment">;;  expression that accepts an argument of the appropriate type.  The</span>
<span class="linecomment">;;  function is read with completion: you can complete a function name</span>
<span class="linecomment">;;  (the completion is lax, to allow for a lambda expression).  Note</span>
<span class="linecomment">;;  that the domain of discourse for completion is the set of *all*</span>
<span class="linecomment">;;  named functions, regardless of the target object.  It is up to you</span>
<span class="linecomment">;;  to choose an appropriate function.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Using a lambda expression here is a good way to "curry" a function</span>
<span class="linecomment">;;  that requires multiple arguments, so that it adapts to expect just</span>
<span class="linecomment">;;  a single argument of the appropriate object type.  For example,</span>
<span class="linecomment">;;  (lambda (sym-name) (get (intern (sym-name)) 'invisible))</span>
<span class="linecomment">;;  transforms function `get', which takes a symbol and a property, to</span>
<span class="linecomment">;;  a function that takes a symbol name and looks up the `invisible'</span>
<span class="linecomment">;;  property of the symbol.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use a prefix argument (`C-u M-RET' or `C-u M-mouse-2'),</span>
<span class="linecomment">;;  then the result of the function application is pretty-printed.</span>
<span class="linecomment">;;  Otherwise, the function is called for effect only.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`icicle-object-action' and `icicle-anything'")</span>
<span class="linecomment">;;  ** `icicle-object-action' and `icicle-anything' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The third way that Icicles helps with object-action interaction is</span>
<span class="linecomment">;;  provided by command `icicle-object-action'.  This reads an</span>
<span class="linecomment">;;  object-type name ("what"), with completion; then it reads an</span>
<span class="linecomment">;;  object of that type ("which"), with completion; then it reads a</span>
<span class="linecomment">;;  function (name or lambda expression) to apply to the object</span>
<span class="linecomment">;;  ("how"), with (lax) completion.  Again, use a prefix argument if</span>
<span class="linecomment">;;  you want to pretty-print the result.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `what-which-how' is an alias for command `icicle-object-action'.</span>
<span class="linecomment">;;  It is easy to remember, taking its name from the successive input</span>
<span class="linecomment">;;  prompts: "What?" - a file.  "Which?" - icicles.el.  "How?" open.</span>
<span class="linecomment">;;  Another alias for the same command is `a', because it acts on a</span>
<span class="linecomment">;;  file, a buffer, a symbol, a process, and so on.  The first thing</span>
<span class="linecomment">;;  it does is prompt you for the type of object, so you do `M-x a RET</span>
<span class="linecomment">;;  buffer', `M-x a RET symbol', and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The aliases `what-which-how' and `a' are just convenience</span>
<span class="linecomment">;;  commands.  They are defined only if user option</span>
<span class="linecomment">;;  `icicle-define-alias-commands-flag' is non-nil.  Two related</span>
<span class="linecomment">;;  commands are also defined only if this option is non-nil:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `file'   - same as `a RET file'</span>
<span class="linecomment">;;  * `buffer' - same as `a RET buffer'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example: `M-x file RET'.  You are prompted for a file to act</span>
<span class="linecomment">;;  on, and then for the action to use.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: If you use AUCTeX, then be aware of an AUCTeX bug that</span>
<span class="linecomment">;;  causes problems if `icicle-define-alias-commands-flag' is non-nil.</span>
<span class="linecomment">;;  Here is the bug description, filed 2007/10/05 by Bjorn Haagensen:</span>
<span class="linecomment">;;  http://lists.gnu.org/archive/html/bug-auctex/2007-10/msg00006.html.</span>
<span class="linecomment">;;  The problem is that AUCTeX mistakenly invokes the Icicles `file'</span>
<span class="linecomment">;;  command, in an inappropriate context.  AUCTeX does not define any</span>
<span class="linecomment">;;  function `file' when it is loaded, but it invokes one, if defined.</span>
<span class="linecomment">;;  This appears to be a name-capture problem.  Since there is no</span>
<span class="linecomment">;;  `file' function defined when Icicles is loaded, Icicles defines</span>
<span class="linecomment">;;  its command.  AUCTeX developers will no doubt fix this bug.  Until</span>
<span class="linecomment">;;  then, AUCTeX users can avoid the bug by setting</span>
<span class="linecomment">;;  `icicle-define-alias-commands-flag' to nil.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The "type" of an object is one of these:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  a. A member of the list `icicle-object-predicate-types'.  These</span>
<span class="linecomment">;;     are type predicates, such as `bufferp', `keywordp', or `atom'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  b. The `type' of an Anything source, or its `name' if it has no</span>
<span class="linecomment">;;     `type'.  This is available only if you use library</span>
<span class="linecomment">;;     `anything.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  c. A member of the list `icicle-object-named-types'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles completion is available for each prompt: the type, the</span>
<span class="linecomment">;;  object, and the action to apply to the object.  Types defined by</span>
<span class="linecomment">;;  Anything are highlighted in buffer `*Completions*' using face</span>
<span class="linecomment">;;  `icicle-special-candidate'.  In the case of an Anything type, you</span>
<span class="linecomment">;;  can use multi-command features to act on multiple objects in</span>
<span class="linecomment">;;  multiple ways, all within a single `a' invocation.  See</span>
<span class="linecomment">;;  (@&gt; "Icicles with Anything") for more information about using</span>
<span class="linecomment">;;  Anything types.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The objects of types (b) and (c) are easily named, and their names</span>
<span class="linecomment">;;  serve as the completion candidates when you choose them.  So, for</span>
<span class="linecomment">;;  instance, if you choose type `buffer', then you can act on a</span>
<span class="linecomment">;;  buffer by choosing its name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The objects of predicate type (type a, above) are not necessarily</span>
<span class="linecomment">;;  named.  The completion candidates for these objects are symbols</span>
<span class="linecomment">;;  whose values are the objects that are acted upon. The object-type</span>
<span class="linecomment">;;  names used for these candidates are really Emacs-Lisp type</span>
<span class="linecomment">;;  predicate names, which all end in `p', except for `atom'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So, for instance, if you choose type `bufferp', then you can</span>
<span class="linecomment">;;  choose a symbol whose value is a buffer, in order to act on that</span>
<span class="linecomment">;;  buffer.  A buffer is of course always named, but an object of type</span>
<span class="linecomment">;;  `stringp' is not.  The value of `emacs-version' is one such string</span>
<span class="linecomment">;;  that you can act on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Be aware that the action function you choose must accommodate the</span>
<span class="linecomment">;;  object you choose as its only argument.  Also, completion of the</span>
<span class="linecomment">;;  function candidate itself is lax, so you can enter a lambda form</span>
<span class="linecomment">;;  as the action.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Objects that are naturally associated with names are treated</span>
<span class="linecomment">;;  differently, depending on the type.  Besides Anything types, the</span>
<span class="linecomment">;;  following object types are used for named objects: `buffer',</span>
<span class="linecomment">;;  `command', `face', `frame', `function', `option', `process',</span>
<span class="linecomment">;;  `symbol', `variable', `window'.  For all of these except `window',</span>
<span class="linecomment">;;  the name of the object is used.  For `window', the candidate</span>
<span class="linecomment">;;  objects are the names of the buffers that are currently shown in a</span>
<span class="linecomment">;;  window (on any frame).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You'll note that some types are treated both ways, 1) using named</span>
<span class="linecomment">;;  objects and 2) using symbols whose values are objects.  An example</span>
<span class="linecomment">;;  is `frame' and `framep': the completion candidates (objects) for</span>
<span class="linecomment">;;  type `frame' are frame names; the candidates for type `framep' are</span>
<span class="linecomment">;;  symbols whose values are frames.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles with Anything")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Apropos Completions").</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Progressive Completion").</span>
 
<span class="linecomment">;;(@* "Icicles with Anything")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles with Anything</span>
<span class="linecomment">;;  ---------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Library Anything (`anything.el') lets you define object types and</span>
<span class="linecomment">;;  associate actions with them.  It provides command `anything',</span>
<span class="linecomment">;;  which you can use to apply an action to an object, choosing the</span>
<span class="linecomment">;;  object first by name.  All objects (of all types) that have a name</span>
<span class="linecomment">;;  that matches your input are candidates.  You can use command</span>
<span class="linecomment">;;  `anything' while in Icicle mode; it has the same behavior with</span>
<span class="linecomment">;;  Icicles as without it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles also integrates some Anything features within its own</span>
<span class="linecomment">;;  completion environment, so that you can use Icicles features such</span>
<span class="linecomment">;;  as progressive completion at the same time.  In particular, you</span>
<span class="linecomment">;;  can act on multiple Anything objects in the same command</span>
<span class="linecomment">;;  invocation, and you can act on them using multiple Anything</span>
<span class="linecomment">;;  actions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-anything' (alias `any') is just command</span>
<span class="linecomment">;;  `icicle-object-action' (alias `a') restricted to Anything types -</span>
<span class="linecomment">;;  see (@&gt; "Icicles OO: Object-Action Interaction").  It is more</span>
<span class="linecomment">;;  convenient than `a' if you know that you want to use an Anything</span>
<span class="linecomment">;;  type, because the set of type candidates to choose from is more</span>
<span class="linecomment">;;  limited.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you act on an object of an Anything type, you are not</span>
<span class="linecomment">;;  prompted for the action ("how").  The default Anything action is</span>
<span class="linecomment">;;  applied, or you can choose a different Anything action.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `any' (or command `a' when applied to an Anything type) is</span>
<span class="linecomment">;;  a multi-command (see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands")):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-RET', `C-mouse-2', and so on perform the default Anything</span>
<span class="linecomment">;;    action on each chosen object.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-S-RET', `C-S-mouse-2', and so on prompt you, for each chosen</span>
<span class="linecomment">;;    object, to choose one or more Anything actions (with</span>
<span class="linecomment">;;    completion).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can thus act on any number of Anything objects in any number</span>
<span class="linecomment">;;  of Anything ways, all in the same `any' command invocation.  And</span>
<span class="linecomment">;;  you can of course use Icicles completion and cycling to choose.</span>
<span class="linecomment">;;  User option `icicle-anything-transform-candidates-flag' determines</span>
<span class="linecomment">;;  whether Anything function `anything-transform-candidates' is</span>
<span class="linecomment">;;  applied to displayed Anything candidates in Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here's an example of using command `any'.  Let's assume that you</span>
<span class="linecomment">;;  have an `action' entry such as this in `anything-type-attributes'</span>
<span class="linecomment">;;  for the Anything type `command':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (action ("Call interactively"</span>
<span class="linecomment">;;           . (lambda (command-name)</span>
<span class="linecomment">;;               (call-interactively (intern command-name))))</span>
<span class="linecomment">;;          ("Describe command"</span>
<span class="linecomment">;;           . (lambda (command-name)</span>
<span class="linecomment">;;               (describe-function (intern command-name))))</span>
<span class="linecomment">;;          ("Add command to kill ring" . kill-new)</span>
<span class="linecomment">;;          ("Go to command's definition"</span>
<span class="linecomment">;;           . (lambda (command-name)</span>
<span class="linecomment">;;               (find-function (intern command-name)))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This defines four actions for objects of type `command', the</span>
<span class="linecomment">;;  default action being the first listed ("Call interactively").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You enter command `any', choose the Anything type `command', and</span>
<span class="linecomment">;;  then choose the command `icicle-face-list' to act on:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x any RET</span>
<span class="linecomment">;;    What (type): command RET</span>
<span class="linecomment">;;    Which (command): icicle-face-list RET</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This invokes command `icicle-face-list', because the default</span>
<span class="linecomment">;;  Anything action for an object of type `command' is to call it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `C-RET' instead of `RET' when choosing command</span>
<span class="linecomment">;;  `icicle-face-list', then you remain within the `any' invocation,</span>
<span class="linecomment">;;  and you can do something with another command after</span>
<span class="linecomment">;;  `icicle-face-list'.  If you use `C-S-RET' when choosing a command,</span>
<span class="linecomment">;;  then you are prompted for the action to invoke for that command:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Which (command): icicle-face-list C-S-RET</span>
<span class="linecomment">;;    How (action): Go to command's definition RET</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you choose the Anything action "Go to command's definition",</span>
<span class="linecomment">;;  then, well, that's what happens: here, you go to the definition of</span>
<span class="linecomment">;;  `icicle-face-list'.  Again, you could use `C-RET' instead of</span>
<span class="linecomment">;;  `RET', to perform this action on the command and then choose and</span>
<span class="linecomment">;;  apply (via `RET' or `C-RET') another action to the same command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  After you've stopped (via `RET' or `C-g') acting on command</span>
<span class="linecomment">;;  `icicle-face-list', you can clear the minibuffer (using `M-k') and</span>
<span class="linecomment">;;  type another command to act on, and so on.  Or, you can stop (via</span>
<span class="linecomment">;;  `RET' or `C-g') and end the invocation of command `any'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  At each prompt, you can use (apropos or prefix) completion or</span>
<span class="linecomment">;;  cycling to pick a candidate.  So, for instance, using completion,</span>
<span class="linecomment">;;  you could simply do this to choose `command', `icicle-face-list',</span>
<span class="linecomment">;;  and "Go to command definition":</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x any RET c RET face-l S-TAB C-S-RET g TAB RET</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles enhances Anything by providing multi-command features, as</span>
<span class="linecomment">;;  well as by providing all of the other standard Icicles features:</span>
<span class="linecomment">;;  apropos and prefix completion, cycling, progressive completion,</span>
<span class="linecomment">;;  help on individual candidates, and so on.  On the other hand,</span>
<span class="linecomment">;;  Anything by itself provides some features that Icicles does not</span>
<span class="linecomment">;;  exploit.  The aim of command `any' is to give you the basic</span>
<span class="linecomment">;;  Anything features in an Icicles completion context.</span>
 
<span class="linecomment">;;(@* "Multi-Completions")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Multi-Completions</span>
<span class="linecomment">;;  -----------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is about using completion candidates that are</span>
<span class="linecomment">;;  composed of more than one part: strings that you can complete</span>
<span class="linecomment">;;  against separately and simultaneously.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicles Multi-Completion Commands")</span>
<span class="linecomment">;;  ** Icicles Multi-Completion Commands **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Have you ever used standard Emacs command `apropos-documentation'?</span>
<span class="linecomment">;;  It searches the doc strings of all Emacs-Lisp symbols for matches</span>
<span class="linecomment">;;  to an input regexp, and displays the hits.  It can be useful when</span>
<span class="linecomment">;;  you don't remember the name of a function or variable but you can</span>
<span class="linecomment">;;  guess at terms that might occur in its doc string.  Typically,</span>
<span class="linecomment">;;  people resort to it only after first trying apropos commands that</span>
<span class="linecomment">;;  match against the function or variable name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The idea behind `apropos-documentation' also motivates Icicles</span>
<span class="linecomment">;;  command `icicle-doc'.  This is a multi-command (see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands")),</span>
<span class="linecomment">;;  so you can use `C-RET' and `C-next' to browse the regexp matches,</span>
<span class="linecomment">;;  displaying the documentation of each match in turn, and you can</span>
<span class="linecomment">;;  change the regexp to get different matches during the same command</span>
<span class="linecomment">;;  invocation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Like `apropos-documentation', `icicle-doc' lets you match a regexp</span>
<span class="linecomment">;;  against the doc strings of symbols such as functions, variables,</span>
<span class="linecomment">;;  and faces.  You can of course use progressive completion to match</span>
<span class="linecomment">;;  multiple regexps.  Here, for example, is a query that shows all doc</span>
<span class="linecomment">;;  strings (functions, variables, faces - a lot! of doc strings)</span>
<span class="linecomment">;;  that match both `mail' and `mode line', in either order,</span>
<span class="linecomment">;;  as completion candidates:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-doc RET mail S-SPC mode line</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You cannot do that with vanilla Emacs `apropos-documentation' or</span>
<span class="linecomment">;;  with any other vanilla Emacs `apropos*' command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Commands `icicle-vardoc', `icicle-fundoc', and `icicle-plist' are</span>
<span class="linecomment">;;  similar to `icicle-doc' in the kind of functionality they provide.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Each of these commands gathers a tremendous amount of information</span>
<span class="linecomment">;;  to construct an initial set of completion candidates based on all</span>
<span class="linecomment">;;  existing Emacs symbols (in the standard `obarray').  This is</span>
<span class="linecomment">;;  time-consuming.  Since the set of symbols that have property lists</span>
<span class="linecomment">;;  or that name functions, variables, or faces changes little, you</span>
<span class="linecomment">;;  can optionally bypass this gathering and reuse the last initial</span>
<span class="linecomment">;;  set of candidates for that command.  You do this by invoking the</span>
<span class="linecomment">;;  command using a prefix argument (non-negative prefix arg, for</span>
<span class="linecomment">;;  `icicle-vardoc').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Each of these particular commands also uses Icicles</span>
<span class="linecomment">;;  multi-completion.  A "multi-completion" is a completion candidate</span>
<span class="linecomment">;;  that has multiple parts.  A multi-completion command lets your</span>
<span class="linecomment">;;  input match any or all parts individually, at the same time.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Commands `icicle-vardoc' and `icicle-fundoc' let you match both</span>
<span class="linecomment">;;    the function or variable name and the doc string.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Command `icicle-doc' lets you match any combination of the</span>
<span class="linecomment">;;    following:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - the function, variable, or face name</span>
<span class="linecomment">;;    - the type: FUNCTION, VARIABLE, or FACE</span>
<span class="linecomment">;;    - the doc string</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Command `icicle-plist' lets you match both a symbol name and its</span>
<span class="linecomment">;;    property list (as a string).  You can use it to find symbols</span>
<span class="linecomment">;;    with certain property-list keys or values.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Command `icicle-describe-option-of-type' (bound to `C-h C-o' in</span>
<span class="linecomment">;;    Icicle mode) lets you match both an option name and the option's</span>
<span class="linecomment">;;    `defcustom' type definition.  There are several ways to match</span>
<span class="linecomment">;;    type definitions, controlled by the prefix argument - see the</span>
<span class="linecomment">;;    command's doc string.  You can match a type directly or taking</span>
<span class="linecomment">;;    type inheritance into account.  You can match a type as a sexp</span>
<span class="linecomment">;;    or using a regexp.  You can match a type expression or match the</span>
<span class="linecomment">;;    option's current value against a type.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Other Icicles commands that use multi-completion include</span>
<span class="linecomment">;;  `icicle-locate-file', `icicle-locate-file-other-window',</span>
<span class="linecomment">;;  `icicle-recent-file', and `icicle-recent-file-other-window'.</span>
<span class="linecomment">;;  These commands let you match against two-part multi-completion</span>
<span class="linecomment">;;  candidates that are composed of an absolute file name and the</span>
<span class="linecomment">;;  file's last modification date.  This means that you can easily</span>
<span class="linecomment">;;  find those notes you took sometime last week...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The way multi-completion commands work is a bit inelegant perhaps,</span>
<span class="linecomment">;;  and it can take some getting used to, but it is quite powerful,</span>
<span class="linecomment">;;  letting you do things with completion that are otherwise</span>
<span class="linecomment">;;  impossible.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In the case of commands that use two-part completions, you provide</span>
<span class="linecomment">;;  two regexps as input, one to match the name of a symbol (e.g. a</span>
<span class="linecomment">;;  function or variable) and one to match some associated information</span>
<span class="linecomment">;;  (doc string, property list, or type definition).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, since completion candidates are not actually multipart,</span>
<span class="linecomment">;;  you in fact type a single regexp that is the concatenation of the</span>
<span class="linecomment">;;  two.  You join these two regexps using `icicle-list-join-string'</span>
<span class="linecomment">;;  (a user option), which, by default, is `^G^J', that is, a</span>
<span class="linecomment">;;  control-G character followed by a control-J (newline) character.</span>
<span class="linecomment">;;  As always, you can input control characters using `C-q', so to</span>
<span class="linecomment">;;  input `^G^J' you can use `C-q C-g C-q C-j'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, in Icicles, `C-j' (newline) is self-inserting during</span>
<span class="linecomment">;;  completion, so you don't need to quote it with `C-q' - you can use</span>
<span class="linecomment">;;  just `C-q C-g C-j'.  Better yet, you can use `C-M-j'</span>
<span class="linecomment">;;  (`icicle-insert-list-join-string') to insert `^G^J'.  This has the</span>
<span class="linecomment">;;  added benefit (in Emacs 22 or later) of hiding the `^G' - it's</span>
<span class="linecomment">;;  there, but you don't see it.  This hiding is only cosmetic; you</span>
<span class="linecomment">;;  still match the characters `^G' and `^J'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In the same way, Icicles hides the `^G' part of `^G^J' in</span>
<span class="linecomment">;;  *Completions*, so the join string appears as a newline character.</span>
<span class="linecomment">;;  This sleight of hand is used only when `icicle-list-join-string'</span>
<span class="linecomment">;;  has its (ugly but useful) default value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an example of using a multi-completion command, you can use</span>
<span class="linecomment">;;  this to match a function name that contains `dired' and a doc</span>
<span class="linecomment">;;  string that contains `file':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-fundoc dired^G^Jfile S-TAB</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That is, you type this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-fundoc dired C-q C-g C-j file S-TAB</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  or this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-fundoc dired C-M-j file S-TAB</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Well, almost.  The way it actually works is that the completion</span>
<span class="linecomment">;;  candidates are themselves formed by concatenating symbol names</span>
<span class="linecomment">;;  with their doc strings, using `icicle-list-join-string'.  Your</span>
<span class="linecomment">;;  input regexp is matched against those candidates.  This means that</span>
<span class="linecomment">;;  the input regexp `dired^G^Jfile' would actually match only</span>
<span class="linecomment">;;  function names that *end* with `dired' and doc strings that</span>
<span class="linecomment">;;  *begin* with `file'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To match `file' against any part of the doc string, you must</span>
<span class="linecomment">;;  explicitly link the two component regexps with a regexp that</span>
<span class="linecomment">;;  matches anything.  If you want to search only the first lines of</span>
<span class="linecomment">;;  doc strings, you can use `.*' to do that: `dired.*^G^J.*file' will</span>
<span class="linecomment">;;  match all functions whose names contain `dired' and whose doc</span>
<span class="linecomment">;;  strings' first lines contain `file'.  This is because `.' matches</span>
<span class="linecomment">;;  any character except a newline.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you want to search the entire doc strings (or property lists,</span>
<span class="linecomment">;;  for `icicle-plist'), then you can use a connecting regexp such as</span>
<span class="linecomment">;;  `[^^G]*', which matches any sequence of characters except</span>
<span class="linecomment">;;  character `^G'.  That's `^' followed by the Control-g character</span>
<span class="linecomment">;;  (input using `C-q C-g'), not `^' followed by `^' and `G'.  To</span>
<span class="linecomment">;;  match any character, even `^G', you can use `\(.\|^J\)'.  (It's</span>
<span class="linecomment">;;  too bad that Emacs doesn't have a dot-matches-newline-too option.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here, `.*' is used to match anything following `dired' in the</span>
<span class="linecomment">;;  function name, and `[^^G]*' is used to match anything (including</span>
<span class="linecomment">;;  newline) before `file' in the doc string.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-fundoc dired.*^G^J[^^G]*file S-TAB</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That is, you type (without the spaces):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-fundoc dired.* C-M-j [^ C-q C-g]* file S-TAB</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "How Multi-Completions Work")</span>
<span class="linecomment">;;  ** How Multi-Completions Work **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These commands that accept a multipart regexp are examples of</span>
<span class="linecomment">;;  Icicles multi-completion.  Icicles extends standard function</span>
<span class="linecomment">;;  `completing-read' so that it will accept, as the set of completion</span>
<span class="linecomment">;;  candidates, an alist argument whose candidates are not only</span>
<span class="linecomment">;;  individual strings but can also be lists of strings.  Each string</span>
<span class="linecomment">;;  in the list is one part of a multipart completion candidate, that</span>
<span class="linecomment">;;  is, a multi-completion.  The strings are joined together pairwise</span>
<span class="linecomment">;;  using `icicle-list-join-string' by `completing-read'.  Commands</span>
<span class="linecomment">;;  `icicle-fundoc' and`icicle-vardoc' each use lists of two strings</span>
<span class="linecomment">;;  (name and doc), but a multi-completion can have any number of</span>
<span class="linecomment">;;  strings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Why is the default value of `icicle-list-join-string' so odd:</span>
<span class="linecomment">;;  `^G^J'?  You can use any string you like, but here is the</span>
<span class="linecomment">;;  rationale behind the default choice:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - ^G does not normally occur in simple strings such as doc strings</span>
<span class="linecomment">;;  - a newline (^J) visually separates the multiple component strings</span>
<span class="linecomment">;;  - ^G^J is not too difficult to enter: `C-M-j' or `C-q C-g C-j'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is important that the value of `icicle-list-join-string' not be</span>
<span class="linecomment">;;  something that is, itself, likely to match any of the candidates.</span>
<span class="linecomment">;;  Otherwise, it would not serve its role as separator.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I find that it helps a bit (in Emacs 22 or later) to customize</span>
<span class="linecomment">;;  face `escape-glyph', which is used for control characters such as</span>
<span class="linecomment">;;  `^G', in such a way that it stands out a bit, especially because</span>
<span class="linecomment">;;  control characters can be used in regexps that also use `^' as a</span>
<span class="linecomment">;;  special character.  I use an orange background with a blue</span>
<span class="linecomment">;;  foreground for this face.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because multi-completions often extend over multiple lines, and</span>
<span class="linecomment">;;  candidates in buffer *Completion* appear one right after the</span>
<span class="linecomment">;;  other, it's helpful to add additional separation between</span>
<span class="linecomment">;;  multi-completion candidates.  That is the purpose of user option</span>
<span class="linecomment">;;  `icicle-list-end-string', whose default value is "^J^J" (two</span>
<span class="linecomment">;;  newline characters).  It is automatically appended to each</span>
<span class="linecomment">;;  candidate, for purposes of both display and matching.  Remember</span>
<span class="linecomment">;;  that it is part of each multi-completion candidate, especially if</span>
<span class="linecomment">;;  you use a regexp that ends in `$', matching the end of the</span>
<span class="linecomment">;;  candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Multi-Completions Let You Match Multiple Things in Parallel")</span>
<span class="linecomment">;;  ** Multi-Completions Let You Match Multiple Things in Parallel **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Consider the command `describe-option-of-type', defined in my</span>
<span class="linecomment">;;  library `help-fns+.el' (or `help+.el', for Emacs 20).  This lets</span>
<span class="linecomment">;;  you first pick a `defcustom' type using completion and then pick</span>
<span class="linecomment">;;  an option of that type to describe.  There are two separate,</span>
<span class="linecomment">;;  sequential acts of completion.  For each completion act, your</span>
<span class="linecomment">;;  current input defines a set of matches.  You can see all option</span>
<span class="linecomment">;;  types that match, say, the regexp `.*string', which means all</span>
<span class="linecomment">;;  types that contain `string'.  After you choose one of those types,</span>
<span class="linecomment">;;  you can see all options of that type whose names start with</span>
<span class="linecomment">;;  `icicle' and then pick one.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can thus tweak the type regexp to filter types, and you can</span>
<span class="linecomment">;;  tweak the name regexp to filter option names.  And you can of</span>
<span class="linecomment">;;  course use progressive completion to whittle down either set of</span>
<span class="linecomment">;;  matches, piecemeal.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What you cannot do, however, using `describe-option-of-type' is</span>
<span class="linecomment">;;  filter both sets at the same time: narrow down the set of type</span>
<span class="linecomment">;;  matches and name matches simultaneously.  For that, you need</span>
<span class="linecomment">;;  Icicles multi-completion.  Without it, you must commit 100% to a</span>
<span class="linecomment">;;  type before you can choose among the options of that type.  With</span>
<span class="linecomment">;;  it, you can change the type (or the name) part of your input</span>
<span class="linecomment">;;  regexp on the fly, and see immediately the set of matching names</span>
<span class="linecomment">;;  (or types) as well.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Multi-Completions vs `completing-read-multiple'")</span>
<span class="linecomment">;;  ** Multi-Completions vs `completing-read-multiple' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that there is (only) a superficial similarity between Icicles</span>
<span class="linecomment">;;  multi-completion and the functionality provided by function</span>
<span class="linecomment">;;  `completing-read-multiple' of standard Emacs library `crm.el'.</span>
<span class="linecomment">;;  The latter lets you complete multiple strings in the minibuffer,</span>
<span class="linecomment">;;  one at a time.  It involves ordinary Emacs prefix completion, and</span>
<span class="linecomment">;;  it uses the same set of completion candidates for each of the</span>
<span class="linecomment">;;  strings in the input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By contrast, Icicles multi-completion completes each part of your</span>
<span class="linecomment">;;  input against a different set of completion candidates.  For</span>
<span class="linecomment">;;  example, when you use `icicle-vardoc', it completes the</span>
<span class="linecomment">;;  variable-name part of your input against the names of defined</span>
<span class="linecomment">;;  variables, and the variable-description part against the doc</span>
<span class="linecomment">;;  strings of defined variables.  Standard Emacs command</span>
<span class="linecomment">;;  `completing-read-multiple' lets you complete several different</span>
<span class="linecomment">;;  variable names at the same minibuffer prompt, but they each</span>
<span class="linecomment">;;  complete against the same set of variable names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Multi-completion matches a list of regexps in parallel.  See also</span>
<span class="linecomment">;;  the description of `M-*', which matches a list of regexps in</span>
<span class="linecomment">;;  series: (@file :file-name "icicles-doc1.el" :to "Progressive Completion").</span>
<span class="linecomment">;;  You can combine these features, of course.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Sorting Candidates by Their Second Part")</span>
<span class="linecomment">;;  ** Sorting Candidates by Their Second Part **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Most multi-completions have two parts.  Typically, the first part</span>
<span class="linecomment">;;  is the main part, that is, the part that you will most frequently</span>
<span class="linecomment">;;  complete against.  Many candidate sort orders involve some flavor</span>
<span class="linecomment">;;  of alphabetic order, and this means alphabetizing first with</span>
<span class="linecomment">;;  respect to the first multi-completion part.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, it can sometimes be convenient to sort instead by the</span>
<span class="linecomment">;;  second part first.  That is what the Icicles sort order "by 2nd</span>
<span class="linecomment">;;  parts alphabetically" is for.  You can use it, for example, with</span>
<span class="linecomment">;;  command `icicle-locate-file' to sort file-name candidates first by</span>
<span class="linecomment">;;  date, and then by file-name for the same date.  This gives you an</span>
<span class="linecomment">;;  easy way to look up files that you modified during a given time</span>
<span class="linecomment">;;  period.  For example, your input regexp can limit candidates to</span>
<span class="linecomment">;;  those files last modified sometime in July, 2008, and you can then</span>
<span class="linecomment">;;  access these chronologically (by cycling or in buffer</span>
<span class="linecomment">;;  *Completions*).  And don't forget that you can always reverse the</span>
<span class="linecomment">;;  current sort order, using `C-N C-,' where N is an integer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Programming Multi-Completions") for information about</span>
<span class="linecomment">;;    changing the appearance and behavior of Icicles</span>
<span class="linecomment">;;    multi-completions using Emacs-Lisp code.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Sorting Candidates and Removing Duplicates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Progressive Completion")</span>
 
<span class="linecomment">;;(@* "Fuzzy Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Fuzzy Completion</span>
<span class="linecomment">;;  ----------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are a few different kinds of what might be called "fuzzy"</span>
<span class="linecomment">;;  matching used in Icicles completion, in addition to apropos</span>
<span class="linecomment">;;  (regexp) matching and prefix matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Fuzzy - This method uses a fairly sophisticated matching</span>
<span class="linecomment">;;    algorithm that seems to account for various typing mistakes.</span>
<span class="linecomment">;;    This algorithm is provided by library `fuzzy-match.el', so I</span>
<span class="linecomment">;;    call its use in Icicles `fuzzy' completion.  You must have</span>
<span class="linecomment">;;    library `fuzzy-match.el' to use this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Scatter - This is a simple, poor man's fuzzy matching method</span>
<span class="linecomment">;;    that I call `scatter' matching.  Ido calls it `flex' matching.</span>
<span class="linecomment">;;    The TextMate editor has the same thing for file-name matching</span>
<span class="linecomment">;;    (only), without naming it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Levenshtein - This method checks whether two strings differ by</span>
<span class="linecomment">;;    at most a given number of character operations, the so-called</span>
<span class="linecomment">;;    "Levenshtein distance".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use fuzzy completion in place of prefix completion</span>
<span class="linecomment">;;  (`TAB').  You can use the scatter or Levenshtein completion in</span>
<span class="linecomment">;;  place of apropos completion (`S-TAB').  You can change completion</span>
<span class="linecomment">;;  methods easily at any time, by hitting a key in the minibuffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-(' to toggle between prefix and fuzzy completion, for `TAB'.</span>
<span class="linecomment">;;  * `M-(' to cycle among apropos, scatter, and Levenshtein</span>
<span class="linecomment">;;    completion, for `S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Of these methods, prefix completion and apropos completion are by</span>
<span class="linecomment">;;  far the most useful, followed, in order, by scatter, fuzzy, and</span>
<span class="linecomment">;;  Levenshtein completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Besides these methods, remember that you can get ordinary</span>
<span class="linecomment">;;  substring matching with `S-TAB' by using `C-`' to turn off</span>
<span class="linecomment">;;  (toggle) escaping of regexp special characters.  With special</span>
<span class="linecomment">;;  characters escaped, `S-TAB' does literal substring completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Scatter-Match Completion")</span>
<span class="linecomment">;;  ** Scatter-Match Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The idea behind scatter-match completion is very simple: input</span>
<span class="linecomment">;;  characters are matched in order against completion candidates, but</span>
<span class="linecomment">;;  possibly with intervening characters.  That is, your input</span>
<span class="linecomment">;;  scatter-matches a completion candidate if each character is also</span>
<span class="linecomment">;;  in the candidate, and the character order is respected.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What this really amounts to is matching input `abc' as if it were</span>
<span class="linecomment">;;  the regexp `a.*b.*c'.  That's all.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use Icicles scatter matching at any time in place of</span>
<span class="linecomment">;;  apropos (regexp) matching.  Unlike the case of fuzzy completion</span>
<span class="linecomment">;;  (see below), you can use it to complete file names also.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The type of completion matching that is used when you hit `S-TAB'</span>
<span class="linecomment">;;  is controlled by user option `icicle-apropos-match-fns-alist'.  By</span>
<span class="linecomment">;;  default, the first method in this list is used for matching.  You</span>
<span class="linecomment">;;  can use `M-(' (command `icicle-next-apropos-match-function') in</span>
<span class="linecomment">;;  the minibuffer to cycle among the matching methods, which by</span>
<span class="linecomment">;;  default are apropos matching and scatter matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Fuzzy-Match Completion")</span>
<span class="linecomment">;;  ** Fuzzy-Match Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Fuzzy completion takes more explaining.  If you use library</span>
<span class="linecomment">;;  `fuzzy-match.el', then you can use fuzzy input matching during</span>
<span class="linecomment">;;  Icicles prefix completion (`TAB').  Icicles fuzzy prefix</span>
<span class="linecomment">;;  completion is controlled by option `icicle-fuzzy-completion-flag',</span>
<span class="linecomment">;;  which you can toggle at any time from the minibuffer using `C-('</span>
<span class="linecomment">;;  (command `icicle-toggle-fuzzy-completion').  When fuzzy completion</span>
<span class="linecomment">;;  is turned on, `TAB' fuzzy-completes your input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Fuzzy matching is described in detail in the commentary of library</span>
<span class="linecomment">;;  `fuzzy-match.el'; please refer to that documentation.  Here are</span>
<span class="linecomment">;;  some things to keep in mind when you use Icicles fuzzy completion:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * File-name completion is never fuzzy.</span>
<span class="linecomment">;;  * Fuzzy completion is always case-sensitive.  This means that</span>
<span class="linecomment">;;    `C-A' in the minibuffer has no effect on fuzzy completion.</span>
<span class="linecomment">;;  * Fuzzy completion always takes a space prefix in your input into</span>
<span class="linecomment">;;    account.  This means that `M-_' in the minibuffer has no effect</span>
<span class="linecomment">;;    on fuzzy completion.</span>
<span class="linecomment">;;  * Fuzzy completion candidates are always sorted by decreasing</span>
<span class="linecomment">;;    match strength.  This means that you cannot use `C-,' in the</span>
<span class="linecomment">;;    minibuffer to sort candidates differently.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Fuzzy completion is a form of prefix completion in which some</span>
<span class="linecomment">;;  input characters might not be present in a matched candidate.</span>
<span class="linecomment">;;  Matching finds the candidates that have the most characters in</span>
<span class="linecomment">;;  common with your input, in the same order and with a minimum of</span>
<span class="linecomment">;;  non-matching characters.  It can skip over non-matching</span>
<span class="linecomment">;;  characters, as long as the number of characters skipped in the</span>
<span class="linecomment">;;  candidate is less that those following them that match.  After the</span>
<span class="linecomment">;;  matching candidates are found, they are sorted by skip length and</span>
<span class="linecomment">;;  then candidate length.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here are some examples:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Input         Completion Domain  Matches (Candidates)</span>
<span class="linecomment">;;  -----         -----------------  --------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  abc           {xxabcxx, xabcxxx,</span>
<span class="linecomment">;;                          xabx}    {xabcxxx, xxabcxx}</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  point-mx      Emacs variables    {point-max, point-max-marker}</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  begining-of-l Emacs commands     {beginning-of-line,</span>
<span class="linecomment">;;                                    beginning-of-line-text,</span>
<span class="linecomment">;;                                    move-beginning-of-line,</span>
<span class="linecomment">;;                                    widget-beginning-of-line}</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The last example shows that although fuzzy matching is a kind of</span>
<span class="linecomment">;;  prefix matching, your input is not necessarily a prefix of each</span>
<span class="linecomment">;;  matching candidate.  It is prefix matching because it tries to</span>
<span class="linecomment">;;  match your input starting at its beginning.  This input prefix is</span>
<span class="linecomment">;;  matched against candidate substrings, not necessarily candidate</span>
<span class="linecomment">;;  prefixes, but the non-matching part (if any) preceding the matched</span>
<span class="linecomment">;;  substring must not be longer than the matching part.  That is,</span>
<span class="linecomment">;;  non-matching substrings can be skipped over, but they must be no</span>
<span class="linecomment">;;  longer than the matching substrings that follow them.  If an input</span>
<span class="linecomment">;;  prefix does not match under these conditions, it is skipped over.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  After matching an input prefix this way, the same process is</span>
<span class="linecomment">;;  repeated, recursively, for input text following that prefix and</span>
<span class="linecomment">;;  for match positions following the matches found.  That is, after</span>
<span class="linecomment">;;  each such prefix match, the process starts again where it left off</span>
<span class="linecomment">;;  in both the input and the candidates.  The resulting matches</span>
<span class="linecomment">;;  contain one or more substrings of your input that are each at</span>
<span class="linecomment">;;  least as long as the non-matching parts that immediately precede</span>
<span class="linecomment">;;  them.  Only matches with the highest number of matching characters</span>
<span class="linecomment">;;  are retained.  They are sorted by two criteria: (1) nearness of</span>
<span class="linecomment">;;  matches to the start of the candidate and (2) candidate length.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The fuzzy-match algorithm is detailed in library `fuzzy-match.el'.</span>
<span class="linecomment">;;  However, it is easier to get a feel for what it does by trying it</span>
<span class="linecomment">;;  than by reading any description.  Just give it a try.  Do not</span>
<span class="linecomment">;;  expect it to rival apropos completion in power or expressivity,</span>
<span class="linecomment">;;  however.  Instead, think of it as prefix completion for lazy or</span>
<span class="linecomment">;;  inaccurate typists!  If that sounds like you, then you might find</span>
<span class="linecomment">;;  it useful.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an example, here are some command-name candidates for the input</span>
<span class="linecomment">;;  `fo' (there are lots more):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  fortune          forms-mode       focus-frame</span>
<span class="linecomment">;;  follow-mode      forward-sexp     forward-list</span>
<span class="linecomment">;;  forward-word     forward-line     forward-page</span>
<span class="linecomment">;;  ...</span>
<span class="linecomment">;;  ifconfig         info             Info-up</span>
<span class="linecomment">;;  Info-edit        Info-next        Info-help</span>
<span class="linecomment">;;  ...</span>
<span class="linecomment">;;  Info-mouse-follow-nearest-node    Info-goto-emacs-key-command-node</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And here are all the command-name candidates for the input `fol':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  follow-mode            follow-delete-other-windows-and-split</span>
<span class="linecomment">;;  Info-last              info-lookup-file       info-lookup-reset</span>
<span class="linecomment">;;  Info-last-preorder     info-lookup-symbol     Info-last-menu-item</span>
<span class="linecomment">;;  nnfolder-generate-active-file     mh-folder-mode</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The first thing to notice is the distribution of candidates for</span>
<span class="linecomment">;;  input `fo'.  Candidates are in decreasing order of match fit:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The nearer the match to the start of the candidate, the better</span>
<span class="linecomment">;;    the fit.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The greater the ratio of matched text to unmatched text, the</span>
<span class="linecomment">;;    better the fit.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note too the candidate `ifconfig'.  First, note that it has no</span>
<span class="linecomment">;;  strict match for substring `fo'.  Its match is in fact in two</span>
<span class="linecomment">;;  parts: `f', then `o'.  Second, note that it is considered a better</span>
<span class="linecomment">;;  fuzzy match than the candidate `info'.  This is because its match</span>
<span class="linecomment">;;  (`f') is nearer to the start of the candidate (second character,</span>
<span class="linecomment">;;  versus third).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The second thing to notice is that when you type the third input</span>
<span class="linecomment">;;  character, `l', the candidates are not a subset of the original</span>
<span class="linecomment">;;  set that matches `fo'.  The candidates in the second screenshot</span>
<span class="linecomment">;;  all match `fol' in a fuzzy way, even though one of them,</span>
<span class="linecomment">;;  `mh-folder-mode', does not match `fo' sufficiently well to be</span>
<span class="linecomment">;;  included as a candidate.  Why?  Because in the `fo' case, the</span>
<span class="linecomment">;;  match is only two characters long and it starts after three</span>
<span class="linecomment">;;  non-matching characters.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For both inputs: If all input prefixes are fair game for matching,</span>
<span class="linecomment">;;  why doesn't `*Completions*' also include other command names that</span>
<span class="linecomment">;;  match only the prefix `f' and nothing else?  Because there is at</span>
<span class="linecomment">;;  least one match that matches more than that - only the best</span>
<span class="linecomment">;;  matches are retained.  In this case, the best matches for input</span>
<span class="linecomment">;;  `fo' match both the `f' and the `o', and the best matches for</span>
<span class="linecomment">;;  input `fol' match all three of those characters.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Refer to `fuzzy-match.el' for a precise description of fuzzy</span>
<span class="linecomment">;;  matching.  It refers to "matchiness" for how many characters match</span>
<span class="linecomment">;;  and "closeness" for the ratio of number of characters matched to</span>
<span class="linecomment">;;  candidate length.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: It is not practical to try to highlight the exact candidate</span>
<span class="linecomment">;;  portions that match different parts of your input.  Because</span>
<span class="linecomment">;;  fuzzy-match input does not function as a literal string for</span>
<span class="linecomment">;;  matching purposes, it is more akin to substring matching than to</span>
<span class="linecomment">;;  plain prefix matching.  For this reason, regexp-match highlighting</span>
<span class="linecomment">;;  is used for fuzzy matching.  That is why you see the input `fo'</span>
<span class="linecomment">;;  highlighted in `*Completions*' candidates in other than just the</span>
<span class="linecomment">;;  prefix position.  It is also why the matching `f' and `o' in</span>
<span class="linecomment">;;  candidate `ifconfig' are not highlighted: for highlighting</span>
<span class="linecomment">;;  purposes, your input is treated as a regexp.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One takeaway here is that fuzzy completion is complicated.  Rather</span>
<span class="linecomment">;;  than try to understand how it works and think ahead in those</span>
<span class="linecomment">;;  terms, you just need to get a feel for it - learn by doing.  Have</span>
<span class="linecomment">;;  fun!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Levenshtein-Match Completion")</span>
<span class="linecomment">;;  ** Levenshtein-Match Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The "Levenshtein distance" is the maximum number of character</span>
<span class="linecomment">;;  insertions, deletions, or replacements that are needed to</span>
<span class="linecomment">;;  transform one string to another.  The more similar two strings</span>
<span class="linecomment">;;  are, the smaller their Levenshtein distance.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When this kind of completion is used, Icicles considers your input</span>
<span class="linecomment">;;  to match a completion candidate if their Levenshtein distance is</span>
<span class="linecomment">;;  no greater than the value of option `icicle-levenshtein-distance'.</span>
<span class="linecomment">;;  The default value of the option is 1, meaning that the difference</span>
<span class="linecomment">;;  is at most one character operation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Using a strict definition of the distance, this also requires the</span>
<span class="linecomment">;;  length of your input to be within the Levenshtein distance of the</span>
<span class="linecomment">;;  length of a completion candidate, for it to match.  That is quite</span>
<span class="linecomment">;;  restrictive.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is more flexible to consider your input to match a candidate if</span>
<span class="linecomment">;;  it is within `icicle-levenshtein-distance' of some *substring* of</span>
<span class="linecomment">;;  the candidate.  Because candidate substrings are tested, the</span>
<span class="linecomment">;;  length of your input need not be nearly the same as the candidate</span>
<span class="linecomment">;;  length.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you cycle among `S-TAB' completion methods using `M-(', there</span>
<span class="linecomment">;;  are thus two choices for Levenshtein completion: `Levenshtein' and</span>
<span class="linecomment">;;  `Levenshtein strict'.  The former is generally more useful.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The larger the value of `icicle-levenshtein-distance', the slower</span>
<span class="linecomment">;;  Levenshtein completion becomes, since it must test more</span>
<span class="linecomment">;;  possibilities.  Also, when the value is 1 (except for `Levenshtein</span>
<span class="linecomment">;;  strict'), Icicles uses a fast, special-case algorithm, and it</span>
<span class="linecomment">;;  highlights the matching parts of candidates in buffer</span>
<span class="linecomment">;;  `*Completions*'.  1 is the most useful value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If the value is other than 1 (or if it is 1 with `Levenshtein</span>
<span class="linecomment">;;  strict'), then you must also use library `levenshtein.el', and</span>
<span class="linecomment">;;  Levenshtein completion can be quite slow.  In that case, you will</span>
<span class="linecomment">;;  no doubt want to turn off incremental completion (`C-#').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Icicles Multi `M-x'")</span>
<span class="linecomment">;;    for completion of command abbreviations</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Apropos Completions")</span>
<span class="linecomment">;;    for completion with regexp matching</span>
 
<span class="linecomment">;;(@* "Completion in Other Buffers")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Completion in Other Buffers</span>
<span class="linecomment">;;  ---------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to input completion, you can use Icicles to complete</span>
<span class="linecomment">;;  words and symbols in other buffers, besides the minibuffer.</span>
<span class="linecomment">;;  Icicles enhances this completion in these ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Lisp symbol completion via `ESC-TAB' (`lisp-complete-symbol').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Word completion using the dynamic abbreviation of standard</span>
<span class="linecomment">;;     Emacs library `dabbrev.el', via `C-M-/'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Mailing information completion for BBDB (Insidious Big Brother</span>
<span class="linecomment">;;     Database).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. Word completion using the words and phrases in a thesaurus, via</span>
<span class="linecomment">;;     `C-c /' (requires library `synonyms.el').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  5. `TAB' completion of the following in Shell mode and ESS modes</span>
<span class="linecomment">;;     (and other, similar interpreters):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     * Commands</span>
<span class="linecomment">;;     * Previous inputs - commands plus their arguments</span>
<span class="linecomment">;;     * File names</span>
<span class="linecomment">;;     * Environment variables</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whenever multiple completion candidates are available, you can use</span>
<span class="linecomment">;;  Icicles completion, with all of its features: cycling of</span>
<span class="linecomment">;;  candidates (`TAB', `down', or `next'), apropos (regexp) completion</span>
<span class="linecomment">;;  (`S-TAB'), progressive completion (`M-SPC'), help on individual</span>
<span class="linecomment">;;  candidates (`C-M-RET'), and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Dynamic Abbreviation")</span>
<span class="linecomment">;;  ** Dynamic Abbreviation **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Library `dabbrev.el' lets you type a few characters in a buffer</span>
<span class="linecomment">;;  and then prefix-complete them (in the same buffer) to a full word</span>
<span class="linecomment">;;  or symbol name.  The completion candidates come from words or</span>
<span class="linecomment">;;  symbol names in buffers that you are editing.  This functionality</span>
<span class="linecomment">;;  is called "dynamic abbreviation", though that is not a very good</span>
<span class="linecomment">;;  term for it (words are completed, not abbreviated, dynamically).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Emacs, there are two ways to "dynamically abbreviate" text:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  a. `M-/' (command `dabbrev-expand') completes to a candidate word.</span>
<span class="linecomment">;;     Repeating it replaces the completion with a different one -</span>
<span class="linecomment">;;     that is, it cycles candidates in the text buffer (not in the</span>
<span class="linecomment">;;     minibuffer).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  b. `C-M-/' (command `dabbrev-completion') completes to the common</span>
<span class="linecomment">;;     prefix of all matching completion candidates.  Repeating it</span>
<span class="linecomment">;;     displays buffer `*Completions*' for you to choose a candidate.</span>
<span class="linecomment">;;     However, in this case, there is no way to cycle among the</span>
<span class="linecomment">;;     candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If there are many candidate completions, then cycling among them</span>
<span class="linecomment">;;  with `M-/' can be tedious.  You can use `C-M-/' to complete to a</span>
<span class="linecomment">;;  common prefix, thus narrowing the set of candidates, but then you</span>
<span class="linecomment">;;  lose the ability to cycle among them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If user option `icicle-redefine-standard-commands-flag' is non-nil</span>
<span class="linecomment">;;  (which is the case by default), then Icicles redefines command</span>
<span class="linecomment">;;  `dabbrev-completion' (it does not change `dabbrev-expand') so that</span>
<span class="linecomment">;;  it uses Icicles completion when there are multiple completions.</span>
<span class="linecomment">;;  You can use any Icicles features, such as apropos completion and</span>
<span class="linecomment">;;  candidate cycling.  In addition, you can even complete an empty</span>
<span class="linecomment">;;  prefix, starting from scratch with apropos completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "BBDB Completion")</span>
<span class="linecomment">;;  ** BBDB Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Library `bbdb.el', available at http://bbdb.sourceforge.net/, is a</span>
<span class="linecomment">;;  rolodex-like database program for GNU Emacs.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If user option `icicle-redefine-standard-commands-flag' is non-nil</span>
<span class="linecomment">;;  (which is the case by default), then Icicles redefines command</span>
<span class="linecomment">;;  `bbdb-complete-name' so that it uses Icicles completion when there</span>
<span class="linecomment">;;  are multiple completions.  You can use any Icicles features, such</span>
<span class="linecomment">;;  as apropos completion and candidate cycling.  For this feature to</span>
<span class="linecomment">;;  take effect, you must load BBDB before you load Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Thesaurus Completion")</span>
<span class="linecomment">;;  ** Thesaurus Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Library `synonyms.el' provides various features for defining a</span>
<span class="linecomment">;;  thesaurus and looking up words and phrases in it.  Command</span>
<span class="linecomment">;;  `icicle-complete-thesaurus-entry' takes advantage of these</span>
<span class="linecomment">;;  features.  You can use it to complete a word in a text buffer to</span>
<span class="linecomment">;;  any word or phrase in the thesaurus.  With the default value of</span>
<span class="linecomment">;;  option `icicle-top-level-key-bindings', this is bound to `C-c /'</span>
<span class="linecomment">;;  in Icicle mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Tip: You can use `icicle-complete-thesaurus-entry' to quickly</span>
<span class="linecomment">;;  check the spelling of a word.  If it is correctly spelled, then it</span>
<span class="linecomment">;;  appears as a complete completion (is highlighted as such in the</span>
<span class="linecomment">;;  minibuffer).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another Icicles command that uses the thesaurus is</span>
<span class="linecomment">;;  `icicle-insert-thesaurus-entry'.  It lets you use Icicles</span>
<span class="linecomment">;;  completion, cycling, and so on to insert thesaurus words and</span>
<span class="linecomment">;;  phrases in any buffer.  It does not complete the word at point.</span>
<span class="linecomment">;;  It is a multi-command (see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands")), so you</span>
<span class="linecomment">;;  can, within a single call to it, insert any number of thesaurus</span>
<span class="linecomment">;;  entries, in succession.  If you wanted to, you could write an</span>
<span class="linecomment">;;  entire book using a single call to</span>
<span class="linecomment">;;  `icicle-insert-thesaurus-entry'!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Both commands, `icicle-complete-thesaurus-entry' and</span>
<span class="linecomment">;;  `icicle-insert-thesaurus-entry', require that you first load</span>
<span class="linecomment">;;  library `synonyms.el'.  See library `synonyms.el' for more</span>
<span class="linecomment">;;  information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Completion in Comint Modes")</span>
<span class="linecomment">;;  ** Completion in Comint Modes **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `TAB' in a shell or similar buffer provides Icicles completion for</span>
<span class="linecomment">;;  command names, file names, and environment variables that are</span>
<span class="linecomment">;;  known to the shell (or other interpreter).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also complete input using your previous inputs as the set</span>
<span class="linecomment">;;  of candidates.  Just type something at the prompt, hit `C-c `',</span>
<span class="linecomment">;;  and pick one or more previous inputs to execute again (this uses</span>
<span class="linecomment">;;  `icicle-search', so it is a multi-command).  You need not</span>
<span class="linecomment">;;  re-execute the exact same shell command; you can edit your</span>
<span class="linecomment">;;  previous input before hitting `RET' to enter the command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These features are available for Comint mode and several modes</span>
<span class="linecomment">;;  that inherit from it, including Shell mode, Shell Script (SH)</span>
<span class="linecomment">;;  mode, various ESS modes (Emacs Speaks Statistics), Inferior</span>
<span class="linecomment">;;  Emacs-Lisp mode (IELM), Grand Unified Debugger (GUD) mode, Tcl</span>
<span class="linecomment">;;  mode, Rlogin mode, and NS Lookup mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Other Icicles Search Commands") for information about other</span>
<span class="linecomment">;;    Icicles enhancements for Comint mode and related modes</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Defining Buffer-Text Completion for Comint Modes") for</span>
<span class="linecomment">;;    information about how you can add Icicles completion to other</span>
<span class="linecomment">;;    modes that inherit from Comint mode</span>
 
<span class="linecomment">;;(@* "Customization and General Tips")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Customization and General Tips</span>
<span class="linecomment">;;  ------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section contains some tips on using Icicles and descriptions</span>
<span class="linecomment">;;  of Icicles user options.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "File-Name and Directory-Name Completion Tips") for tips on</span>
<span class="linecomment">;;    using Icicles to complete file names.  User options related to</span>
<span class="linecomment">;;    file-name and directory-name completion are presented there, not</span>
<span class="linecomment">;;    here.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Dealing With Large Candidate Sets")</span>
<span class="linecomment">;;    for tips on improving performance when dealing with a large</span>
<span class="linecomment">;;    number of completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Customizing Key Bindings") for information on customizing</span>
<span class="linecomment">;;    Icicles key bindings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using Icicles with Delete Selection Mode")</span>
<span class="linecomment">;;  ** Using Icicles with Delete Selection Mode **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles works especially well with Delete Selection mode, which I</span>
<span class="linecomment">;;  use and recommend.  (Likewise, for PC selection mode, which uses</span>
<span class="linecomment">;;  Delete Selection mode.)  In Delete Selection mode, whenever the</span>
<span class="linecomment">;;  region (selection) is active (highlighted), you can simply type to</span>
<span class="linecomment">;;  replace text in the region, or hit `DEL' (Backspace) or `C-d'</span>
<span class="linecomment">;;  (Delete) to delete the region.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, library `delsel.el', which provides Delete Selection</span>
<span class="linecomment">;;  mode, binds keys in minibuffer maps that are also bound by</span>
<span class="linecomment">;;  Icicles.  For this reason, if you use both Icicles and Delete</span>
<span class="linecomment">;;  Selection mode, you must turn on Icicle mode after you turn on</span>
<span class="linecomment">;;  Delete Selection mode.  If you forget to do this, you will notice</span>
<span class="linecomment">;;  that `C-g' does not abort minibuffer input.  The remedy is simply</span>
<span class="linecomment">;;  to turn Icicle mode off, then on again.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicles User Options and Faces")</span>
<span class="linecomment">;;  ** Icicles User Options and Faces **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are several user options (user variables) and faces that</span>
<span class="linecomment">;;  Icicles defines, and you can also use various standard user</span>
<span class="linecomment">;;  options, including Icomplete options, that control various aspects</span>
<span class="linecomment">;;  of completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-mode-hook' is a normal hook containing</span>
<span class="linecomment">;;    functions that are run after entering and exiting Icicle mode.</span>
<span class="linecomment">;;    This is nil, by default.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-minibuffer-setup-hook' is a list of</span>
<span class="linecomment">;;    functions to be run at the end of minibuffer setup for Icicle</span>
<span class="linecomment">;;    mode.  This is nil, by default.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-update-input-hook' is a list of functions to</span>
<span class="linecomment">;;    be run when minibuffer input is updated (typing or deleting).</span>
<span class="linecomment">;;    This is nil, by default.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Case sensitivity: Standard user options `completion-ignore-case'</span>
<span class="linecomment">;;    and `read-file-name-completion-ignore-case' (for Emacs 22 and</span>
<span class="linecomment">;;    later) control whether completion distinguishes between</span>
<span class="linecomment">;;    uppercase and lowercase letters.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    In addition, you can toggle case-sensitivity at any time using</span>
<span class="linecomment">;;    `C-A' (that is, `C-S-a') in the minibuffer.  This toggles</span>
<span class="linecomment">;;    `case-fold-search' and `completion-ignore-case'.  With a prefix</span>
<span class="linecomment">;;    argument, it also toggles</span>
<span class="linecomment">;;    `read-file-name-completion-ignore-case' (starting with Emacs</span>
<span class="linecomment">;;    22).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    More precisely, it toggles the default value of</span>
<span class="linecomment">;;    `case-fold-search', and then it sets the other variables to the</span>
<span class="linecomment">;;    value of `case-fold-search'.  Because the default value of</span>
<span class="linecomment">;;    `case-fold-search' is changed, all buffers are affected.  Note</span>
<span class="linecomment">;;    that because some commands bind one or more of these variables,</span>
<span class="linecomment">;;    toggling case-sensitivity during command execution will not</span>
<span class="linecomment">;;    necessarily toggle their global values.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    You can tell whether completion is currently case-sensitive by</span>
<span class="linecomment">;;    looking at the Icicle minor-mode lighter in the mode line, if</span>
<span class="linecomment">;;    `icicle-highlight-lighter-flag' is non-nil.  If case-sensitive,</span>
<span class="linecomment">;;    then the lighter text (with or without multi-command symbol `+')</span>
<span class="linecomment">;;    is `Icy'; if not, it is `ICY'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-region-background',</span>
<span class="linecomment">;;    `icicle-point-position-in-candidate',</span>
<span class="linecomment">;;    `icicle-mark-position-in-candidate', and</span>
<span class="linecomment">;;    `icicle-change-region-background-flag' are all used to define</span>
<span class="linecomment">;;    the region (the selected text) when cycling completion</span>
<span class="linecomment">;;    candidates.  They are described below individually.  The region</span>
<span class="linecomment">;;    is active when cycling, so you can easily delete it or replace</span>
<span class="linecomment">;;    it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-point-position-in-candidate' defines the</span>
<span class="linecomment">;;    minibuffer cursor position (point) while cycling candidate</span>
<span class="linecomment">;;    completions.  By default, the cursor is placed at the end of the</span>
<span class="linecomment">;;    root being completed.  You can instead place it at the root</span>
<span class="linecomment">;;    beginning or at the beginning or end of the complete minibuffer</span>
<span class="linecomment">;;    input.  For file-name input, the beginning of minibuffer input</span>
<span class="linecomment">;;    starts after the directory name (which is inserted</span>
<span class="linecomment">;;    automatically).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Similarly, user option `icicle-mark-position-in-candidate'</span>
<span class="linecomment">;;    defines the position of the mark; by default, it is at the end</span>
<span class="linecomment">;;    of the input.  Together, these two options control the size and</span>
<span class="linecomment">;;    placement of the region in a flexible way.  You can make the</span>
<span class="linecomment">;;    region include all of the input, only the root, from beginning</span>
<span class="linecomment">;;    to root, or from root to end.  You can put the cursor at either</span>
<span class="linecomment">;;    end of the region.  You can get rid of the region altogether, by</span>
<span class="linecomment">;;    making point and mark coincide (at any of the possible</span>
<span class="linecomment">;;    positions).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Because the region background color is often quite different</span>
<span class="linecomment">;;    from the frame background color (in order to have it stand out),</span>
<span class="linecomment">;;    it can be a bit hard to read the completion candidates when the</span>
<span class="linecomment">;;    region is highlighted during input cycling.  If user option</span>
<span class="linecomment">;;    `icicle-change-region-background-flag' is non-nil, however, then</span>
<span class="linecomment">;;    the region background is changed to a color that differs only</span>
<span class="linecomment">;;    slightly from the frame background, making it easier to read the</span>
<span class="linecomment">;;    completion candidates.  The actual background color used is the</span>
<span class="linecomment">;;    value of `icicle-region-background', which you can customize.</span>
<span class="linecomment">;;    If you make this color the same as the frame background, then</span>
<span class="linecomment">;;    the region background is, in effect, invisible.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The default value of `icicle-change-region-background-flag' is</span>
<span class="linecomment">;;    determined by the current value of `delete-selection-mode', that</span>
<span class="linecomment">;;    is, whether or not Delete Selection mode is enabled, when</span>
<span class="linecomment">;;    Icicles is loaded.  For this reason, if you use Delete Selection</span>
<span class="linecomment">;;    mode and you want the region background to change in the</span>
<span class="linecomment">;;    minibuffer, you should either turn on Delete Selection mode</span>
<span class="linecomment">;;    before loading `icicles.el' or explicitly customize</span>
<span class="linecomment">;;    `icicle-change-region-background-flag' to non-nil.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-default-value' controls the treatment of a</span>
<span class="linecomment">;;    default value for minibuffer input.  This includes not only</span>
<span class="linecomment">;;    functions that read input with completion (`completing-read',</span>
<span class="linecomment">;;    `read-file-name'), but also other input-reading functions:</span>
<span class="linecomment">;;    `read-from-minibuffer' and `read-string'.  The default value of</span>
<span class="linecomment">;;    t gives the vanilla Emacs behavior: `completing-read' adds the</span>
<span class="linecomment">;;    default input value to the prompt as a hint (but</span>
<span class="linecomment">;;    `read-file-name' does not).  Non-nil and non-t means to</span>
<span class="linecomment">;;    automatically insert the default input value into the minibuffer</span>
<span class="linecomment">;;    as the initial value.  I prefer to have it inserted, as I often</span>
<span class="linecomment">;;    use the default value (perhaps editing it).  A value of nil</span>
<span class="linecomment">;;    neither inserts the default value nor adds it to the prompt.  If</span>
<span class="linecomment">;;    the value is t or nil, remember that you can always insert the</span>
<span class="linecomment">;;    default value manually with `M-n'.  If the value is neither t</span>
<span class="linecomment">;;    nor nil, you can always use `M-p' to remove the default value</span>
<span class="linecomment">;;    from the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    A non-nil, non-t value of `icicle-default-value' controls also</span>
<span class="linecomment">;;    whether or not the initial value is preselected, and where to</span>
<span class="linecomment">;;    leave the cursor: at the beginning or end of the value.</span>
<span class="linecomment">;;    Preselecting the value can be useful in Delete Selection mode or</span>
<span class="linecomment">;;    PC Selection mode, because it makes it easy to replace that</span>
<span class="linecomment">;;    value by typing characters, or delete it by hitting `DEL'</span>
<span class="linecomment">;;    (Backspace) or `C-d' (Delete).  However, all of the initial</span>
<span class="linecomment">;;    input is lost if you type or hit `C-d' or `DEL', which is</span>
<span class="linecomment">;;    inconvenient if you want to edit it only slightly.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-thing-at-point-functions' and</span>
<span class="linecomment">;;    `icicle-default-thing-insertion' control the behavior of `M-.'</span>
<span class="linecomment">;;    in the minibuffer, which grabs text from the current buffer and</span>
<span class="linecomment">;;    yanks it into the minibuffer.</span>
<span class="linecomment">;;    See (@file :file-name "icicles-doc1.el" :to "Inserting Text Found Near the Cursor")</span>
<span class="linecomment">;;    and the doc string (`C-h v') of</span>
<span class="linecomment">;;    `icicle-thing-at-point-functions' for more information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-comint-dynamic-complete-replacements'</span>
<span class="linecomment">;;    specifies a list of function replacements for</span>
<span class="linecomment">;;    `icicle-comint-dynamic-complete' to replace the functions in</span>
<span class="linecomment">;;    `comint-dynamic-complete-functions'.  You can use this to</span>
<span class="linecomment">;;    provide Icicles completion for various modes that inherit from</span>
<span class="linecomment">;;    Comint mode.  By default, it treats Comint mode and Shell mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-input-string' is a regexp string that is</span>
<span class="linecomment">;;    inserted in the minibuffer when you use `C-='.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Inserting a Regexp from a Variable").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * In buffer `*Completions*', face `icicle-saved-candidate'</span>
<span class="linecomment">;;    highlights candidates that have been saved, face</span>
<span class="linecomment">;;    `icicle-current-candidate-highlight' highlights the current</span>
<span class="linecomment">;;    completion candidate, and, provided user option</span>
<span class="linecomment">;;    `icicle-expand-input-to-common-match-flag' is non-nil, face</span>
<span class="linecomment">;;    `icicle-common-match-highlight-Completions' highlights the</span>
<span class="linecomment">;;    expanded common match among all completions.  Faces</span>
<span class="linecomment">;;    `icicle-match-highlight-Completions' and</span>
<span class="linecomment">;;    `icicle-match-highlight-minibuffer' highlight whatever your</span>
<span class="linecomment">;;    input matches, in buffer `*Completions*' and in the minibuffer,</span>
<span class="linecomment">;;    respectively.  In the minibuffer, face `icicle-complete-input'</span>
<span class="linecomment">;;    highlights your input when it is complete.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-touche-pas-aux-menus-flag' means</span>
<span class="linecomment">;;    that Icicles will not add menu items to menu-bar menus, except</span>
<span class="linecomment">;;    for the Icicles and Minibuf menus.  Default value nil means that</span>
<span class="linecomment">;;    whenever an appropriate menu-bar menu exists, Icicles items are</span>
<span class="linecomment">;;    added to it (when in Icicle mode).  For example, if nil, then</span>
<span class="linecomment">;;    Delete File is added to the File menu; otherwise it is added to</span>
<span class="linecomment">;;    the Icicles menu.  The value of this option is used only when</span>
<span class="linecomment">;;    Icicle mode is initially established, so changing it has no</span>
<span class="linecomment">;;    effect after Icicles has been loaded.  However, you can change</span>
<span class="linecomment">;;    it and save the new value, so it will be used next time.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-redefine-standard-commands-flag' controls</span>
<span class="linecomment">;;    whether Icicles redefines some standard commands, enhancing them</span>
<span class="linecomment">;;    to use Icicles completion.  A non-nil value causes redefinition.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-apropos-cycle-previous-keys',</span>
<span class="linecomment">;;    `icicle-apropos-cycle-next-keys',</span>
<span class="linecomment">;;    `icicle-prefix-cycle-previous-keys',</span>
<span class="linecomment">;;    `icicle-prefix-cycle-next-keys',</span>
<span class="linecomment">;;    `icicle-apropos-cycle-previous-action-keys',</span>
<span class="linecomment">;;    `icicle-apropos-cycle-next-action-keys',</span>
<span class="linecomment">;;    `icicle-prefix-cycle-previous-action-keys', and</span>
<span class="linecomment">;;    `icicle-prefix-cycle-next-action-keys' specify the keys to use</span>
<span class="linecomment">;;    for completion-candidate cycling.  By default, these keys are</span>
<span class="linecomment">;;    `prior', `next', `up', `down', `C-prior', `C-next', `C-up', and</span>
<span class="linecomment">;;    `C-down', respectively.  The prefix (non-action) versions are</span>
<span class="linecomment">;;    also used to move up or down a line in buffer `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil option `icicle-cycling-respects-completion-mode' causes</span>
<span class="linecomment">;;    the modal cycling keys to act differently during completion.</span>
<span class="linecomment">;;    Those keys are `up', `down', `C-up', and `C-down' by default,</span>
<span class="linecomment">;;    but they are configurable by user options</span>
<span class="linecomment">;;    `icicle-modal-cycle-up-keys', `icicle-modal-cycle-down-keys',</span>
<span class="linecomment">;;    `icicle-modal-cycle-up-action-keys', and</span>
<span class="linecomment">;;    `icicle-modal-cycle-down-action-keys'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The completion mode, and hence the behavior of these keys, is</span>
<span class="linecomment">;;    changed whenever you hit `TAB' or `S-TAB' during completion: the</span>
<span class="linecomment">;;    mode is prefix completion after `TAB' and apropos completion</span>
<span class="linecomment">;;    after `S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Before you hit `TAB' or `S-TAB', the cycling behavior depends on</span>
<span class="linecomment">;;    the particular non-nil value of the option:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - `prefix'  means cycle prefix completions</span>
<span class="linecomment">;;    - `apropos' means cycle apropos completions</span>
<span class="linecomment">;;    - Other non-nil value means cycle inputs from the input history</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    For example, if the value is `apropos' then you can immediately</span>
<span class="linecomment">;;    cycle apropos completions without first hitting `S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Once you have used `TAB' or `S-TAB', the only way to traverse</span>
<span class="linecomment">;;    the input history is to use `M-p' and `M-n' (`up' and `down'</span>
<span class="linecomment">;;    will cycle completions).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If the option is non-nil you can still use `M-p' and `M-n' to</span>
<span class="linecomment">;;    traverse the input history, and `prior' and `next' to cycle</span>
<span class="linecomment">;;    apropos completions (assuming that those default keys have not</span>
<span class="linecomment">;;    been changed).  And if you customize either the modal cycling</span>
<span class="linecomment">;;    keys or the prefix cycling keys so that they are different</span>
<span class="linecomment">;;    (e.g. one of those sets is no longer `up'/`down'), then you can</span>
<span class="linecomment">;;    also still use the latter.  In this case, you need not use `TAB'</span>
<span class="linecomment">;;    and `S-TAB' to switch between the two completion types, even</span>
<span class="linecomment">;;    when this option is non-nil - you can use the separate apropos</span>
<span class="linecomment">;;    and prefix cycling keys.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The values of user options `icicle-modal-cycle-up-keys',</span>
<span class="linecomment">;;    `icicle-modal-cycle-down-keys',</span>
<span class="linecomment">;;    `icicle-modal-cycle-up-action-keys', and</span>
<span class="linecomment">;;    `icicle-modal-cycle-down-action-keys' are the keys used for</span>
<span class="linecomment">;;    modal cycling.  By default, these keys are `up', `down', `C-up',</span>
<span class="linecomment">;;    and `C-down'.  These options have an effect only if option</span>
<span class="linecomment">;;    `icicle-cycling-respects-completion-mode' is non-nil.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-word-completion-keys' is a list of keys to</span>
<span class="linecomment">;;    use for word completion.  By default, the only such key is</span>
<span class="linecomment">;;    `M-SPC'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-apropos-complete-no-display-keys' is a list</span>
<span class="linecomment">;;    of keys to bind to `icicle-apropos-complete-no-display'.  By</span>
<span class="linecomment">;;    default, these keys are `C-M-S-tab' and `C-M-S-iso-lefttab',</span>
<span class="linecomment">;;    which together implement `C-M-S-TAB'.  Similarly,</span>
<span class="linecomment">;;    `icicle-prefix-complete-no-display-keys' is the list of keys for</span>
<span class="linecomment">;;    `icicle-prefix-complete-no-display'.  By default, the only such</span>
<span class="linecomment">;;    key is `C-M-tab'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-prefix-complete-keys' is the list of keys for</span>
<span class="linecomment">;;    `icicle-prefix-complete'.  By default, these keys are `tab' and</span>
<span class="linecomment">;;    `C-i', which together implement `TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-apropos-complete-keys' is the list of keys to</span>
<span class="linecomment">;;    bind to `icicle-apropos-complete'.  By default, these keys are</span>
<span class="linecomment">;;    `S-tab' and `S-iso-lefttab', which together implement `S-TAB'.</span>
<span class="linecomment">;;    (In Emacs 22 and later, `backtab' is the canonical key that</span>
<span class="linecomment">;;    represents both `S-tab' and `S-iso-lefttab', so that is used in</span>
<span class="linecomment">;;    the default value.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-key-complete-keys' is the list of keys to bind to</span>
<span class="linecomment">;;    `icicle-complete-keys'.  By default, these keys are `S-tab' and</span>
<span class="linecomment">;;    `S-iso-lefttab', which together implement `S-TAB'.  (In Emacs 22</span>
<span class="linecomment">;;    and later, `backtab' is the canonical key that represents both</span>
<span class="linecomment">;;    `S-tab' and `S-iso-lefttab', so that is used in the default</span>
<span class="linecomment">;;    value.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-previous-candidate-keys' is the list of keys to</span>
<span class="linecomment">;;    bind to `icicle-move-to-previous-completion'.  By default, these</span>
<span class="linecomment">;;    keys are `S-tab' and `S-iso-lefttab', which together implement</span>
<span class="linecomment">;;    `S-TAB'.  (In Emacs 22 and later, `backtab' is the canonical key</span>
<span class="linecomment">;;    that represents both `S-tab' and `S-iso-lefttab', so that is</span>
<span class="linecomment">;;    used in the default value.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-isearch-complete-keys' is the list of keys for</span>
<span class="linecomment">;;    `icicle-isearch-complete'.  By default, these keys are `M-TAB'</span>
<span class="linecomment">;;    and `M-o' (and, on MS Windows, `C-M-TAB').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-act-before-cycle-flag' nil means that keys</span>
<span class="linecomment">;;    such as `C-next', which combine candidate action and cycling,</span>
<span class="linecomment">;;    cycle to the next (or previous) candidate and act on it.</span>
<span class="linecomment">;;    Non-nil means they act on the current candidate and then cycle</span>
<span class="linecomment">;;    to the next (or previous) candidate.  When the value is nil, you</span>
<span class="linecomment">;;    can think of `C-next' as an operation on the next candidate.</span>
<span class="linecomment">;;    When the value is non-nil, you can think of `C-next' as an</span>
<span class="linecomment">;;    operation on the current candidate, which ends by making the</span>
<span class="linecomment">;;    next candidate current.  Similarly for `C-prior', `C-down', and</span>
<span class="linecomment">;;    `C-up'.  The default value is nil.  See also option</span>
<span class="linecomment">;;    `icicle-use-C-for-actions-flag', which changes the keys affected</span>
<span class="linecomment">;;    by `icicle-act-before-cycle-flag'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If option `icicle-use-C-for-actions-flag' is nil, then the keys</span>
<span class="linecomment">;;    that cycle candidates are swapped with the keys that both cycle</span>
<span class="linecomment">;;    and act on a candidate.  You can then use `down', `up', `next',</span>
<span class="linecomment">;;    and `prior' to both cycle and act, and `C-down', `C-up',</span>
<span class="linecomment">;;    `C-next', and `C-prior' to merely cycle, without acting</span>
<span class="linecomment">;;    (e.g. navigating).  The option has no effect on other keys.  You</span>
<span class="linecomment">;;    can toggle this option at any time using `M-g'</span>
<span class="linecomment">;;    (`icicle-toggle-C-for-actions') in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (The keys mentioned here are the default bindings.  The actual</span>
<span class="linecomment">;;    keys swapped are those defined by user options</span>
<span class="linecomment">;;    `icicle-modal-cycle-down-keys', `icicle-modal-cycle-up-keys',</span>
<span class="linecomment">;;    `icicle-prefix-cycle-next-keys',</span>
<span class="linecomment">;;    `icicle-prefix-cycle-previous-keys',</span>
<span class="linecomment">;;    `icicle-apropos-cycle-next-keys',</span>
<span class="linecomment">;;    `icicle-apropos-cycle-previous-keys',</span>
<span class="linecomment">;;    `icicle-modal-cycle-down-action-keys',</span>
<span class="linecomment">;;    `icicle-modal-cycle-up-action-keys',</span>
<span class="linecomment">;;    `icicle-prefix-cycle-next-action-keys',</span>
<span class="linecomment">;;    `icicle-prefix-cycle-previous-action-keys',</span>
<span class="linecomment">;;    `icicle-apropos-cycle-next-action-keys', and</span>
<span class="linecomment">;;    `icicle-apropos-cycle-previous-action-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-top-level-when-sole-completion-flag'</span>
<span class="linecomment">;;    means that whenever there is only one completion candidate that</span>
<span class="linecomment">;;    matches your input, that candidate is used immediately, without</span>
<span class="linecomment">;;    requiring you to hit `RET' or `S-RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-TAB-shows-candidates-flag' means</span>
<span class="linecomment">;;    that hitting `TAB' for prefix completion immediately shows the</span>
<span class="linecomment">;;    completion candidates in buffer `*Completions*'.  If nil, then</span>
<span class="linecomment">;;    candidates are shown only after `TAB' is hit a second time,</span>
<span class="linecomment">;;    which is the standard Emacs behavior.  The default value is t.</span>
<span class="linecomment">;;    (Actually, the concerned keys are those defined by option</span>
<span class="linecomment">;;    `icicle-prefix-complete-keys', not necessarily `TAB'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-expand-input-to-common-match-flag'</span>
<span class="linecomment">;;    means that completion commands `TAB' and `S-TAB' expand your</span>
<span class="linecomment">;;    minibuffer input to (typically) the longest common match among</span>
<span class="linecomment">;;    all completion candidates.  This replaces the input you typed.</span>
<span class="linecomment">;;    If you want to edit your original, raw input, use `C-l'.  If</span>
<span class="linecomment">;;    your input has been expanded, then hit `C-l' twice: once to</span>
<span class="linecomment">;;    replace a completion candidate (from, say, `next') with the</span>
<span class="linecomment">;;    common match string, and a second time to replace the common</span>
<span class="linecomment">;;    match string with your original input.  The main reason you</span>
<span class="linecomment">;;    might want to set this to nil is for apropos completion, if you</span>
<span class="linecomment">;;    want to always work with a regexp in the minibuffer.  You can</span>
<span class="linecomment">;;    toggle this option at any time using `C-;' in the minibuffer.</span>
<span class="linecomment">;;    See (@file :file-name "icicles-doc1.el" :to "Expanded-Common-Match Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option</span>
<span class="linecomment">;;    `icicle-hide-common-match-in-Completions-flag' hides the common</span>
<span class="linecomment">;;    match for your current input from each candidate in</span>
<span class="linecomment">;;    *Completions*.  You can toggle this at any time during</span>
<span class="linecomment">;;    completion using `C-M-.' (`icicle-toggle-hiding-common-match').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-show-Completions-initially-flag' controls</span>
<span class="linecomment">;;    whether or not buffer `*Completions*' is shown initially,</span>
<span class="linecomment">;;    without your needing to hit `TAB' or `S-TAB' to show it.</span>
<span class="linecomment">;;    However, if you type something before</span>
<span class="linecomment">;;    `icicle-incremental-completion-delay', then display is</span>
<span class="linecomment">;;    inhibited.  The default value is nil, meaning that</span>
<span class="linecomment">;;    `*Completions*' is not shown until you hit `TAB' or `S-TAB'.</span>
<span class="linecomment">;;    More typical than setting this option to non-nil globally is to</span>
<span class="linecomment">;;    bind it to non-nil in Emacs-Lisp code, to display</span>
<span class="linecomment">;;    `*Completions*' as a menu.  For example, pass a non-nil binding</span>
<span class="linecomment">;;    to `icicle-define-command' to create a command that displays a</span>
<span class="linecomment">;;    multiple-choice menu.  As an alternative to a non-nil</span>
<span class="linecomment">;;    `icicle-show-Completions-initially-flag', you can set option</span>
<span class="linecomment">;;    `icicle-incremental-completion-flag' to a value that is neither</span>
<span class="linecomment">;;    nil nor t; that will display `*Completions*' as soon as you type</span>
<span class="linecomment">;;    or delete input (but not initially).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-incremental-completion-flag' controls</span>
<span class="linecomment">;;    whether or not `*Completions*' is updated incrementally</span>
<span class="linecomment">;;    (icompletion) as you type.  You can toggle incremental</span>
<span class="linecomment">;;    completion at any time using `C-#'.  For more information, see</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Icompletion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-incremental-completion-delay' and</span>
<span class="linecomment">;;    `icicle-incremental-completion-threshold' together cause a delay</span>
<span class="linecomment">;;    before incremental completion takes effect.</span>
<span class="linecomment">;;    See (@file :file-name "icicles-doc1.el" :to "Icompletion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-Completions-display-min-input-chars' is the</span>
<span class="linecomment">;;    minimum number of input characters that allow buffer</span>
<span class="linecomment">;;    `*Completions*' to remain displayed.  By default, this is zero</span>
<span class="linecomment">;;    (0), meaning that any number of input characters, even none,</span>
<span class="linecomment">;;    allows `*Completions*' to remain displayed.  If you use</span>
<span class="linecomment">;;    incremental completion (see `icicle-incremental-completion-*'),</span>
<span class="linecomment">;;    and you are bothered by `*Completions*' being automatically</span>
<span class="linecomment">;;    updated when, for instance, you empty the minibuffer, then you</span>
<span class="linecomment">;;    might want to set this option to, say, 1 or 2.  With a value of</span>
<span class="linecomment">;;    2, for instance, whenever the minibuffer input has less than 2</span>
<span class="linecomment">;;    characters, incremental completion will remove the</span>
<span class="linecomment">;;    `*Completions*' window.  You can also remove the `*Completions*'</span>
<span class="linecomment">;;    window at any time using `C-x 0' in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil option `icicle-show-Completions-help-flag' means display</span>
<span class="linecomment">;;    help (instructions) at the top of the `*Completions*' window.</span>
<span class="linecomment">;;    These instructions are shown in faces</span>
<span class="linecomment">;;    `icicle-Completions-instruction-1' and</span>
<span class="linecomment">;;    `icicle-Completions-instruction-2'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-Completions-frame-at-right-flag' controls</span>
<span class="linecomment">;;    whether `icicle-candidate-action' moves the frame showing buffer</span>
<span class="linecomment">;;    `*Completions*' to the right, out of the way of other frames.</span>
<span class="linecomment">;;    This can be useful if you use one-buffer-per-frame (non-nil</span>
<span class="linecomment">;;    `pop-up-frames').  In that case, I recommend that you also try</span>
<span class="linecomment">;;    my library `oneonone.el'.</span>
<span class="linecomment">;;    See (@&gt; "Note on Non-nil `pop-up-frames' on MS Windows") for</span>
<span class="linecomment">;;    more advice about non-nil `pop-up-frames'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-Completions-window-max-height' is the</span>
<span class="linecomment">;;    maximum height of the `*Completions*' window, in lines.  The</span>
<span class="linecomment">;;    window is fit to the buffer size, with this as maximum height.</span>
<span class="linecomment">;;    This is not used if `*Completions*' is a special display buffer</span>
<span class="linecomment">;;    with its own frame, and it is not used in Emacs releases prior</span>
<span class="linecomment">;;    to 21.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-candidate-width-factor' controls how many</span>
<span class="linecomment">;;    columns of completion candidates are displayed in</span>
<span class="linecomment">;;    `*Completions*'.  The widest current candidate is scaled by this</span>
<span class="linecomment">;;    percentage, and the window width is divided by that figure.</span>
<span class="linecomment">;;    Other things are taken into account also, but this gives you a</span>
<span class="linecomment">;;    way to tweak the number of columns: the larger this number, the</span>
<span class="linecomment">;;    fewer the columns.  The default value is 70.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If you use Do Re Mi (library `doremi.el'), then you can modify</span>
<span class="linecomment">;;    `icicle-candidate-width-factor' incrementally during completion,</span>
<span class="linecomment">;;    seeing the effect as it changes.  Use `C-x w' from the</span>
<span class="linecomment">;;    minibuffer, then use the `right' and `left' arrow keys or the</span>
<span class="linecomment">;;    mouse wheel to increment and decrement the value.  You can at</span>
<span class="linecomment">;;    the same time use the `up' and `down' keys to adjust the value</span>
<span class="linecomment">;;    of `icicle-inter-candidates-min-spaces'.  WYSIWYG.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-inter-candidates-min-spaces' is the minimum</span>
<span class="linecomment">;;    number of spaces between candidates displayed in</span>
<span class="linecomment">;;    `*Completions*'.  The default value is one space.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If you use Do Re Mi (library `doremi.el'), then you can modify</span>
<span class="linecomment">;;    `icicle-inter-candidates-min-spaces' incrementally during</span>
<span class="linecomment">;;    completion, seeing the effect as it changes.  Use `C-x |' from</span>
<span class="linecomment">;;    the minibuffer, then use the `up' and `down' arrow keys or the</span>
<span class="linecomment">;;    mouse wheel to increment and decrement the value.  You can at</span>
<span class="linecomment">;;    the same time use the `left' and `right' keys to adjust the</span>
<span class="linecomment">;;    value of `icicle-candidate-width-factor'.  WYSIWYG.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Face `icicle-historical-candidate' is used to highlight</span>
<span class="linecomment">;;    completion candidates that you have used (entered with `RET')</span>
<span class="linecomment">;;    previously.  This highlighting is controlled by user option</span>
<span class="linecomment">;;    `icicle-highlight-historical-candidates-flag'.  You can toggle</span>
<span class="linecomment">;;    this option from the minibuffer at any time using `C-pause'.</span>
<span class="linecomment">;;    See (@file :file-name "icicles-doc1.el" :to "History Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-sort-function' controls the order of</span>
<span class="linecomment">;;    completion candidates during cycling and in buffer</span>
<span class="linecomment">;;    `*Completions*'.  If nil, then no sorting is done.  If non-nil,</span>
<span class="linecomment">;;    then the value must be a string-comparison function - the</span>
<span class="linecomment">;;    function is passed to the standard function `sort' to do the</span>
<span class="linecomment">;;    sorting.  The default value for `icicle-sort-function' is</span>
<span class="linecomment">;;    `icicle-case-string-less-p', which sorts alphabetically,</span>
<span class="linecomment">;;    possibly ignoring letter case.  During completion, you can</span>
<span class="linecomment">;;    toggle sorting using `C-,'.  If you are an Emacs-Lisp programmer</span>
<span class="linecomment">;;    and you write new commands using Icicles functionalities, you</span>
<span class="linecomment">;;    can bind `icicle-sort-function' temporarily to any sort function</span>
<span class="linecomment">;;    you need.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-alternative-sort-function' is an alternative</span>
<span class="linecomment">;;    to `icicle-sort-function, providing a different sort order.  By</span>
<span class="linecomment">;;    default, it is `icicle-historical-alphabetic-p', a function that</span>
<span class="linecomment">;;    sorts previously used completion candidates before candidates</span>
<span class="linecomment">;;    that have not yet been used, and sorts alphabetically within</span>
<span class="linecomment">;;    each of these groups of candidates.  In other words, it places</span>
<span class="linecomment">;;    inputs that you have used previously at the top of buffer</span>
<span class="linecomment">;;    `*Completions*' and makes them available for completion first.</span>
<span class="linecomment">;;    During completion, you can toggle normal and alternative sorting</span>
<span class="linecomment">;;    using `C-M-,'.  See (@&gt; "Sorting Candidates") and</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "History Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-change-sort-order-completion-flag' specifies</span>
<span class="linecomment">;;    whether `C-,' cycles among available sort orders or lets you</span>
<span class="linecomment">;;    choose a sort order using Icicles completion.  Non-nil means to</span>
<span class="linecomment">;;    use completion; nil (the default value) means to cycle.  You can</span>
<span class="linecomment">;;    override the current setting at any time by using `C-u C-,'.</span>
<span class="linecomment">;;    See (@&gt; "Sorting Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-sort-functions-alist' is an alist of</span>
<span class="linecomment">;;    possible sort orders for user to choose from using `C-,' or</span>
<span class="linecomment">;;    `M-,'.  See (@&gt; "Sorting Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The value of user option `icicle-transform-function' is a</span>
<span class="linecomment">;;    function that is applied to the list of completion candidates,</span>
<span class="linecomment">;;    to transform them before they are presented to the user.  If</span>
<span class="linecomment">;;    nil, then no transformation is done.  The default transformation</span>
<span class="linecomment">;;    is to remove duplicate candidates, when transformation is</span>
<span class="linecomment">;;    active, but the default value of this option is nil.  You can</span>
<span class="linecomment">;;    toggle transformation at any time using command</span>
<span class="linecomment">;;    `icicle-toggle-transforming', bound to `C-$' in the minibuffer.</span>
<span class="linecomment">;;    Although this is a user option, you probably do *NOT* want to</span>
<span class="linecomment">;;    change its value by customizing it.  Icicles commands already</span>
<span class="linecomment">;;    "do the right thing" when it comes to candidate transformation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The value of this option can be changed by program locally, for</span>
<span class="linecomment">;;    use in particular contexts.  For example, when you use</span>
<span class="linecomment">;;    `icicle-search-generic' (`C-c `') in a *shell* buffer, Icicles</span>
<span class="linecomment">;;    uses this variable with a value of `icicle-remove-duplicates',</span>
<span class="linecomment">;;    to remove duplicate shell commands from your input history list.</span>
<span class="linecomment">;;    Lisp programmers can use this variable to transform the list of</span>
<span class="linecomment">;;    candidates in any way they like.  A typical use is to remove</span>
<span class="linecomment">;;    duplicates, by binding it to `icicle-remove-duplicates' or</span>
<span class="linecomment">;;    `icicle-remove-dups-if-extras'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-require-match-flag',</span>
<span class="linecomment">;;    `icicle-buffer-require-match-flag', and</span>
<span class="linecomment">;;    `icicle-file-require-match-flag' let you override the value of</span>
<span class="linecomment">;;    the REQUIRE-MATCH argument provided to `completing-read' or</span>
<span class="linecomment">;;    `read-file-name'.  They are provided mainly for use (binding) in</span>
<span class="linecomment">;;    `icicle-define-command' and `icicle-define-file-command', but</span>
<span class="linecomment">;;    you may also use them globally, if you wish.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Exiting the Minibuffer Without Confirmation").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    A typical use is made in the definition of command</span>
<span class="linecomment">;;    `icicle-buffer': `icicle-buffer-require-match-flag' is used to</span>
<span class="linecomment">;;    bind `icicle-require-match-flag', so that you can, for example,</span>
<span class="linecomment">;;    match only existing buffers and be able to match on partial</span>
<span class="linecomment">;;    input without explicitly completing (hitting `TAB' or `S-TAB').</span>
<span class="linecomment">;;    Simply set the option to `partial-match-ok' to get this</span>
<span class="linecomment">;;    behavior.  To apropos-complete and exit the minibuffer, use</span>
<span class="linecomment">;;    `S-RET' instead of `RET'.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Exiting the Minibuffer Without Confirmation"),</span>
<span class="linecomment">;;    for more information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-ignore-space-prefix-flag' means to</span>
<span class="linecomment">;;    ignore completion candidates that start with a space.  However,</span>
<span class="linecomment">;;    such candidates are not ignored for prefix completion if the</span>
<span class="linecomment">;;    input also starts with a space.  Naturally, apropos completion</span>
<span class="linecomment">;;    is not affected by whether or not the input starts with a space.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Option `icicle-buffer-ignore-space-prefix-flag' lets you</span>
<span class="linecomment">;;    override the value of `icicle-ignore-space-prefix-flag' for use</span>
<span class="linecomment">;;    with buffer-name completion (the names of internal buffers start</span>
<span class="linecomment">;;    with a space).  It is provided mainly for binding in</span>
<span class="linecomment">;;    `icicle-define-command' (`icicle-buffer' does this).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    You can toggle `icicle-ignore-space-prefix-flag' at any time</span>
<span class="linecomment">;;    using `M-_' in the minibuffer.  If the current command binds</span>
<span class="linecomment">;;    this option locally, then it is the local, not the global, value</span>
<span class="linecomment">;;    that is changed.  For example, if</span>
<span class="linecomment">;;    `icicle-buffer-ignore-space-prefix-flag' is non-nil, then `M-_'</span>
<span class="linecomment">;;    toggles `icicle-ignore-space-prefix-flag' to nil only for the</span>
<span class="linecomment">;;    duration of `icicle-buffer'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-test-for-remote-files-flag' means</span>
<span class="linecomment">;;    that Icicles tests for remote file names; nil means that it does</span>
<span class="linecomment">;;    not.  You can toggle this using `C-^' in the minibuffer (except</span>
<span class="linecomment">;;    during Icicles search).  Turning off remote file-name testing</span>
<span class="linecomment">;;    means that you cannot use remote files with Tramp; it disables</span>
<span class="linecomment">;;    Tramp's remote file-name handling and completion.  This can, for</span>
<span class="linecomment">;;    local files, slightly speed up incremental completion and the</span>
<span class="linecomment">;;    highlighting of the part of your current input that does not</span>
<span class="linecomment">;;    complete (see `icicle-highlight-input-completion-failure').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-regexp-quote-flag' reduces apropos</span>
<span class="linecomment">;;    completion to simple substring completion and Icicles regexp</span>
<span class="linecomment">;;    search to literal search.  Regexp special characters are no</span>
<span class="linecomment">;;    longer recognized as special; they simply match themselves.  You</span>
<span class="linecomment">;;    probably do not want to customize this option.  Instead, you can</span>
<span class="linecomment">;;    toggle it at any time using `C-`' in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-command-abbrev-match-all-parts-flag',</span>
<span class="linecomment">;;    `icicle-command-abbrev-priority-flag', and</span>
<span class="linecomment">;;    `icicle-command-abbrev-alist' control the behavior of</span>
<span class="linecomment">;;    multi-command `icicle-command-abbrev' (`C-x SPC').  The first</span>
<span class="linecomment">;;    determines whether an abbreviation must match all parts of a</span>
<span class="linecomment">;;    command name.  The second controls whether command names or</span>
<span class="linecomment">;;    abbreviations take precedence in case of conflict.  The third is</span>
<span class="linecomment">;;    the persistent list of your command abbreviations.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-apropos-match-fns-alist' controls which</span>
<span class="linecomment">;;    function is used by `S-TAB' to complete your input.  By default,</span>
<span class="linecomment">;;    the first method in this list is used for matching.  By default,</span>
<span class="linecomment">;;    the first element specifies apropos (regexp) matching, and the</span>
<span class="linecomment">;;    second specifies scatter matching.  You can use `M-(' (command</span>
<span class="linecomment">;;    `icicle-next-apropos-match-function') in the minibuffer to cycle</span>
<span class="linecomment">;;    among the matching methods.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-fuzzy-completion-flag' means that</span>
<span class="linecomment">;;    `TAB' completes non-filename input using fuzzy prefix matching</span>
<span class="linecomment">;;    as defined in `fuzzy-match.el'.  See `fuzzy-match.el' for</span>
<span class="linecomment">;;    details about fuzzy matching.  This has no effect if library</span>
<span class="linecomment">;;    `fuzzy-match.el' is not used (loaded).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    This option has no effect on file-name completion.  Fuzzy</span>
<span class="linecomment">;;    completion is always case-sensitive, and leading spaces are</span>
<span class="linecomment">;;    taken into account.  Completion candidates are always sorted by</span>
<span class="linecomment">;;    decreasing fuzzy match strength.  That is, fuzzy completion is</span>
<span class="linecomment">;;    not affected by `C-A', `M-_', or `C-,'.  You can toggle this</span>
<span class="linecomment">;;    option from the minibuffer at any time with `C-(' (command</span>
<span class="linecomment">;;    `icicle-toggle-fuzzy-completion').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-levenshtein-distance' is the Levenshtein</span>
<span class="linecomment">;;    distance allowed for strings to be considered as matching during</span>
<span class="linecomment">;;    N-off completion.  This means that two strings match if they</span>
<span class="linecomment">;;    differ by at most this many character operations (insertion,</span>
<span class="linecomment">;;    deletion, replacement).  This option is used only if you have</span>
<span class="linecomment">;;    library `levenshtein.el'.  See (@&gt; "Fuzzy Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Top-level command `icicle-search' uses several faces to</span>
<span class="linecomment">;;    highlight found text that matches your input.  Faces</span>
<span class="linecomment">;;    `icicle-search-main-regexp-current' and</span>
<span class="linecomment">;;    `icicle-search-main-regexp-others' highlight what your</span>
<span class="linecomment">;;    search-context regexp (entered with `RET') matches.  The former</span>
<span class="linecomment">;;    highlights the current search context; the latter highlights all</span>
<span class="linecomment">;;    other search contexts.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Face `icicle-search-current-input' highlights what your current</span>
<span class="linecomment">;;    input (typically another regexp) matches; that is, it highlights</span>
<span class="linecomment">;;    a match within a search context.  Faces</span>
<span class="linecomment">;;    `icicle-search-context-level-1' through</span>
<span class="linecomment">;;    `icicle-search-context-level-8' highlight the first eight regexp</span>
<span class="linecomment">;;    subgroup matches, within a search context.  This highlighting is</span>
<span class="linecomment">;;    done whenever `icicle-search-highlight-context-levels-flag' is</span>
<span class="linecomment">;;    non-nil and the search context corresponds to the entire regexp.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-search-highlight-context-levels-flag'</span>
<span class="linecomment">;;    controls highlighting of regexp subgroup matches within the</span>
<span class="linecomment">;;    search context.  Non-nil (the default value) means highlight</span>
<span class="linecomment">;;    them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-search-highlight-threshold' controls</span>
<span class="linecomment">;;    highlighting with face `icicle-search-main-regexp-others': this</span>
<span class="linecomment">;;    many matches, maximum, are highlighted.  If zero, then only the</span>
<span class="linecomment">;;    current match is highlighted.  The effect is similar to the</span>
<span class="linecomment">;;    Emacs 22+ lazy search highlighting of Isearch (except that the</span>
<span class="linecomment">;;    highlighting is not in fact lazy).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-search-highlight-all-current-flag'</span>
<span class="linecomment">;;    means highlight the current input match in all main search hits</span>
<span class="linecomment">;;    at the same time.  If `icicle-expand-input-to-common-match-flag'</span>
<span class="linecomment">;;    is also non-nil, then what is highlighted for each input match</span>
<span class="linecomment">;;    is the expanded common match among all input matches throughout</span>
<span class="linecomment">;;    the search area.  If either is nil, then only the exact input</span>
<span class="linecomment">;;    match is highlighted.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The default value of `icicle-search-highlight-all-current-flag'</span>
<span class="linecomment">;;    is nil, because non-nil can impact performance negatively if</span>
<span class="linecomment">;;    there are many search contexts - the highlighting is updated</span>
<span class="linecomment">;;    with each input change.  You can toggle the value at any time</span>
<span class="linecomment">;;    using command `icicle-toggle-highlight-all-current', bound to</span>
<span class="linecomment">;;    `C-^' in the minibuffer (except during file-name completion).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If, in addition to `icicle-search-highlight-all-current-flag'</span>
<span class="linecomment">;;    and `icicle-expand-input-to-common-match-flag', option</span>
<span class="linecomment">;;    `icicle-search-replace-common-match-flag' is also non-nil, then</span>
<span class="linecomment">;;    a search replacement replaces the expanded common match;</span>
<span class="linecomment">;;    otherwise, it replaces only the exact match.  You can toggle the</span>
<span class="linecomment">;;    value at any time using `M-;' in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-search-cleanup-flag' means that</span>
<span class="linecomment">;;    `icicle-search' highlighting is removed after the search.  This</span>
<span class="linecomment">;;    is the default behavior.  If you set this to nil then you can</span>
<span class="linecomment">;;    remove search highlighting manually later using command</span>
<span class="linecomment">;;    `icicle-search-highlight-cleanup'.  You can toggle this search</span>
<span class="linecomment">;;    highlight removal at any time using command</span>
<span class="linecomment">;;    `icicle-toggle-search-cleanup', bound to `C-.' in the minibuffer</span>
<span class="linecomment">;;    (except during file-name completion).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    One use of nil `icicle-search-cleanup-flag' is to highlight</span>
<span class="linecomment">;;    regexp matches throughout a region or buffer (or multiple files</span>
<span class="linecomment">;;    or...).  In that capacity, Icicles search functions act like</span>
<span class="linecomment">;;    some of the highlighting commands in my library `highlight.el'.</span>
<span class="linecomment">;;    Note that when `icicle-search-cleanup-flag' is nil, *all*</span>
<span class="linecomment">;;    Icicles search highlighting remains: last-visited search</span>
<span class="linecomment">;;    context, other context matches, current-input matches, and even</span>
<span class="linecomment">;;    regexp subgroups.  The faces for these are, respectively:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     - `icicle-search-main-regexp-current'</span>
<span class="linecomment">;;     - `icicle-search-main-regexp-others'</span>
<span class="linecomment">;;     - `icicle-search-highlight-input-matches-here' (everywhere, if</span>
<span class="linecomment">;;       `icicle-search-highlight-all-current-flag' is non-nil)</span>
<span class="linecomment">;;     - `icicle-search-context-level-1' through</span>
<span class="linecomment">;;       `icicle-search-context-level-8'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-search-whole-word-flag' means that</span>
<span class="linecomment">;;    whole-word search is done.  All characters in your search string</span>
<span class="linecomment">;;    are searched for literally, and matches for the string must</span>
<span class="linecomment">;;    begin and end on a word boundary.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-search-context-match-predicate', if non-nil,</span>
<span class="linecomment">;;    is a predicate that takes a search-context (string) argument.</span>
<span class="linecomment">;;    Only contexts that satisfy the predicate are used.  For example,</span>
<span class="linecomment">;;    if the predicate is (lambda (x) (commandp (intern-soft x))),</span>
<span class="linecomment">;;    then only contexts that name commands are kept.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If user option `icicle-search-replace-whole-candidate-flag' is</span>
<span class="linecomment">;;    nil, then whatever matches your current input is replaced,</span>
<span class="linecomment">;;    within the current search context, when you perform replacement</span>
<span class="linecomment">;;    during Icicles searching (e.g. `C-S-RET').  If the value is</span>
<span class="linecomment">;;    non-nil (the default value), then the entire search context is</span>
<span class="linecomment">;;    replaced, instead.  You can use `C-,' at any time during</span>
<span class="linecomment">;;    searching and replacing, to toggle the value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-search-replace-literally-flag' determines</span>
<span class="linecomment">;;    whether Icicles search-and-replace replaces text literally or</span>
<span class="linecomment">;;    interprets `\' specially in the replacement text, as in</span>
<span class="linecomment">;;    `query-replace-regexp'.  Non-nil means to treat replacement text</span>
<span class="linecomment">;;    literally.  The default value is nil.  You can use `C-M-`' to</span>
<span class="linecomment">;;    toggle this at any time during Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-search-hook' is a list of functions to be</span>
<span class="linecomment">;;    run after searching and moving to an `icicle-search' match,</span>
<span class="linecomment">;;    whether you move there by `RET', `C-RET', `C-next', or</span>
<span class="linecomment">;;    `C-prior'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-region-alist' is a list of regions, which</span>
<span class="linecomment">;;    you can act on individually or together.  The regions can be in</span>
<span class="linecomment">;;    any buffers.  As an alternative to customizing this option</span>
<span class="linecomment">;;    directly, you can use command `icicle-add-region' to add the</span>
<span class="linecomment">;;    current Emacs region to the list.  Option</span>
<span class="linecomment">;;    `icicle-regions-name-length-max' is the maximum length of the</span>
<span class="linecomment">;;    region-start string that identifies the region for completion</span>
<span class="linecomment">;;    purposes.  See (@&gt; "Multiple Regions").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-bookmark-name-length-max' is the maximum</span>
<span class="linecomment">;;    number of buffer characters to use when `icicle-bookmark-cmd'</span>
<span class="linecomment">;;    with a numeric prefix argument automatically names a bookmark.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-region-auto-open-files-flag' means</span>
<span class="linecomment">;;    that commands that access `icicle-region-alist' first open all</span>
<span class="linecomment">;;    of the files associated with the recorded regions.  The files</span>
<span class="linecomment">;;    are not necessarily displayed.  If this option is nil, then</span>
<span class="linecomment">;;    these commands open the files only as you access them by</span>
<span class="linecomment">;;    choosing a region candidate.  You can also open all such files</span>
<span class="linecomment">;;    at any time, using command `icicle-region-open-all-files'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-add-buffer-name-flag' means that for</span>
<span class="linecomment">;;    some commands, such as `icicle-search' and</span>
<span class="linecomment">;;    `icicle-select-region', the name of the buffer associated with</span>
<span class="linecomment">;;    each completion candidate is added to the candidate and</span>
<span class="linecomment">;;    highlighted.  You can match against the buffer name, as well as</span>
<span class="linecomment">;;    the rest of the candidate.  Note that even when the value of</span>
<span class="linecomment">;;    this option is nil, you can use `C-M-mouse-2' and so on to see</span>
<span class="linecomment">;;    information about a candidate, and this information includes its</span>
<span class="linecomment">;;    buffer name whenever a non-nil value of the option would have</span>
<span class="linecomment">;;    shown the buffer name.  The default value is t.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-buffer-match-regexp',</span>
<span class="linecomment">;;    `icicle-buffer-no-match-regexp', `icicle-buffer-predicate', and</span>
<span class="linecomment">;;    `icicle-buffer-extras' determine the behavior of commands</span>
<span class="linecomment">;;    `icicle-buffer' and `icicle-buffer-other-window'.  They</span>
<span class="linecomment">;;    determine the set of buffer-name candidates initially available</span>
<span class="linecomment">;;    for completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The first three restrict this set to names that satisfy the</span>
<span class="linecomment">;;    properties they specify.  Option `icicle-buffer-extras' lets you</span>
<span class="linecomment">;;    add additional buffer names to the set of candidates, after</span>
<span class="linecomment">;;    restriction by the other options.  Extra buffer-name candidates</span>
<span class="linecomment">;;    are displayed in buffer `*Completions*' using face</span>
<span class="linecomment">;;    `icicle-extra-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note that if an extra candidate is already a candidate anyway</span>
<span class="linecomment">;;    then it will be present twice in the list of all candidates</span>
<span class="linecomment">;;    (that is, unless `icicle-transform-function' removes duplicate</span>
<span class="linecomment">;;    candidates).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Since these are user options, they provide an additional, more</span>
<span class="linecomment">;;    static way to filter the set of candidates.  Typing input</span>
<span class="linecomment">;;    (e.g. a regexp) then dynamically filters the result of applying</span>
<span class="linecomment">;;    the filter options.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Options `icicle-file-match-regexp',</span>
<span class="linecomment">;;    `icicle-file-no-match-regexp', `icicle-file-predicate', and</span>
<span class="linecomment">;;    `icicle-file-extras' act similarly for file-name completion.</span>
<span class="linecomment">;;    You could use `icicle-file-no-match-regexp' or</span>
<span class="linecomment">;;    `icicle-file-predicate', for instance, to exclude files that are</span>
<span class="linecomment">;;    in or under the directories in `vc-directory-exclusion-list':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (defun my-locate-non-vc-file ()</span>
<span class="linecomment">;;      "`icicle-locate-file', but excluding stuff in VC directories."</span>
<span class="linecomment">;;      (interactive)</span>
<span class="linecomment">;;      (let ((icicle-file-predicate  'not-excluded-vc-file-p))</span>
<span class="linecomment">;;        (icicle-locate-file)))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (defun not-excluded-vc-file-p (file)</span>
<span class="linecomment">;;      "nil if FILE is in a `vc-directory-exclusion-list' directory."</span>
<span class="linecomment">;;      (or (not (boundp 'vc-directory-exclusion-list))</span>
<span class="linecomment">;;          (not (consp vc-directory-exclusion-list))</span>
<span class="linecomment">;;          (not (let ((case-fold-search  completion-ignore-case))</span>
<span class="linecomment">;;                 (catch 'nevfp</span>
<span class="linecomment">;;                   (dolist (dir  vc-directory-exclusion-list)</span>
<span class="linecomment">;;                     (when (string-match</span>
<span class="linecomment">;;                            (concat ".*" dir "\\(/.*\\)?")</span>
<span class="linecomment">;;                            file)</span>
<span class="linecomment">;;                       (throw 'nevfp t)))</span>
<span class="linecomment">;;                   nil)))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-buffer-sort' is a predicate used to sort</span>
<span class="linecomment">;;    buffer-name candidates in commands `icicle-buffer' and</span>
<span class="linecomment">;;    `icicle-buffer-other-window'.  One possible value is</span>
<span class="linecomment">;;    `icicle-buffer-sort-*...*-last', which sorts names of internal</span>
<span class="linecomment">;;    buffers, which begin with `*', after other buffer names.  Option</span>
<span class="linecomment">;;    `icicle-file-sort' acts similarly for file-name completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-buffer-configs' is a list of named</span>
<span class="linecomment">;;    configurations of options `icicle-buffer-match-regexp',</span>
<span class="linecomment">;;    `icicle-buffer-no-match-regexp', `icicle-buffer-predicate',</span>
<span class="linecomment">;;    `icicle-buffer-extras', and `icicle-buffer-sort'.  You use</span>
<span class="linecomment">;;    command `icicle-buffer-config' to choose one of the</span>
<span class="linecomment">;;    configurations to be current.  You can use commands</span>
<span class="linecomment">;;    `icicle-add-buffer-config' and `icicle-remove-buffer-config' to</span>
<span class="linecomment">;;    add and remove configurations from the list.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Example: A configuration such as the following, named "Files and</span>
<span class="linecomment">;;    Scratch", defines `icicle-buffer-predicate' to display only file</span>
<span class="linecomment">;;    buffers, and it defines `icicle-buffer-extras' to include the</span>
<span class="linecomment">;;    extra buffer `*scratch*':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     ("Files and Scratch" nil nil</span>
<span class="linecomment">;;      (lambda (bufname) (buffer-file-name (get-buffer bufname)))</span>
<span class="linecomment">;;      ("*scratch*") icicle-sort-function)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The idea of buffer-option configurations was borrowed from</span>
<span class="linecomment">;;    library `bs.el', by Olaf Sylvester &lt;olaf@geekware.de&gt;.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-list-join-string',</span>
<span class="linecomment">;;    `icicle-list-end-string', and</span>
<span class="linecomment">;;    `icicle-list-nth-parts-join-string' are described in sections</span>
<span class="linecomment">;;    (@&gt; "Multi-Completions") and</span>
<span class="linecomment">;;    (@&gt; "Programming Multi-Completions").  Option</span>
<span class="linecomment">;;    `icicle-list-join-string' is the separator string that joins</span>
<span class="linecomment">;;    together the parts of a multi-completion.  The end string is</span>
<span class="linecomment">;;    appended to each multi-completion candidate.  Option</span>
<span class="linecomment">;;    `icicle-list-nth-parts-join-string' specifies how the</span>
<span class="linecomment">;;    multi-completion extracted parts are joined back together when a</span>
<span class="linecomment">;;    user chooses a multi-completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The default value of `icicle-list-join-string' is `^G^J'.  With</span>
<span class="linecomment">;;    Emacs 22 and later, the `^G' part is hidden when it appears in</span>
<span class="linecomment">;;    *Completions*, and you can hide it in the minibuffer also by</span>
<span class="linecomment">;;    using `C-M-j' instead of typing `C-q C-g C-j'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Face `icicle-candidate-part' highlights one or more parts of a</span>
<span class="linecomment">;;    candidate, in buffer `*Completions*'.  The candidate is</span>
<span class="linecomment">;;    typically a multi-completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Face `icicle-special-candidate' highlights candidates, in</span>
<span class="linecomment">;;    `*Completions*', that are considered "special".  Generally,</span>
<span class="linecomment">;;    these are candidates that match user option</span>
<span class="linecomment">;;    `icicle-special-candidate-regexp'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Similarly, face `icicle-proxy-candidate' highlights proxy</span>
<span class="linecomment">;;    candidates.  These are placeholders for real candidates.</span>
<span class="linecomment">;;    Non-nil user option `icicle-add-proxy-candidates-flag' means</span>
<span class="linecomment">;;    include proxy candidates whenever there are any.  You can toggle</span>
<span class="linecomment">;;    this option during completion using command</span>
<span class="linecomment">;;    `icicle-toggle-proxy-candidates', which is bound to `C-M-_' in</span>
<span class="linecomment">;;    the minibuffer.  For performance reasons, you will in some cases</span>
<span class="linecomment">;;    need to re-invoke the command to make the proxy candidates</span>
<span class="linecomment">;;    available.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Face `icicle-extra-candidate' highlights extra candidates, that</span>
<span class="linecomment">;;    is, members of `icicle-extra-candidates', `icicle-buffer-extras',</span>
<span class="linecomment">;;    or `icicle-file-extras'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-kmacro-ring-max' acts as `kmacro-ring-max'</span>
<span class="linecomment">;;    when you are in Icicle mode.  (When you exit Icicle mode,</span>
<span class="linecomment">;;    `kmacro-ring-max' is restored.)  In Icicles, you will typically</span>
<span class="linecomment">;;    want to use a much larger number than the default value in</span>
<span class="linecomment">;;    vanilla Emacs.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-regexp-search-ring-max' and</span>
<span class="linecomment">;;    `icicle-search-ring-max' act as `regexp-search-ring-max' and</span>
<span class="linecomment">;;    `search-ring-max', respectively, when you are in Icicle mode.</span>
<span class="linecomment">;;    (When you exit Icicle mode, `regexp-search-ring-max' and</span>
<span class="linecomment">;;    `search-ring-max' are restored.)  The reason for having these</span>
<span class="linecomment">;;    options is that with Icicles you will likely want to use a much</span>
<span class="linecomment">;;    longer search history.  By default, these are as large as</span>
<span class="linecomment">;;    possible (virtually unlimited).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Suggestion: If you use library `savehist.el' (recommended),</span>
<span class="linecomment">;;    customize `savehist-additional-variables' to include variables</span>
<span class="linecomment">;;    `search-ring' and `regexp-search-ring', so that your search</span>
<span class="linecomment">;;    histories will be saved between Emacs sessions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note: You can clear (empty) a given search history with command</span>
<span class="linecomment">;;    `clear-option' (aka `icicle-reset-option-to-nil').  For example,</span>
<span class="linecomment">;;    to clear the regular-expression search history, do this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;      `C-u M-x clear-option RET regexp-search-ring RET'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (The `C-u' is needed because this variable is not a user</span>
<span class="linecomment">;;    option.)  If you use my library `misc-cmds.el', you can clear</span>
<span class="linecomment">;;    search histories easier, using commands `clear-search-history',</span>
<span class="linecomment">;;    `clear-regexp-search-history', and `clear-search-histories'.</span>
<span class="linecomment">;;    See (@file :file-name "icicles-doc1.el" :to "Isearch Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-completion-history-max-length' limits the</span>
<span class="linecomment">;;    number of completion inputs to save.  If you customize user</span>
<span class="linecomment">;;    option `icicle-C-l-uses-completion-flag' to non-nil, then,</span>
<span class="linecomment">;;    instead of cycling, `C-l' lets you use Icicles completion to</span>
<span class="linecomment">;;    retrieve a past completion input.  (`C-L' does the same thing.)</span>
<span class="linecomment">;;    If you use library `savehist.el', then you can save the history</span>
<span class="linecomment">;;    of completion inputs persistently by customizing user option</span>
<span class="linecomment">;;    `savehist-additional-variables' to include the Icicles internal</span>
<span class="linecomment">;;    variables `icicle-previous-raw-file-name-inputs' and</span>
<span class="linecomment">;;    `icicle-previous-raw-non-file-name-inputs'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Faces `icicle-completion', `icicle-multi-command-completion',</span>
<span class="linecomment">;;    and `icicle-mustmatch-completion' indicate the status of</span>
<span class="linecomment">;;    minibuffer completion.  During completion, Icicles uses them for</span>
<span class="linecomment">;;    a minibuffer indicator and, if user option</span>
<span class="linecomment">;;    `icicle-highlight-lighter-flag' is non-nil, for the `Icy'</span>
<span class="linecomment">;;    mode-line lighter as well.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil option `icicle-highlight-input-initial-whitespace-flag'</span>
<span class="linecomment">;;    uses face `icicle-whitespace-highlight' to highlight any</span>
<span class="linecomment">;;    whitespace that starts your minibuffer input.  This is done to</span>
<span class="linecomment">;;    help you recognize accidentally typing such whitespace.</span>
<span class="linecomment">;;    Otherwise, you might not understand the set of matching</span>
<span class="linecomment">;;    completion candidates (or lack thereof).  There is not</span>
<span class="linecomment">;;    necessarily anything wrong with input that starts with</span>
<span class="linecomment">;;    whitespace - it might be what you want, but without this</span>
<span class="linecomment">;;    highlighting it is easy to not notice the whitespace.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The part of your current input that does not complete can be</span>
<span class="linecomment">;;    highlighted automatically, and you can then remove that part</span>
<span class="linecomment">;;    using `C-M-l'.  This highlighting is controlled by options</span>
<span class="linecomment">;;    `icicle-incremental-completion-flag',</span>
<span class="linecomment">;;    `icicle-test-for-remote-files-flag',</span>
<span class="linecomment">;;    `icicle-highlight-input-completion-failure',</span>
<span class="linecomment">;;    `icicle-highlight-input-completion-failure-delay', and</span>
<span class="linecomment">;;    `icicle-highlight-input-completion-failure-threshold'.  The</span>
<span class="linecomment">;;    highlighting uses face `icicle-input-completion-fail' (for</span>
<span class="linecomment">;;    strict completion) or `icicle-input-completion-fail-lax' (for</span>
<span class="linecomment">;;    lax completion).  For details, see the option doc strings and</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Icicles Highlights the Input that Won't Complete").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-top-level-key-bindings' specifies top-level</span>
<span class="linecomment">;;    commands and their bindings for Icicle mode.  By default, this</span>
<span class="linecomment">;;    rebinds several standard Emacs keys (in Icicle mode only).  For</span>
<span class="linecomment">;;    example, it substitutes `icicle-kill-buffer' for `kill-buffer'</span>
<span class="linecomment">;;    (binding it to whatever `kill-buffer' is bound to globally).</span>
<span class="linecomment">;;    Top-level commands are commands that are not used only in the</span>
<span class="linecomment">;;    minibuffer.  To change these bindings, customize</span>
<span class="linecomment">;;    `icicle-top-level-key-bindings'.  If you do that, then you must</span>
<span class="linecomment">;;    exit and re-enter Icicle mode to ensure that the change takes</span>
<span class="linecomment">;;    effect.  This is really necessary only if your changes would</span>
<span class="linecomment">;;    undefine a key.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil option `icicle-define-alias-commands-flag' defines a few</span>
<span class="linecomment">;;    top-level Icicles commands whose names do not begin with</span>
<span class="linecomment">;;    `icicle-', for convenience when using `M-x'.  For example,</span>
<span class="linecomment">;;    command `toggle' is defined as an alias for command</span>
<span class="linecomment">;;    `icicle-toggle-option'.  In any case, no such command is ever</span>
<span class="linecomment">;;    defined by Icicles if a function with the same name is already</span>
<span class="linecomment">;;    defined.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-color-themes' is a list of color themes to</span>
<span class="linecomment">;;    cycle through when you use command `icicle-color-theme'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-saved-completion-sets' is a persistent list</span>
<span class="linecomment">;;    of named sets of completion candidates.  You can switch among</span>
<span class="linecomment">;;    such sets at any time.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Persistent Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-filesets-as-saved-completion-sets-flag'</span>
<span class="linecomment">;;    non-nil means you can use Emacs filesets to save completion</span>
<span class="linecomment">;;    candidates persistently.  This means that you can save file-name</span>
<span class="linecomment">;;    candidates in a persistent Icicles saved completion set (cache</span>
<span class="linecomment">;;    file) or in in an Emacs fileset.  It also means that an Icicles</span>
<span class="linecomment">;;    persistent completion set can contain filesets, in addition to</span>
<span class="linecomment">;;    file names: any number of filesets, and filesets of different</span>
<span class="linecomment">;;    type.  Available only for Emacs 22 and later, and you must load</span>
<span class="linecomment">;;    library `filesets.el' (and enable filesets using</span>
<span class="linecomment">;;    `(filesets-init)').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-key-descriptions-use-&lt;&gt;-flag' determines</span>
<span class="linecomment">;;    whether angle brackets (`&lt;', `&gt;') are used by Icicles for named</span>
<span class="linecomment">;;    keys, such as function keys (`&lt;f9&gt;' vs `f9') and pseudo keys</span>
<span class="linecomment">;;    (`&lt;mode-line&gt;' vs `mode-line').  Non-nil means to use angle</span>
<span class="linecomment">;;    brackets.  This option does not affect Emacs key descriptions</span>
<span class="linecomment">;;    outside of Icicles (e.g. `C-h k' or `C-h w'), and it has no</span>
<span class="linecomment">;;    effect for versions of Emacs prior to 21, because they never use</span>
<span class="linecomment">;;    angle brackets.  The default value is nil, because I think angle</span>
<span class="linecomment">;;    brackets reduce readability.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-keymaps-for-key-completion' is a list of</span>
<span class="linecomment">;;    variables that are bound to keymaps in which you want to bind</span>
<span class="linecomment">;;    `S-TAB' (actually, each of the keys in the value of option</span>
<span class="linecomment">;;    `icicle-key-complete-keys') to `icicle-complete-keys'.  Each</span>
<span class="linecomment">;;    such keymap should have at least one prefix key.  `S-TAB' is</span>
<span class="linecomment">;;    bound in each keymap, so that you can use it to complete the</span>
<span class="linecomment">;;    prefix keys.  See also `icicle-complete-key-anyway-flag'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil option `icicle-complete-key-anyway-flag' means bind</span>
<span class="linecomment">;;    `S-TAB' (actually, each of the keys in the value of option</span>
<span class="linecomment">;;    `icicle-key-complete-keys') to `icicle-complete-keys' in each</span>
<span class="linecomment">;;    keymap of option `icicle-keymaps-for-key-completion', regardless</span>
<span class="linecomment">;;    of whether `S-TAB' already has a binding in that keymap.  A</span>
<span class="linecomment">;;    value of nil means bind `S-TAB' only if there is not already a</span>
<span class="linecomment">;;    binding.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil option `icicle-complete-keys-self-insert-flag' means</span>
<span class="linecomment">;;    that `icicle-complete-keys' includes self-inserting keys as</span>
<span class="linecomment">;;    completion candidates.  You will probably want to leave this nil</span>
<span class="linecomment">;;    and use command `icicle-insert-char', not</span>
<span class="linecomment">;;    `icicle-complete-keys', to insert special characters.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-yank-function' is a function to use to yank</span>
<span class="linecomment">;;    text.  By default, it is `yank'.  Command</span>
<span class="linecomment">;;    `icicle-yank-maybe-completing' calls this function, except when</span>
<span class="linecomment">;;    it is called from the minibuffer or called with a negative</span>
<span class="linecomment">;;    prefix argument.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-use-candidates-only-once-flag' means</span>
<span class="linecomment">;;    that acting on a candidate removes it from the set of available</span>
<span class="linecomment">;;    candidates, so that you don't see that it can be used again.</span>
<span class="linecomment">;;    (`TAB' or `S-TAB' makes it available again.)  The default value</span>
<span class="linecomment">;;    is nil, and you probably do not want to customize this.</span>
<span class="linecomment">;;    However, if you write Emacs-Lisp code that uses completion, then</span>
<span class="linecomment">;;    you can bind this to non-nil in contexts where that makes sense.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-deletion-action-flag' means</span>
<span class="linecomment">;;    `S-delete' during completion deletes the current object.  More</span>
<span class="linecomment">;;    precisely, it deletes the object named by the current completion</span>
<span class="linecomment">;;    candidate, if a deletion action is defined for the current</span>
<span class="linecomment">;;    command.  If no deletion action is defined, then the value of</span>
<span class="linecomment">;;    this option has no effect for that command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-anything-transform-candidates-flag'</span>
<span class="linecomment">;;    means that Anything function `anything-transform-candidates' is</span>
<span class="linecomment">;;    applied to displayed Anything candidates in Icicles.  The</span>
<span class="linecomment">;;    default value is nil.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-WYSIWYG-Completions-flag' controls how face</span>
<span class="linecomment">;;    and color names are displayed as candidates in `*Completions*'.</span>
<span class="linecomment">;;    If value is non-nil, then a WYSIWYG (what you see is what you</span>
<span class="linecomment">;;    get) sample of the face or color is shown.  If the value is a</span>
<span class="linecomment">;;    string, then a face name is accompanied by a separate face</span>
<span class="linecomment">;;    swatch with that string text.  If the value is t, then the face</span>
<span class="linecomment">;;    name itself is shown using the face it names.  You can use</span>
<span class="linecomment">;;    command `icicle-toggle-WYSIWYG-Completions' to toggle this</span>
<span class="linecomment">;;    option.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-unpropertize-completion-result-flag'</span>
<span class="linecomment">;;    means that `completing-read' and (starting with Emacs 23)</span>
<span class="linecomment">;;    `read-file-name' will strip all text properties from the result</span>
<span class="linecomment">;;    they return.  The default value is nil.  It is not likely that</span>
<span class="linecomment">;;    you will need to change this, but you might if you use some</span>
<span class="linecomment">;;    other library that cannot accept a propertized string as the</span>
<span class="linecomment">;;    result of completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note: This is the case if you use GNUS - it has a known bug in</span>
<span class="linecomment">;;    this regard (reported 2008-06-21).  It blindly prints the</span>
<span class="linecomment">;;    Emacs-Lisp string that is the result of completion into an MML</span>
<span class="linecomment">;;    attribute value: filename=#("~/.gnus/attach.el" 0 25 (face</span>
<span class="linecomment">;;    nil)).  GNUS should ensure that whatever it uses for an</span>
<span class="linecomment">;;    attribute value is valid for MML (has normal "..." string</span>
<span class="linecomment">;;    syntax, with acceptable characters).  But it simply calls a Lisp</span>
<span class="linecomment">;;    print function, which prints #("...").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-pp-eval-expression-print-length' and</span>
<span class="linecomment">;;    `icicle-pp-eval-expression-print-level' control the Lisp sexp</span>
<span class="linecomment">;;    print length and print level, respectively, for values printed</span>
<span class="linecomment">;;    by `M-:' (`icicle-pp-eval-expression').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil option `icicle-guess-cmds-in-path-flag' means that all</span>
<span class="linecomment">;;    executable files (or all files, if option</span>
<span class="linecomment">;;    `shell-completion-execonly' is nil) in your search path are</span>
<span class="linecomment">;;    included among the completion candidates whenever a</span>
<span class="linecomment">;;    shell-command is read.  The default value is nil, because</span>
<span class="linecomment">;;    computing the available set of shell commands is time-consuming.</span>
<span class="linecomment">;;    Once computed, however, the value is cached.  To update the</span>
<span class="linecomment">;;    cache if your environment changes, just toggle Icicle mode</span>
<span class="linecomment">;;    twice.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-inhibit-ding-flag' means Icicles</span>
<span class="linecomment">;;    never uses an audible bell (ding).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-option-type-prefix-arg-list' is a list of symbols</span>
<span class="linecomment">;;    that control prefix arguments for command</span>
<span class="linecomment">;;    `icicle-describe-option-of-type (bound to `C-h C-o' by</span>
<span class="linecomment">;;    default). A list of six symbols taken from this list:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `direct'            `inherit'            `inherit-or-value'</span>
<span class="linecomment">;;    `direct-or-value'   `inherit-or-regexp'  `direct-or-regexp'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Choose the order you like. The list members map, in order from</span>
<span class="linecomment">;;    left to right, to these prefix argument keys:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;      1. `C-u C-u'</span>
<span class="linecomment">;;      2. `C-0'</span>
<span class="linecomment">;;      3. `C-u'</span>
<span class="linecomment">;;      4. `C-9' (positive)</span>
<span class="linecomment">;;      5. no prefix arg</span>
<span class="linecomment">;;      6. `C--' (negative)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    For the meanings of the symbols, see the doc string of</span>
<span class="linecomment">;;    `icicle-describe-option-of-type', which describes the default</span>
<span class="linecomment">;;    prefix-argument bindings for the command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option `icicle-customize-save-flag' means that</span>
<span class="linecomment">;;    Icicles will save the updated value of option</span>
<span class="linecomment">;;    `icicle-command-abbrev-alist' when you quit Emacs.  This is the</span>
<span class="linecomment">;;    normal behavior.  If you for some reason do not want your</span>
<span class="linecomment">;;    `custom-file' or init file updated in this way, then customize</span>
<span class="linecomment">;;    `icicle-customize-save-flag' to nil.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The value of option `icicle-customize-save-variable-function' is</span>
<span class="linecomment">;;    the function Icicles uses to automatically save user option</span>
<span class="linecomment">;;    changes made by some commands.  I recommend that you do *NOT*</span>
<span class="linecomment">;;    change this option value.  This is provided only for users who</span>
<span class="linecomment">;;    might want to disable such automatic saving of option changes,</span>
<span class="linecomment">;;    by setting this to `ignore', or users who might want to manage</span>
<span class="linecomment">;;    such option saving using their own function instead of the</span>
<span class="linecomment">;;    default value, `customize-save-variable'.</span>
 
<span class="linecomment">;;(@* "File-Name and Directory-Name Completion Tips")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  File-Name and Directory-Name Completion Tips</span>
<span class="linecomment">;;  --------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section contains some tips about completing file and</span>
<span class="linecomment">;;  directory names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Function `icicle-dirs-last-p' is provided as a possible value</span>
<span class="linecomment">;;    for user option `icicle-sort-function'.  It treats file and</span>
<span class="linecomment">;;    directory names specially, sorting directory names after file</span>
<span class="linecomment">;;    names; otherwise, it is the same as `icicle-case-string-less-p'.</span>
<span class="linecomment">;;    (You can of course reach directory names before, instead of</span>
<span class="linecomment">;;    after, file names, by cycling using `up' and `prior' instead of</span>
<span class="linecomment">;;    `down' and `next'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-cycle-into-subdirs-flag' controls whether or</span>
<span class="linecomment">;;    not minibuffer-input cycling explores subdirectories.  By</span>
<span class="linecomment">;;    default, it is nil, meaning that cycling does not descend into</span>
<span class="linecomment">;;    subdirectories.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    non-nil - When this option is non-nil, you might want to use a</span>
<span class="linecomment">;;          function such as `icicle-dirs-last-p' for option</span>
<span class="linecomment">;;          `icicle-sort-function', to prevent cycling depth first</span>
<span class="linecomment">;;          into the subdirectories.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    nil - When this option is nil, you can still choose to cycle</span>
<span class="linecomment">;;          into a given directory (which is why nil is the default</span>
<span class="linecomment">;;          value).  When cycling reaches a candidate directory that</span>
<span class="linecomment">;;          you want to cycle through, just: 1) move the cursor</span>
<span class="linecomment">;;          (e.g. `C-e'), 2) hit `TAB' or `S-TAB' to "complete" the</span>
<span class="linecomment">;;          candidate, and then 3) use any of the cycle keys, such as</span>
<span class="linecomment">;;          `up', to cycle within the candidate directory.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;          Although the candidate directory was already completed by</span>
<span class="linecomment">;;          cycling, moving the cursor and explicitly "completing" it</span>
<span class="linecomment">;;          tells Icicles that you want to treat the candidate in the</span>
<span class="linecomment">;;          minibuffer as real input, just as if you had typed it, not</span>
<span class="linecomment">;;          merely as a cycling candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use `..' during completion to access a parent directory,</span>
<span class="linecomment">;;    and you can use `/' and `~/' to shadow input to the left.  There</span>
<span class="linecomment">;;    is currently no special treatment of MS Windows drive letters</span>
<span class="linecomment">;;    (e.g. `C:') - I use Cygwin on Windows.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-nil user option</span>
<span class="linecomment">;;    `icicle-hide-common-match-in-Completions-flag' hides the common</span>
<span class="linecomment">;;    match for your current input from each candidate in</span>
<span class="linecomment">;;    *Completions*.  You can toggle this at any time during</span>
<span class="linecomment">;;    completion using `C-M-.' (`icicle-toggle-hiding-common-match').</span>
<span class="linecomment">;;    This can be especially useful when reading an absolute file name</span>
<span class="linecomment">;;    (e.g. `C-u C-x C-f'), by removing any common directory</span>
<span class="linecomment">;;    component.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Standard Emacs user option `completion-ignored-extensions' is a</span>
<span class="linecomment">;;    list of file-name extensions.  File names that match any of</span>
<span class="linecomment">;;    these extensions are generally ignored for completion (but see</span>
<span class="linecomment">;;    the doc string for particulars).  In Icicles, however, the</span>
<span class="linecomment">;;    behavior is slightly different:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - In vanilla Emacs the option is itself ignored for display in</span>
<span class="linecomment">;;      buffer `*Completions*'.  That is, even file names that are</span>
<span class="linecomment">;;      ignored for completion are shown in `*Completions*' as</span>
<span class="linecomment">;;      available completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - In Icicles this is not the case. When a file name is ignored</span>
<span class="linecomment">;;      it is ignored completely; it is not shown in `*Completions*'.</span>
<span class="linecomment">;;      But in Icicles you can toggle this ignoring off or on at any</span>
<span class="linecomment">;;      time during completion, using `C-.' in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-use-~-for-home-dir-flag' controls whether</span>
<span class="linecomment">;;    your home directory is written in the minibuffer using `~' or in</span>
<span class="linecomment">;;    expanded form, during completion.  The default value is `t',</span>
<span class="linecomment">;;    which means to use `~', saving minibuffer space.  You can toggle</span>
<span class="linecomment">;;    this option at any time using command</span>
<span class="linecomment">;;    `icicle-toggle-~-for-home-dir', bound to `M-~'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Remember that you can use a regular expression to</span>
<span class="linecomment">;;    apropos-complete file names.  This is a powerful feature.  Do</span>
<span class="linecomment">;;    not confuse its use with the ability to use shell wildcards</span>
<span class="linecomment">;;    (globbing) to access multiple files at once.  For example, if</span>
<span class="linecomment">;;    you use `C-x 4 f *.el RET', then all files with suffix `el' will</span>
<span class="linecomment">;;    be opened.  Regexp matching is used only for apropos (not</span>
<span class="linecomment">;;    prefix) completion and cycling.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "What About Special-Character Conflicts?").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use `$' for both environment variables and as a regexp</span>
<span class="linecomment">;;    special character.  For example, you can use a pattern such as</span>
<span class="linecomment">;;    `$HOME.*t$' to match the files in your home directory (`$HOME')</span>
<span class="linecomment">;;    whose names end in `t'.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "What About Special-Character Conflicts?").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use the idiom `\W$' as input to match only directories,</span>
<span class="linecomment">;;    when a command asks for a file or directory name.  The `\W' says</span>
<span class="linecomment">;;    to match any non word-syntax character.  The `$' says to match</span>
<span class="linecomment">;;    this at the end of the name.  This works because directory names</span>
<span class="linecomment">;;    appear as completion candidates with a trailing slash (`/'), and</span>
<span class="linecomment">;;    slash (`/') is about the only non word-syntax character that is</span>
<span class="linecomment">;;    likely to appear in file-name completions.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "What About Special-Character Conflicts?").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use library `ffap.el', if you like, with Icicles, to</span>
<span class="linecomment">;;    pick up the file, directory, or URL name under the cursor.  All</span>
<span class="linecomment">;;    Icicles features are available during file-name and URL</span>
<span class="linecomment">;;    completion.  If you like `ffap.el', you might also like to try</span>
<span class="linecomment">;;    my extension library `ffap-.el'.   See also</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Inserting Text Found Near the Cursor").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Many Icicles commands that target file or directory names look</span>
<span class="linecomment">;;    only in the current directory (`default-directory').  This means</span>
<span class="linecomment">;;    that the directory part of the name is ignored for matching</span>
<span class="linecomment">;;    purposes.  You can thus use apropos completion to match a</span>
<span class="linecomment">;;    substring, without needing to prefix the substring with `.*'.</span>
<span class="linecomment">;;    For example, to match file `favorite-foo-file.bar' in directory</span>
<span class="linecomment">;;    `/some/path/to/my/', it is sufficient to use either `foo' or</span>
<span class="linecomment">;;    `/some/path/to/my/foo'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Some Icicles commands that target file names match your input</span>
<span class="linecomment">;;    against absolute file-name completion candidates.  This is the</span>
<span class="linecomment">;;    case for `icicle-locate-file', `icicle-recent-file', and</span>
<span class="linecomment">;;    `icicle-find-file-absolute', as well as `icicle-file' with a</span>
<span class="linecomment">;;    prefix argument.  These commands let you regexp-match against</span>
<span class="linecomment">;;    any part of the absolute file name, including directory</span>
<span class="linecomment">;;    components.</span>
<span class="linecomment">;;    See (@file :file-name "icicles-doc1.el" :to "File-Name Input and Locating Files Anywhere").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Customization and General Tips") for general tips about</span>
<span class="linecomment">;;    using Icicles.  Many of those tips apply also to file-name and</span>
<span class="linecomment">;;    directory-name completion.</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "File-Name Input and Locating Files Anywhere").</span>
 
<span class="linecomment">;;(@* "Key Bindings")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Key Bindings</span>
<span class="linecomment">;;  ------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Global Bindings")</span>
<span class="linecomment">;;  ** Global Bindings **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles does not change your global key bindings.  It changes some</span>
<span class="linecomment">;;  minibuffer bindings, and it adds some bindings for Icicle mode,</span>
<span class="linecomment">;;  but it does not change your global bindings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are two exceptions:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. In Icicle mode, various Icicles commands are added to menu-bar</span>
<span class="linecomment">;;  menus.  File commands are added to the File menu, and so on, under</span>
<span class="linecomment">;;  an Icicles submenu.  Those items that do not belong naturally to</span>
<span class="linecomment">;;  any existing menu-bar menu are added to a new top-level Icicles</span>
<span class="linecomment">;;  menu and to the existing Minibuf menu.  Whatever the menu they</span>
<span class="linecomment">;;  appear in, however, Icicles menu items are visible only when</span>
<span class="linecomment">;;  Icicle mode is active.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you do not want Icicles to add items to menus besides Minibuf</span>
<span class="linecomment">;;  and Icicles, then set option `icicle-touche-pas-aux-menus' to</span>
<span class="linecomment">;;  non-nil.  See (@&gt; "Customizing Key Bindings").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Icicles adds the key `S-TAB' (bound to `icicle-complete-keys')</span>
<span class="linecomment">;;  to each existing keymap.  This allows you to complete keys in any</span>
<span class="linecomment">;;  keymap.  For technical reasons, these bindings are not part of</span>
<span class="linecomment">;;  `icicle-mode-map'; other keymaps are enhanced to include this</span>
<span class="linecomment">;;  binding.  However, this Icicles binding of `S-TAB' never replaces</span>
<span class="linecomment">;;  any existing binding of `S-TAB'.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Key Completion") for more</span>
<span class="linecomment">;;  information about this use of `S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (The documentation always refers to the key that performs key</span>
<span class="linecomment">;;  completion as `S-TAB'.  Actually, it is `S-TAB' only by default.</span>
<span class="linecomment">;;  You can customize it, using option `icicle-key-complete-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicle-Mode Bindings")</span>
<span class="linecomment">;;  ** Icicle-Mode Bindings **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Most Icicle-mode bindings are in the Icicles menu-bar menu.  In</span>
<span class="linecomment">;;  addition, option `icicle-top-level-key-bindings' causes Icicles to</span>
<span class="linecomment">;;  bind some keyboard keys to some top-level Icicles commands.  Some</span>
<span class="linecomment">;;  of these take the place of similar, global bindings whenever you</span>
<span class="linecomment">;;  are in Icicle mode.  Typically, these top-level commands are</span>
<span class="linecomment">;;  Icicles multi-command versions of the vanilla Emacs commands.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc1.el" :to "Multi-Commands").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can customize option `icicle-top-level-key-bindings' to</span>
<span class="linecomment">;;  specify the top-level commands that you want to bind in Icicle</span>
<span class="linecomment">;;  mode, and the keys you want to bind them to.  With the default</span>
<span class="linecomment">;;  value of `icicle-top-level-key-bindings', Icicles makes the</span>
<span class="linecomment">;;  following Icicle-mode bindings:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-c ''          - `icicle-occur'</span>
<span class="linecomment">;;  * `C-c ='          - `icicle-imenu'</span>
<span class="linecomment">;;  * `C-c `'          - `icicle-search'</span>
<span class="linecomment">;;  * `C-c `'          - `icicle-compilation-search' (in *grep* etc.)</span>
<span class="linecomment">;;  * `C-c `'          - `icicle-comint-search' (in *shell* etc.)</span>
<span class="linecomment">;;  * `C-c TAB'        - `icicle-comint-command' (in *shell* etc.)</span>
<span class="linecomment">;;  * `C-c /'          - `icicle-complete-thesaurus-entry'</span>
<span class="linecomment">;;  * `C-h C-o'        - `icicle-describe-option-of-type'</span>
<span class="linecomment">;;  * `ESC M-x', `M-`' - `lacarte-execute-menu-command'</span>
<span class="linecomment">;;  * `M-x'            - `icicle-execute-extended-command'</span>
<span class="linecomment">;;  * `C-x SPC'        - `icicle-command-abbrev'</span>
<span class="linecomment">;;  * `C-x M-e'        - `icicle-execute-named-keyboard-macro'</span>
<span class="linecomment">;;  * `S-f4'           - `icicle-kmacro'</span>
<span class="linecomment">;;  * `pause'          - `icicle-switch-to/from-minibuffer'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `S-TAB' is bound, in effect, to `icicle-complete-keys', which</span>
<span class="linecomment">;;  completes a key sequence.  Prefix keys followed by `S-TAB' are</span>
<span class="linecomment">;;  also bound to `icicle-complete-keys'.  (`S-TAB' is effectively</span>
<span class="linecomment">;;  bound to other commands in buffer `*Completions*' and in the</span>
<span class="linecomment">;;  minibuffer.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (The documentation always refers to the key that performs key</span>
<span class="linecomment">;;  completion as `S-TAB'.  Actually, it is `S-TAB' only by default.</span>
<span class="linecomment">;;  You can customize it, using option `icicle-key-complete-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When `icicle-top-level-key-bindings' has its default value,</span>
<span class="linecomment">;;  Icicles also substitutes all of the key bindings for some standard</span>
<span class="linecomment">;;  Emacs commands.  For example, Icicles binds `icicle-buffer' to all</span>
<span class="linecomment">;;  keys that are globally bound outside Icicle mode to standard</span>
<span class="linecomment">;;  command `switch-to-buffer'.  By default, the following standard</span>
<span class="linecomment">;;  commands have their bindings co-opted this way by Icicles</span>
<span class="linecomment">;;  commands:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Standard Command                   Icicles Command</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `abort-recursive-edit'.............`icicle-abort-recursive-edit'</span>
<span class="linecomment">;;  `bookmark-set'.....................`icicle-bookmark-cmd'</span>
<span class="linecomment">;;  `dabbrev-completion'...............`icicle-dabbrev-completion'</span>
<span class="linecomment">;;  `delete-window'....................`icicle-delete-window'</span>
<span class="linecomment">;;  `eval-expression'..................`icicle-pp-eval-expression'</span>
<span class="linecomment">;;  `exchange-point-and-mark'.........`icicle-exchange-point-and-mark'</span>
<span class="linecomment">;;  `execute-extended-command'.......`icicle-execute-extended-command'</span>
<span class="linecomment">;;  `find-file'........................`icicle-file'</span>
<span class="linecomment">;;  `find-file-other-window'...........`icicle-file-other-window'</span>
<span class="linecomment">;;  `find-tag'.........................`icicle-find-tag'</span>
<span class="linecomment">;;  `find-tag-other-window'.......`icicle-find-first-tag-other-window'</span>
<span class="linecomment">;;  `Info-goto-node'...................`icicle-Info-goto-node'</span>
<span class="linecomment">;;  `Info-index'.......................`icicle-Info-index'</span>
<span class="linecomment">;;  `Info-menu'........................`icicle-Info-menu'</span>
<span class="linecomment">;;  `kill-buffer'......................`icicle-kill-buffer'</span>
<span class="linecomment">;;  `lisp-complete-symbol'.............`icicle-lisp-complete-symbol'</span>
<span class="linecomment">;;  `other-window'.....................`icicle-other-window-or-frame'</span>
<span class="linecomment">;;  `other-frame'......................`icicle-select-frame'</span>
<span class="linecomment">;;  `pop-global-mark'...`icicle-goto-global-marker-or-pop-global-mark'</span>
<span class="linecomment">;;  `pop-tag-mark'.....................`icicle-pop-tag-mark'</span>
<span class="linecomment">;;  `pp-eval-expression'...............`icicle-pp-eval-expression'</span>
<span class="linecomment">;;  `set-mark-command'........`icicle-goto-marker-or-set-mark-command'</span>
<span class="linecomment">;;  `switch-to-buffer'.................`icicle-buffer'</span>
<span class="linecomment">;;  `switch-to-buffer-other-window'....`icicle-buffer-other-window'</span>
<span class="linecomment">;;  `where-is'.........................`icicle-where-is'</span>
<span class="linecomment">;;  `yank'.............................`icicle-yank-maybe-completing'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Actually, by default, Icicles binds `icicle-yank-maybe-completing'</span>
<span class="linecomment">;;  to whatever the value of option `icicle-yank-function' is.  By</span>
<span class="linecomment">;;  default, this value is `yank'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here are some other Icicles commands that you might want to bind</span>
<span class="linecomment">;;  to keys in Icicle mode - they are not bound by Icicles (except to</span>
<span class="linecomment">;;  menu items):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `clear-option' (alias) - Set value of binary option to nil</span>
<span class="linecomment">;;  `icicle-add-buffer-candidate' -</span>
<span class="linecomment">;;                          Add buffer to those always shown</span>
<span class="linecomment">;;  `icicle-add-buffer-config' - Add to `icicle-buffer-configs'</span>
<span class="linecomment">;;  `icicle-add-entry-to-saved-completion-set' -</span>
<span class="linecomment">;;                          Add a completion candidate to a saved set</span>
<span class="linecomment">;;  `icicle-add/update-saved-completion-set' - Add a set to</span>
<span class="linecomment">;;                          `icicle-saved-completion-sets'</span>
<span class="linecomment">;;  `icicle-apply'        - Selectively apply function to alist items</span>
<span class="linecomment">;;  `icicle-apropos'      - `apropos', but shows matches</span>
<span class="linecomment">;;  `icicle-apropos-command' - Enhanced `apropos-command'</span>
<span class="linecomment">;;  `icicle-apropos-variable' - Enhanced `apropos-variable'</span>
<span class="linecomment">;;  `icicle-apropos-zippy' - Show matching Zippy quotes</span>
<span class="linecomment">;;  `icicle-bookmark'     - Jump to a bookmark</span>
<span class="linecomment">;;  `icicle-buffer-config' - Pick `icicle-buffer' options</span>
<span class="linecomment">;;  `icicle-buffer-list'  - Choose a list of buffer names</span>
<span class="linecomment">;;  `icicle-clear-history' - Clear minibuffer histories</span>
<span class="linecomment">;;  `icicle-color-theme'  - Change color theme</span>
<span class="linecomment">;;  `icicle-completing-yank' - Yank text using completion</span>
<span class="linecomment">;;  `icicle-customize-face' - Multi-command `customize-face'</span>
<span class="linecomment">;;  `icicle-customize-icicles-group' -</span>
<span class="linecomment">;;                          Customize Icicles options and faces</span>
<span class="linecomment">;;  `icicle-delete-file'  - Delete a file or directory</span>
<span class="linecomment">;;  `icicle-delete-windows' - Delete all windows for a buffer</span>
<span class="linecomment">;;  `icicle-doc'          - Display doc of function, variable, or face</span>
<span class="linecomment">;;  `icicle-face-list'    - Choose a list of face names</span>
<span class="linecomment">;;  `icicle-file-list'    - Choose a list of file names</span>
<span class="linecomment">;;  `icicle-font'         - Change the frame font</span>
<span class="linecomment">;;  `icicle-frame-bg'     - Change the frame background color</span>
<span class="linecomment">;;  `icicle-frame-fg'     - Change the frame foreground color</span>
<span class="linecomment">;;  `icicle-fundoc'       - Display the doc of a function</span>
<span class="linecomment">;;  `icicle-insert-thesaurus-entry' -</span>
<span class="linecomment">;;                          Insert a thesaurus entry</span>
<span class="linecomment">;;  `icicle-keyword-list' - Choose a list of keywords (regexps)</span>
<span class="linecomment">;;  `icicle-locate-file'  - Open a file located anywhere</span>
<span class="linecomment">;;  `icicle-minibuffer-help' - Show Icicles minibuffer help</span>
<span class="linecomment">;;  `icicle-recent-file'  - Open a recently used file</span>
<span class="linecomment">;;  `icicle-remove-buffer-candidate' -</span>
<span class="linecomment">;;                          Remove buffer from those always shown</span>
<span class="linecomment">;;  `icicle-remove-buffer-config' -</span>
<span class="linecomment">;;                          Remove from `icicle-buffer-configs'</span>
<span class="linecomment">;;  `icicle-remove-entry-from-saved-completion-set' -</span>
<span class="linecomment">;;                          Remove a candidate from a saved set</span>
<span class="linecomment">;;  `icicle-remove-saved-completion-set' - Remove a set from</span>
<span class="linecomment">;;                          `icicle-saved-completion-sets'</span>
<span class="linecomment">;;  `icicle-reset-option-to-nil' -</span>
<span class="linecomment">;;                          Set value of binary option to nil</span>
<span class="linecomment">;;  `icicle-save-string-to-variable' -</span>
<span class="linecomment">;;                          Save text for use with `C-='</span>
<span class="linecomment">;;  `icicle-select-window' - Select a window by its buffer name</span>
<span class="linecomment">;;  `icicle-set-option-to-t' - Set value of binary option to t</span>
<span class="linecomment">;;  `icicle-toggle-option' - Toggle the value of a binary option</span>
<span class="linecomment">;;  `icicle-vardoc'       - Display the doc of a variable</span>
<span class="linecomment">;;  `toggle' (alias)      - Toggle the value of a binary option</span>

<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Minibuffer Bindings")</span>
<span class="linecomment">;;  ** Minibuffer Bindings **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are many key bindings available during completion.  Most of</span>
<span class="linecomment">;;  these key sequences are bound in the minibuffer completion</span>
<span class="linecomment">;;  keymaps, but some are bound in the `*Completions*' buffer keymap.</span>
<span class="linecomment">;;  In addition, clicking `C-mouse-3' on a completion candidate in</span>
<span class="linecomment">;;  buffer `*Completions*' pops up a menu of available commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Some of these menu commands are applicable to the completion you</span>
<span class="linecomment">;;  click; others apply to the current state of completion or to the</span>
<span class="linecomment">;;  complete set of completion candidates.  The associated key</span>
<span class="linecomment">;;  bindings are indicated in the menu items, so this can be a good</span>
<span class="linecomment">;;  way to learn minibuffer and `*Completions*' bindings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following key bindings are made for the minibuffer completion</span>
<span class="linecomment">;;  keymaps.  They are in effect whenever you are using the minibuffer</span>
<span class="linecomment">;;  for input with completion (e.g. `completing-read',</span>
<span class="linecomment">;;  `read-file-name', `M-x').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-?' - `icicle-minibuffer-help': Pop up a *Help* buffer with</span>
<span class="linecomment">;;            information on using the minibuffer in Icicle mode.</span>
<span class="linecomment">;;            During completion, this includes information similar to</span>
<span class="linecomment">;;            what you are reading now.  It also includes toggle</span>
<span class="linecomment">;;            commands and the current toggle values.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `down', `up'    - `icicle-next-prefix-candidate',</span>
<span class="linecomment">;;                      `icicle-next-candidate-per-mode' (modal),</span>
<span class="linecomment">;;                      `icicle-previous-prefix-candidate',</span>
<span class="linecomment">;;                      `icicle-previous-candidate-per-mode' (modal),</span>
<span class="linecomment">;;                      which cycle candidate prefix completions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `next', `prior' - `icicle-next-apropos-candidate',</span>
<span class="linecomment">;;                      `icicle-previous-apropos-candidate', which</span>
<span class="linecomment">;;                      cycle candidate apropos completions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;                     (The documentation always refers to the keys</span>
<span class="linecomment">;;                     that cycle completion candidates as `down',</span>
<span class="linecomment">;;                     `up', `next', and `prior'.  Actually, these are</span>
<span class="linecomment">;;                     the cycling keys only by default.  You can</span>
<span class="linecomment">;;                     customize the cycling keys, using options</span>
<span class="linecomment">;;                     `icicle-prefix-cycle-next-keys',</span>
<span class="linecomment">;;                     `icicle-modal-cycle-down-keys' (modal),</span>
<span class="linecomment">;;                     `icicle-prefix-cycle-previous-keys',</span>
<span class="linecomment">;;                     `icicle-modal-cycle-up-keys' (modal),</span>
<span class="linecomment">;;                     `icicle-apropos-cycle-next-keys', and</span>
<span class="linecomment">;;                     `icicle-apropos-cycle-previous-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Keys bound globally to commands that perform simple text</span>
<span class="linecomment">;;    insertion, deletion, and transposition operations - commands</span>
<span class="linecomment">;;    such as `self-insert-command' - are bound to Icicles versions of</span>
<span class="linecomment">;;    those commands that do the same thing but also provide apropos</span>
<span class="linecomment">;;    icompletion.  This includes keys such as `C-d', `C-k', and `C-w'</span>
<span class="linecomment">;;    (and lots more).  See (@file :file-name "icicles-doc1.el" :to "Icompletion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `pause'  - `icicle-switch-to/from-minibuffer': Move cursor to</span>
<span class="linecomment">;;               the buffer from which the minibuffer was activated.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-insert' - `icicle-switch-to-Completions-buf': Move cursor to</span>
<span class="linecomment">;;               the current candidate in buffer `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-*'    - `icicle-narrow-candidates': Narrow the set of</span>
<span class="linecomment">;;               completion candidates using another input regexp.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-SPC'  - `icicle-prefix-word-complete': Complete current input</span>
<span class="linecomment">;;               in minibuffer, as a prefix, a single word at a time.</span>
<span class="linecomment">;;               This replaces `minibuffer-complete-word'.  In fact,</span>
<span class="linecomment">;;               it is the keys in `icicle-word-completion-keys' that</span>
<span class="linecomment">;;               are bound to this command; `M-SPC' is by default.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `S-SPC'  - `icicle-apropos-complete-and-narrow': Same as</span>
<span class="linecomment">;;               `S-TAB' followed by `M-*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `TAB' -    `icicle-prefix-complete': Complete current input in</span>
<span class="linecomment">;;               minibuffer, as a prefix.  If there is more than one</span>
<span class="linecomment">;;               prefix-completion candidate, display them in buffer</span>
<span class="linecomment">;;               `*Completions*', highlighting the common prefix.</span>
<span class="linecomment">;;               This replaces `minibuffer-complete'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;               (The documentation always refers to the key that does</span>
<span class="linecomment">;;               this as `TAB'.  Actually, it is only `TAB' by</span>
<span class="linecomment">;;               default.  You can customize it, using option</span>
<span class="linecomment">;;               `icicle-prefix-complete-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `S-TAB'  - In the minibuffer: `icicle-apropos-complete' - like</span>
<span class="linecomment">;;               `TAB', but use apropos completion.  In buffer</span>
<span class="linecomment">;;               `*Completions*': `icicle-move-to-previous-completion'</span>
<span class="linecomment">;;               - move backwards among candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;               (The documentation always refers to the keys that do</span>
<span class="linecomment">;;               these things as `S-TAB'.  Actually, they are only</span>
<span class="linecomment">;;               `S-TAB' by default.  You can customize the keys,</span>
<span class="linecomment">;;               using options `icicle-apropos-complete-keys' and</span>
<span class="linecomment">;;               `icicle-previous-candidate-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-TAB' - `icicle-prefix-complete-no-display': Like `TAB', but</span>
<span class="linecomment">;;               does not display candidates in `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;               (The documentation always refers to the key that does</span>
<span class="linecomment">;;               this as `C-M-TAB'.  Actually, it is only `C-M-TAB' by</span>
<span class="linecomment">;;               default.  You can customize it, using option</span>
<span class="linecomment">;;               `icicle-prefix-complete-no-display-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-S-TAB' - `icicle-apropos-complete-no-display': Like</span>
<span class="linecomment">;;               `S-TAB', but does not display candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;               (The documentation always refers to the key that does</span>
<span class="linecomment">;;               this as `C-M-S-TAB'.  Actually, it is only</span>
<span class="linecomment">;;               `C-M-S-TAB' by default.  You can customize it, using</span>
<span class="linecomment">;;               option `icicle-apropos-complete-no-display-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-&'  - `icicle-save-predicate-to-variable': Save the current</span>
<span class="linecomment">;;               predicate used for completion to a variable.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `delete' - `icicle-remove-candidate': Remove the current</span>
<span class="linecomment">;;               candidate from consideration.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `S-mouse-2' - `icicle-mouse-remove-candidate': Same as `delete'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-q'    - `icicle-insert-key-description': Insert the textual</span>
<span class="linecomment">;;               representation of a key sequence, during key</span>
<span class="linecomment">;;               completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-o'    - `icicle-insert-history-element': Use completion to</span>
<span class="linecomment">;;               insert a previously entered input in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, multi-line completion candidates are not uncommon.</span>
<span class="linecomment">;;  You can move up and down minibuffer lines with `C-p' and `C-n',</span>
<span class="linecomment">;;  and you can use the following keys to move among line beginnings</span>
<span class="linecomment">;;  and ends:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-a', `C-e' - `icicle-beginning-of-line+',</span>
<span class="linecomment">;;               `icicle-end-of-line+': Like normal `C-a', `C-e', but</span>
<span class="linecomment">;;               repeating goes to the previous or next line.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-o' - `1on1-fit-minibuffer-frame': Fit minibuffer frame.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That is, if you use libraries `fit-frame.el', `setup-keys.el', and</span>
<span class="linecomment">;;  `oneonone.el' with a standalone minibuffer frame, then `C-o' in</span>
<span class="linecomment">;;  the minibuffer fits the minibuffer frame height to its contents.</span>
<span class="linecomment">;;  Repeat to increase the height a line at a time.  Similarly, `C-j'</span>
<span class="linecomment">;;  (`icicle-insert-newline-in-minibuffer') and `C-M-j' (see next)</span>
<span class="linecomment">;;  each insert a newline and then fit the minibuffer frame.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-j' - `icicle-insert-list-join-string': Insert</span>
<span class="linecomment">;;              `icicle-list-join-string'. See also</span>
<span class="linecomment">;;              (@&gt; "Multi-Completions").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you prefer, you can use the keys that are defined by options</span>
<span class="linecomment">;;  `icicle-modal-cycle-up-keys', `icicle-modal-cycle-down-keys',</span>
<span class="linecomment">;;  `icicle-modal-cycle-up-action-keys', and</span>
<span class="linecomment">;;  `icicle-modal-cycle-down-action-keys' (`up', `down', `C-up', and</span>
<span class="linecomment">;;  `C-down', by default) for both prefix and apropos completion, as</span>
<span class="linecomment">;;  well as for input-history traversal - the behavior is determined</span>
<span class="linecomment">;;  by the value of option `icicle-cycling-respects-completion-mode'</span>
<span class="linecomment">;;  and whether you have previously used `TAB' or `S-TAB'.  The</span>
<span class="linecomment">;;  documentation assumes the default value of nil.  See</span>
<span class="linecomment">;;  (@&gt; "Customization and General Tips").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In vanilla Emacs, the following keys have a special purpose during</span>
<span class="linecomment">;;  input completion, but in Icicles they simply insert the character</span>
<span class="linecomment">;;  typed - they are self-inserting.  This is because (1) there are</span>
<span class="linecomment">;;  better ways to do what vanilla Emacs uses these keys for and (2)</span>
<span class="linecomment">;;  it is useful to be able to insert these characters without first</span>
<span class="linecomment">;;  typing `C-q' to quote them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `?'   - see also</span>
<span class="linecomment">;;            (@file :file-name "icicles-doc1.el" :to "What About Special-Character Conflicts?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `SPC' (space)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-j' (newline) - see also `C-o', above, and</span>
<span class="linecomment">;;                      (@&gt; "Multi-Completions")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings are made to clear minibuffer</span>
<span class="linecomment">;;  input, making them handy for editing and removing completions</span>
<span class="linecomment">;;  (e.g. default or initial values) in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-k' - `icicle-erase-minibuffer-or-history-element'</span>
<span class="linecomment">;;    `M-S-backspace', `M-S-delete' - `icicle-erase-minibuffer'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `M-k' has an alternative behavior when you are cycling minibuffer</span>
<span class="linecomment">;;  history items: it deletes the current item from the history.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During (absolute or relative) file-name completion, the following</span>
<span class="linecomment">;;  minibuffer binding navigates up the directory hierarchy.  It</span>
<span class="linecomment">;;  removes the last directory component (and any partial file name)</span>
<span class="linecomment">;;  from your minibuffer input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-backspace'   - `icicle-up-directory'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer binding moves the cursor to the start of</span>
<span class="linecomment">;;  the part of your input, if any, that is highlighted because it</span>
<span class="linecomment">;;  does not match any completion candidate (see option</span>
<span class="linecomment">;;  `icicle-highlight-input-completion-failure').  Repeating this</span>
<span class="linecomment">;;  command kills the rest of the line, removing the highlighted</span>
<span class="linecomment">;;  mismatched input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-l'         - `icicle-goto/kill-failed-input'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The remaining input matches at least one candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings can be used to get rid of a</span>
<span class="linecomment">;;  completion inserted during cycling, and retrieve what you last</span>
<span class="linecomment">;;  typed during completion or any previous completion inputs:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-l'           - `icicle-retrieve-previous-input'</span>
<span class="linecomment">;;    `C-S-l' (`C-L') - `icicle-retrieve-next-input'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use these to cycle among and reuse inputs that you typed</span>
<span class="linecomment">;;  during completion but did not enter.  This completion input is not</span>
<span class="linecomment">;;  recorded in the standard input histories - they record only input</span>
<span class="linecomment">;;  that you have entered with `RET'.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc1.el" :to "History Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, suppose that you used `C-h v hook' to examine various</span>
<span class="linecomment">;;  hook variables, and you did this using`C-next' to display their</span>
<span class="linecomment">;;  documentation.  If you finished the command by just typing `C-g',</span>
<span class="linecomment">;;  then your input (`hook') was never really entered, so it is not</span>
<span class="linecomment">;;  available via the minibuffer history (`M-p').  You can retrieve it</span>
<span class="linecomment">;;  with `C-l', to use it again, in your next command.  User option</span>
<span class="linecomment">;;  `icicle-C-l-uses-completion-flag' controls the behavior of `C-l'</span>
<span class="linecomment">;;  and `C-L'; if non-nil, then, instead of cycling inputs, these</span>
<span class="linecomment">;;  commands let you access previous inputs using completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You of course have the standard access to the minibuffer history,</span>
<span class="linecomment">;;  via `M-p', `M-n', `M-r', and `M-s'.  In addition to these, the</span>
<span class="linecomment">;;  following minibuffer bindings let you use apropos completion on</span>
<span class="linecomment">;;  the current minibuffer history list.  For explanation, see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "History Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-h'     - `icicle-history'</span>
<span class="linecomment">;;    `M-pause' - `icicle-keep-only-past-inputs'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings let you act on candidate</span>
<span class="linecomment">;;  completions.  For explanation, see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands"),</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "More about Multi-Commands"),</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Choose All Completion Candidates"),</span>
<span class="linecomment">;;  and (@&gt; "OO: Object-Action Interaction").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-RET'     - `icicle-candidate-action': current candidate</span>
<span class="linecomment">;;    `C-mouse-2' - `icicle-mouse-candidate-action': clicked candidate</span>
<span class="linecomment">;;    `C-up'      - `icicle-previous-prefix-candidate-action'</span>
<span class="linecomment">;;    `C-up'      - `icicle-previous-candidate-per-mode-action'(modal)</span>
<span class="linecomment">;;    `C-down'    - `icicle-next-prefix-candidate-action'</span>
<span class="linecomment">;;    `C-down'    - `icicle-next-candidate-per-mode-action' (modal)</span>
<span class="linecomment">;;    `C-prior'   - `icicle-previous-apropos-candidate-action'</span>
<span class="linecomment">;;    `C-next'    - `icicle-next-apropos-candidate-action'</span>
<span class="linecomment">;;    `C-!'       - `icicle-all-candidates-action': each candidate</span>
<span class="linecomment">;;    `M-!'       - `icicle-all-candidates-list-action': all, as list</span>
<span class="linecomment">;;    `M-RET'     - `icicle-candidate-read-fn-invoke': apply function</span>
<span class="linecomment">;;    `M-mouse-2' - `icicle-mouse-yank-secondary' (in minibuffer)</span>
<span class="linecomment">;;    `M-mouse-2' - `icicle-mouse-candidate-read-fn-invoke': apply fn</span>
<span class="linecomment">;;    `S-delete'  - `icicle-delete-candidate-object': delete object</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Except as noted, the bindings for `icicle-mouse-*' are actually in</span>
<span class="linecomment">;;  the `*Completions*' buffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings provide help on candidate</span>
<span class="linecomment">;;  completions.  For explanation, see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Get Help on Candidates")</span>
<span class="linecomment">;;  and (@file :file-name "icicles-doc1.el" :to "Multi-Commands").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-RET'   - `icicle-help-on-candidate': current candidate</span>
<span class="linecomment">;;    `C-M-mouse-2' - `icicle-mouse-help-on-candidate': clicked</span>
<span class="linecomment">;;    `C-M-up'    - `icicle-help-on-previous-prefix-candidate'</span>
<span class="linecomment">;;    `C-M-down'  - `icicle-help-on-next-prefix-candidate'</span>
<span class="linecomment">;;    `C-M-prior' - `icicle-help-on-previous-apropos-candidate'</span>
<span class="linecomment">;;    `C-M-next'  - `icicle-help-on-next-apropos-candidate'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings provide an alternative action</span>
<span class="linecomment">;;  for individual candidates.  The alternative action is specific to</span>
<span class="linecomment">;;  the given command.  Most commands define no alternative action.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-S-RET'     - `icicle-candidate-alt-action': current candidate</span>
<span class="linecomment">;;    `C-S-mouse-2' - `icicle-mouse-candidate-alt-action': clicked</span>
<span class="linecomment">;;    `C-S-up'      - `icicle-previous-prefix-candidate-alt-action'</span>
<span class="linecomment">;;    `C-S-down'    - `icicle-next-prefix-candidate-alt-action'</span>
<span class="linecomment">;;    `C-S-prior'   - `icicle-previous-apropos-candidate-alt-action'</span>
<span class="linecomment">;;    `C-S-next'    - `icicle-next-apropos-candidate-alt-action'</span>
<span class="linecomment">;;    `C-|'         - `icicle-all-candidates-alt-action': each</span>
<span class="linecomment">;;    `M-|'         - `icicle-all-candidates-list-alt-action': list</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings let you perform set operations</span>
<span class="linecomment">;;  on sets of completion candidates.  For explanation, see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-~'     - `icicle-candidate-set-complement'</span>
<span class="linecomment">;;    `C--'     - `icicle-candidate-set-difference'</span>
<span class="linecomment">;;    `C-+'     - `icicle-candidate-set-union'</span>
<span class="linecomment">;;    `C-*'     - `icicle-candidate-set-intersection'</span>
<span class="linecomment">;;    `C-M-&lt;'   - `icicle-candidate-set-retrieve': retrieve saved set</span>
<span class="linecomment">;;    `C-M-&gt;'   - `icicle-candidate-set-save': save current set</span>
<span class="linecomment">;;    `C-M-)'   - `icicle-candidate-set-save-selected': save selected</span>
<span class="linecomment">;;    `C-&lt;'     - `icicle-candidate-set-retrieve-more': add from saved</span>
<span class="linecomment">;;    `C-&gt;'     - `icicle-candidate-set-save-more': add to saved set</span>
<span class="linecomment">;;    `C-)'     - `icicle-candidate-set-save-more-selected': selected</span>
<span class="linecomment">;;    `insert'  - `icicle-save/unsave-candidate': save current cand</span>
<span class="linecomment">;;    `C-%'     - `icicle-candidate-set-swap': swap saved and current</span>
<span class="linecomment">;;    `C-:'     - `icicle-candidate-set-define': define current (Lisp)</span>
<span class="linecomment">;;    `M-S-mouse-2' - `icicle-mouse-save/unsave-candidate': (un)save</span>
<span class="linecomment">;;    `M-S-mouse-3' - `icicle-mouse-candidate-set-save': save selected</span>
<span class="linecomment">;;    `M-mouse-3'   - `icicle-mouse-candidate-set-save-more'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings insert text in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-.'     - `icicle-insert-string-at-point'</span>
<span class="linecomment">;;    `C-='     - `icicle-insert-string-from-variable'</span>
<span class="linecomment">;;    `M-:'     - `icicle-pp-eval-expression-in-minibuffer'</span>
<span class="linecomment">;;                (with a prefix arg)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings let you toggle Icicles options</span>
<span class="linecomment">;;  or cycle among alternative Icicles behaviors.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-A' (that is, `C-S-a') - `icicle-toggle-case-sensitivity'</span>
<span class="linecomment">;;    `C-.'     - `icicle-toggle-ignored-extensions' (file completion)</span>
<span class="linecomment">;;    `C-.'     - `icicle-toggle-search-cleanup' (search)</span>
<span class="linecomment">;;    `C-M-.'   - `icicle-toggle-hiding-common-match'</span>
<span class="linecomment">;;    `C-;'     - `icicle-toggle-expand-to-common-match'</span>
<span class="linecomment">;;    `C-,'     - `icicle-change-sort-order'</span>
<span class="linecomment">;;    `C-,'     - `icicle-toggle-search-replace-whole' (search)</span>
<span class="linecomment">;;    `M-,'     - `icicle-change-alternative-sort-order'</span>
<span class="linecomment">;;    `C-M-,'   - `icicle-toggle-alternative-sorting'</span>
<span class="linecomment">;;    `C-^'     - `icicle-toggle-remote-file-testing'</span>
<span class="linecomment">;;    `C-^'     - `icicle-toggle-highlight-all-current' (search)</span>
<span class="linecomment">;;    `C-#'     - `icicle-toggle-incremental-completion'</span>
<span class="linecomment">;;    `C-('     - `icicle-toggle-fuzzy-completion'</span>
<span class="linecomment">;;    `C-`'     - `icicle-toggle-regexp-quote'</span>
<span class="linecomment">;;    `C-M-`'   - `icicle-toggle-literal-replacement' (search)</span>
<span class="linecomment">;;    `C-$'     - `icicle-toggle-transforming' (removal of duplicates)</span>
<span class="linecomment">;;    `C-pause' - `icicle-toggle-highlight-historical-candidates'</span>
<span class="linecomment">;;    `M-g'     - `icicle-toggle-C-for-actions'</span>
<span class="linecomment">;;    `M-q'     - `icicle-toggle-search-whole-word' (search)</span>
<span class="linecomment">;;    `M-('     - `icicle-next-apropos-match-function'</span>
<span class="linecomment">;;    `M-~'     - `icicle-toggle-~-for-home-dir'</span>
<span class="linecomment">;;    `M-_'     - `icicle-toggle-ignored-space-prefix'</span>
<span class="linecomment">;;    `C-M-_'   - `icicle-toggle-proxy-candidates'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings let you incrementally change</span>
<span class="linecomment">;;  options that affect the `*Completions*' display columns.  To take</span>
<span class="linecomment">;;  advantage of these, you must also use Do Re Mi (library</span>
<span class="linecomment">;;  `doremi.el').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-x w'   - `icicle-doremi-candidate-width-factor'</span>
<span class="linecomment">;;    `C-x |'   - `icicle-doremi-inter-candidates-min-spaces'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When used in the minibuffer, the following Icicles global binding</span>
<span class="linecomment">;;  lets you remove the `*Completions*' window.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-x 0'   - `icicle-delete-window'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings are in effect during Icicles</span>
<span class="linecomment">;;  search:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-.'     - `icicle-toggle-search-cleanup'</span>
<span class="linecomment">;;    `C-,'     - `icicle-toggle-search-replace-whole'</span>
<span class="linecomment">;;    `M-,'     - `icicle-search-define-replacement'</span>
<span class="linecomment">;;    `M-q'     - `icicle-toggle-search-whole-word'</span>
<span class="linecomment">;;    `C-^'     - `icicle-toggle-highlight-all-current'</span>
<span class="linecomment">;;    `C-M-`'   - `icicle-toggle-literal-replacement'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer binding lets you evaluate an Emacs-Lisp</span>
<span class="linecomment">;;  sexp at any time, using a recursive minibuffer.  It displays the</span>
<span class="linecomment">;;  result of evaluation in the echo area or in a pop-up buffer, `*Pp</span>
<span class="linecomment">;;  Eval Output*'.  With a prefix arg (`C-u M-:'), it inserts the</span>
<span class="linecomment">;;  result into the minibuffer at point.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-:'     - `icicle-pp-eval-expression-in-minibuffer'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following bindings are made for `completion-list-mode', that</span>
<span class="linecomment">;;  is, for buffer `*Completions*', which shows the list of candidate</span>
<span class="linecomment">;;  completions:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `left', `right' (`TAB')</span>
<span class="linecomment">;;                    - `icicle-move-to-previous-completion',</span>
<span class="linecomment">;;                      `icicle-move-to-next-completion': Navigate</span>
<span class="linecomment">;;                      backward & forward among candidates</span>
<span class="linecomment">;;    `up', `down'    - `icicle-previous-line', `icicle-next-line':</span>
<span class="linecomment">;;                      Navigate up & down among candidates (The</span>
<span class="linecomment">;;                      documentation refers to these keys as `up' and</span>
<span class="linecomment">;;                      `down'.  Actually, these are the keys only by</span>
<span class="linecomment">;;                      default.  You can customize them using options</span>
<span class="linecomment">;;                      `icicle-prefix-cycle-next-keys' and</span>
<span class="linecomment">;;                      `icicle-prefix-cycle-previous-keys'.)</span>
<span class="linecomment">;;    `C-insert'      - `icicle-insert-completion': Move cursor to the</span>
<span class="linecomment">;;                      minibuffer, with the current `*Completions*'</span>
<span class="linecomment">;;                      candidate as input</span>
<span class="linecomment">;;    `C-a', `C-e'    - `icicle-beginning-of-line+',</span>
<span class="linecomment">;;                      `icicle-end-of-line+' (repeatable)</span>
<span class="linecomment">;;    `C-g', `q'      - `icicle-abort-recursive-edit'</span>
<span class="linecomment">;;    `mouse-2'       - `icicle-mouse-choose-completion'</span>
<span class="linecomment">;;    `C-mouse-2'     - `icicle-mouse-candidate-action'</span>
<span class="linecomment">;;    `M-mouse-2'     - `icicle-mouse-candidate-read-fn-invoke'</span>
<span class="linecomment">;;    `C-M-mouse-2'   - `icicle-mouse-help-on-candidate'</span>
<span class="linecomment">;;    `M-S-mouse-2'   - `icicle-mouse-save/unsave-candidate'</span>
<span class="linecomment">;;    `C-mouse-3'     - `icicle-Completions-mouse-3-menu'</span>
<span class="linecomment">;;    `M-mouse-3'     - `icicle-mouse-candidate-set-save-more'</span>
<span class="linecomment">;;    `M-S-mouse-3'   - `icicle-mouse-candidate-set-save'</span>
 
<span class="linecomment">;;(@* "Customizing Key Bindings")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Customizing Key Bindings</span>
<span class="linecomment">;;  ------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Key Bindings") for a description of the key bindings</span>
<span class="linecomment">;;  defined by Icicles.  The options mentioned here are also presented</span>
<span class="linecomment">;;  there, in context.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Key bindings are very personal choices, and reflect preferences</span>
<span class="linecomment">;;  and habits, as well as keyboard and other configurations.  You</span>
<span class="linecomment">;;  might want to change some of the bindings that Icicles creates.</span>
<span class="linecomment">;;  This section tells you how to do that.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, before doing so, unless the default bindings present a</span>
<span class="linecomment">;;  hardware or OS configuration problem for you, please try using the</span>
<span class="linecomment">;;  default bindings for a while, before deciding that you want to</span>
<span class="linecomment">;;  change them.  Habit is a powerful persuader, but its advice is not</span>
<span class="linecomment">;;  always the best ;-).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The main user option for customizing key bindings is</span>
<span class="linecomment">;;  `icicle-top-level-key-bindings'.  You use it to change or remove</span>
<span class="linecomment">;;  any of the top-level bindings in Icicle mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are some other user options that make it easy to customize</span>
<span class="linecomment">;;  some Icicles key bindings.  Most of these are minibuffer key</span>
<span class="linecomment">;;  bindings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-apropos-cycle-previous-keys'               (`prior')</span>
<span class="linecomment">;;    Cycle to the previous apropos-completion candidate.</span>
<span class="linecomment">;;  * `icicle-apropos-cycle-next-keys'                   (`next')</span>
<span class="linecomment">;;    Cycle to the next apropos-completion candidate.</span>
<span class="linecomment">;;  * `icicle-prefix-cycle-previous-keys'                (`up')</span>
<span class="linecomment">;;    Cycle to the previous prefix-completion candidate.</span>
<span class="linecomment">;;  * `icicle-prefix-cycle-next-keys'                    (`down')</span>
<span class="linecomment">;;    Cycle to the next prefix-completion candidate.</span>
<span class="linecomment">;;  * `icicle-modal-cycle-up-keys'                       (`up')</span>
<span class="linecomment">;;    Cycle to the previous candidate (modal).</span>
<span class="linecomment">;;  * `icicle-modal-cycle-down-keys'                     (`down')</span>
<span class="linecomment">;;    Cycle to the next candidate (modal).</span>
<span class="linecomment">;;  * `icicle-apropos-cycle-previous-keys'               (`C-prior')</span>
<span class="linecomment">;;    Cycle to previous apropos-completion candidate and act on it.</span>
<span class="linecomment">;;  * `icicle-apropos-cycle-next-keys'                   (`C-next')</span>
<span class="linecomment">;;    Cycle to next apropos-completion candidate and act on it.</span>
<span class="linecomment">;;  * `icicle-prefix-cycle-previous-keys'                (`C-up')</span>
<span class="linecomment">;;    Cycle to previous prefix-completion candidate and act on it.</span>
<span class="linecomment">;;  * `icicle-prefix-cycle-next-keys'                    (`C-down')</span>
<span class="linecomment">;;    Cycle to next prefix-completion candidate and act on it.</span>
<span class="linecomment">;;  * `icicle-modal-cycle-up-keys'                       (`C-up')</span>
<span class="linecomment">;;    Cycle to previous candidate and act on it (modal).</span>
<span class="linecomment">;;  * `icicle-modal-cycle-down-keys'                     (`C-down')</span>
<span class="linecomment">;;    Cycle to next candidate and act on it (modal).</span>
<span class="linecomment">;;  * `icicle-prefix-complete-keys'                      (`TAB')</span>
<span class="linecomment">;;    Prefix-complete your input.</span>
<span class="linecomment">;;  * `icicle-apropos-complete-keys'                     (`S-TAB')</span>
<span class="linecomment">;;    Apropos-complete your input.</span>
<span class="linecomment">;;  * `icicle-prefix-complete-no-display-keys'           (`C-M-TAB')</span>
<span class="linecomment">;;    Prefix-complete without showing `*Completions*'.</span>
<span class="linecomment">;;  * `icicle-apropos-complete-no-display-keys'          (`C-M-S-TAB')</span>
<span class="linecomment">;;    Apropos-complete without showing `*Completions*'.</span>
<span class="linecomment">;;  * `icicle-word-completion-keys'                      (`M-SPC')</span>
<span class="linecomment">;;    Prefix-complete your input a word at a time.</span>
<span class="linecomment">;;  * `icicle-key-complete-keys'                         (`S-TAB')</span>
<span class="linecomment">;;    Complete key sequences.</span>
<span class="linecomment">;;  * `icicle-previous-candidate-keys'                   (`S-TAB')</span>
<span class="linecomment">;;    Move to the previous candidate in `*Completions*'.</span>
<span class="linecomment">;;  * `icicle-search-from-isearch-keys'                  (`S-TAB')</span>
<span class="linecomment">;;    Start `icicle-search' from Isearch.</span>
<span class="linecomment">;;  * `icicle-isearch-complete-keys'                  (`M-TAB', `M-o')</span>
<span class="linecomment">;;    Complete incremental search string using search ring.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These are the main kinds of Icicles key bindings:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Global bindings</span>
<span class="linecomment">;;    . Additions to menu-bar menus</span>
<span class="linecomment">;;    . Key completion keys (`S-TAB' by default)</span>
<span class="linecomment">;;  * Icicle mode bindings</span>
<span class="linecomment">;;  * Minibuffer bindings</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Customizing Global Bindings")</span>
<span class="linecomment">;;  ** Customizing Global Bindings **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles normally adds items to appropriate existing menu-bar</span>
<span class="linecomment">;;  menus, such as File and Options, as well as to menu-bar menus</span>
<span class="linecomment">;;  Minibuf and Icicles.  These items are placed in an Icicles submenu</span>
<span class="linecomment">;;  (e.g. Files &gt; Icicles).  If you do not want to add an Icicles</span>
<span class="linecomment">;;  submenu, then set option `icicle-touche-pas-aux-menus-flag' to</span>
<span class="linecomment">;;  non-nil before loading Icicles.  The menu items are then added to</span>
<span class="linecomment">;;  the Icicles menu.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles binds key completion (`icicle-complete-keys') to the keys</span>
<span class="linecomment">;;  defined in option `icicle-key-complete-keys'.  See</span>
<span class="linecomment">;;  (@&gt; "Key Bindings") for more information about this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Customizing Icicle Mode Bindings")</span>
<span class="linecomment">;;  ** Customizing Icicle Mode Bindings **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In the Icicle mode keymap, several top-level commands are bound by</span>
<span class="linecomment">;;  default.  You can use option `icicle-top-level-key-bindings' to</span>
<span class="linecomment">;;  customize the keys that are used for these commands, or to remove</span>
<span class="linecomment">;;  any such bindings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Customizing Minibuffer Bindings")</span>
<span class="linecomment">;;  ** Customizing Minibuffer Bindings **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are user options for most Icicles minibuffer bindings that</span>
<span class="linecomment">;;  you might want to change - see above for the list.  This section</span>
<span class="linecomment">;;  tells you how to change additional bindings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To understand how you can modify Icicles minibuffer bindings, it</span>
<span class="linecomment">;;  helps to know how Icicles creates the default bindings.  For that,</span>
<span class="linecomment">;;  the best advice is to consult the Emacs-Lisp code in library</span>
<span class="linecomment">;;  `icicle-mode.el'.  Even if you are not very familiar with</span>
<span class="linecomment">;;  Emacs-Lisp, however, you should be able to do what you want by</span>
<span class="linecomment">;;  adapting the example in this section.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Suppose that you want to bind `f11' and `f12' to traverse the</span>
<span class="linecomment">;;  input history up and down whenever you are in Icicle mode.  There</span>
<span class="linecomment">;;  are no user options for this, but you can do it by inserting this</span>
<span class="linecomment">;;  code into your init file (~/.emacs), before the code that requires</span>
<span class="linecomment">;;  (loads) library `icicles.el':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (add-hook 'icicle-mode-hook 'bind-my-icicles-keys)</span>
<span class="linecomment">;;  (defun bind-my-icicles-keys ()</span>
<span class="linecomment">;;    "Replace some default Icicles minibuffer bindings with others."</span>
<span class="linecomment">;;    (dolist</span>
<span class="linecomment">;;        (map</span>
<span class="linecomment">;;          (append</span>
<span class="linecomment">;;           (list minibuffer-local-completion-map</span>
<span class="linecomment">;;                 minibuffer-local-must-match-map)</span>
<span class="linecomment">;;           (and (fboundp</span>
<span class="linecomment">;;                 'minibuffer-local-filename-completion-map)</span>
<span class="linecomment">;;                (list minibuffer-local-filename-completion-map))))</span>
<span class="linecomment">;;      (when icicle-mode</span>
<span class="linecomment">;;        (define-key map [f11] 'previous-history-element)</span>
<span class="linecomment">;;        (define-key map [f12] 'next-history-element))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Key Bindings")</span>
<span class="linecomment">;;  * (@&gt; "Customization and General Tips") for information</span>
<span class="linecomment">;;    about other customizations, besides key bindings.</span>
 
<span class="linecomment">;;(@* "Icicles Redefines Some Standard Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Redefines Some Standard Commands</span>
<span class="linecomment">;;  ----------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If user option `icicle-redefine-standard-commands-flag' is</span>
<span class="linecomment">;;  non-nil, then Icicles automatically redefines a few standard Emacs</span>
<span class="linecomment">;;  commands when you are in Icicle mode, enhancing them for Icicles</span>
<span class="linecomment">;;  completion:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `bbdb-complete-name' (from BBDB), `customize-apropos',</span>
<span class="linecomment">;;    `customize-apropos-faces', `customize-apropos-groups',</span>
<span class="linecomment">;;    `customize-apropos-options', `customize-face',</span>
<span class="linecomment">;;    `customize-face-other-window', `dabbrev-completion',</span>
<span class="linecomment">;;    `lisp-complete-symbol', `repeat-complex-command',</span>
<span class="linecomment">;;    `switch-to-completions'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles automatically redefines these standard Emacs commands for</span>
<span class="linecomment">;;  use in the minibuffer or *Completions*:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `choose-completion', `exit-minibuffer',</span>
<span class="linecomment">;;    `minibuffer-complete-and-exit', `mouse-choose-completion',</span>
<span class="linecomment">;;    `next-history-element'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you exit Icicle mode, the standard definitions are restored.</span>
 
<span class="linecomment">;;(@* "Programming with Fancy Candidates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Programming with Fancy Candidates</span>
<span class="linecomment">;;  ---------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles lets you program with several kinds of candidates that are</span>
<span class="linecomment">;;  not supported by vanilla Emacs.  For lack of a better word, I call</span>
<span class="linecomment">;;  them all "fancy candidates".  Multi-completions are fancy</span>
<span class="linecomment">;;  candidates.  So are ordinary string candidates that have text</span>
<span class="linecomment">;;  properties such as `face'.  And there are other kinds of fancy</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because they are not supported by vanilla Emacs, and because</span>
<span class="linecomment">;;  Icicles uses Emacs functions such as `all-completions' to perform</span>
<span class="linecomment">;;  the primitive completion operations, fancy candidates require some</span>
<span class="linecomment">;;  extra processing.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  All fancy candidates must first be converted to a form that such</span>
<span class="linecomment">;;  primitives can understand.  During completion, fancy candidates</span>
<span class="linecomment">;;  must sometimes be displayed specially, for example using</span>
<span class="linecomment">;;  particular faces.  And after completion, the completion result</span>
<span class="linecomment">;;  must sometimes be converted back again to retrieve some or all of</span>
<span class="linecomment">;;  the original candidate information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This conversion (encoding and decoding) can be costly, especially</span>
<span class="linecomment">;;  when there are many candidates.  For this reason, it is turned</span>
<span class="linecomment">;;  off, by default, so it that doesn't represent overhead during</span>
<span class="linecomment">;;  completion of non-fancy candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In order to use `completing-read' with fancy candidates, you must</span>
<span class="linecomment">;;  do one of the following in your code:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Propertize at least the first character of the</span>
<span class="linecomment">;;     `completing-read' PROMPT argument string with a non-nil text</span>
<span class="linecomment">;;     property `icicle-fancy-candidates'.  This turns on processing</span>
<span class="linecomment">;;     of fancy candidates for the duration of the `completing-read'</span>
<span class="linecomment">;;     call.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Bind variable `icicle-fancy-candidates-p' to non-nil.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Bind variable `icicle-whole-candidate-as-text-prop-p' to</span>
<span class="linecomment">;;     non-nil.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You use method 1 or 2 to handle multi-completion candidates or</span>
<span class="linecomment">;;  candidates that have text properties or are otherwise to be</span>
<span class="linecomment">;;  displayed specially.  I recommend that you generally use text</span>
<span class="linecomment">;;  property `icicle-fancy-candidates', not variable</span>
<span class="linecomment">;;  `icicle-fancy-candidates-p'.  The variable is provided so that you</span>
<span class="linecomment">;;  can widen the scope of this feature beyond a given call to</span>
<span class="linecomment">;;  `completing-read'.  You will need to do that only rarely.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A use case for variable `icicle-fancy-candidates-p' would be, for</span>
<span class="linecomment">;;  instance, if your code calls other code that calls</span>
<span class="linecomment">;;  `completing-read', so you have no direct access to the</span>
<span class="linecomment">;;  `completing-read' PROMPT argument in order to propertize it.  If</span>
<span class="linecomment">;;  you nevertheless want to use some fancy candidates, then you can</span>
<span class="linecomment">;;  bind `icicle-fancy-candidates-p' with the scope you want.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You use method 3, `icicle-whole-candidate-as-text-prop-p', when</span>
<span class="linecomment">;;  you need to save and later retrieve all of the information</span>
<span class="linecomment">;;  contained in an alist COLLECTION entry.  Completion returns only a</span>
<span class="linecomment">;;  string.  If the COLLECTION alist has only one entry with a given</span>
<span class="linecomment">;;  string as its car, then you can simply use `assoc' to retrieve the</span>
<span class="linecomment">;;  whole entry.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But if you use an alist that allows entries with different cdrs</span>
<span class="linecomment">;;  for the same car, then you need some way to encode an entire alist</span>
<span class="linecomment">;;  entry in a display string.  When you have this need, set variable</span>
<span class="linecomment">;;  `icicle-candidates-alist' to the alist, and bind</span>
<span class="linecomment">;;  `icicle-whole-candidate-as-text-prop-p' to non-nil.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This has the effect of encoding, as a text property on the</span>
<span class="linecomment">;;  candidate display string, the entire corresponding original alist</span>
<span class="linecomment">;;  entry.  You can then use `icicle-get-alist-candidate' to recover</span>
<span class="linecomment">;;  that information.</span>
 
<span class="linecomment">;;(@* "Programming Multi-Completions")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Programming Multi-Completions</span>
<span class="linecomment">;;  -----------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Multi-completions are completion candidates that are composed of</span>
<span class="linecomment">;;  parts separated by `icicle-list-join-string' and terminated by</span>
<span class="linecomment">;;  `icicle-list-end-string'.  See (@&gt; "Multi-Completions") for</span>
<span class="linecomment">;;  information about how users interact with multi-completions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Multi-completions are examples of fancy candidates.</span>
<span class="linecomment">;;  See (@&gt; "Programming with Fancy Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can define your own Icicles commands that use</span>
<span class="linecomment">;;  multi-completions.  You can bind `icicle-list-join-string' or</span>
<span class="linecomment">;;  `icicle-list-end-string' to any strings you like, depending on</span>
<span class="linecomment">;;  your needs.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Key Completion") for an</span>
<span class="linecomment">;;  example where `icicle-list-join-string' is bound to "  =  " and</span>
<span class="linecomment">;;  `icicle-list-end-string' is "".  This section describes two</span>
<span class="linecomment">;;  additional variables that you can bind to affect the appearance</span>
<span class="linecomment">;;  and behavior of multi-completions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Variable icicle-list-use-nth-parts")</span>
<span class="linecomment">;;  ** Variable icicle-list-use-nth-parts **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Variable `icicle-list-use-nth-parts' affects the minibuffer</span>
<span class="linecomment">;;  behavior of multi-completions.  If you bind this to a list of</span>
<span class="linecomment">;;  whole numbers, then multi-completion candidates are transformed</span>
<span class="linecomment">;;  using those numbers as indexes.  During completion and cycling,</span>
<span class="linecomment">;;  whenever a sole candidate matches the user input, if that</span>
<span class="linecomment">;;  candidate is a multi-completion, then it is transformed by</span>
<span class="linecomment">;;  extracting and possibly reordering its parts according to</span>
<span class="linecomment">;;  `icicle-list-use-nth-parts'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The actual candidate to match is still the original candidate; the</span>
<span class="linecomment">;;  transformation takes place after matching, for final insertion in</span>
<span class="linecomment">;;  the minibuffer.  This means that you must use this feature only</span>
<span class="linecomment">;;  with lax (permissive) completion, since strict completion requires</span>
<span class="linecomment">;;  an exact match against the original completion candidate, and the</span>
<span class="linecomment">;;  transformed candidate will normally not match the original.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Variable `icicle-list-use-nth-parts' works as follows.  The</span>
<span class="linecomment">;;  matching candidate is split at each `icicle-list-join-string' into</span>
<span class="linecomment">;;  its component parts.  The indexes in `icicle-list-use-nth-parts'</span>
<span class="linecomment">;;  are then used to extract parts, in the same order as the indexes</span>
<span class="linecomment">;;  appear.  The extracted parts are joined back together in an order</span>
<span class="linecomment">;;  that you specify, separated by the value of user option</span>
<span class="linecomment">;;  `icicle-list-nth-parts-join-string'.  An index greater than the</span>
<span class="linecomment">;;  number of parts means to use the last part.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example: If the value of `icicle-list-use-nth-parts' is (1),</span>
<span class="linecomment">;;  then only the first part of the multi-completion is used as the</span>
<span class="linecomment">;;  completion candidate.  If the value is (2 1), then the resulting</span>
<span class="linecomment">;;  candidate is the second part followed by the first part, the two</span>
<span class="linecomment">;;  parts being joined by `icicle-list-nth-parts-join-string'.  If the</span>
<span class="linecomment">;;  value is (1 99) and the multi-completion has fewer than 99 parts,</span>
<span class="linecomment">;;  then the first and last parts are used.  If the value is (2 1 2),</span>
<span class="linecomment">;;  then the resulting candidate is composed of the second part</span>
<span class="linecomment">;;  followed by the first part followed by the second part again.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Thus, you can use a given part any number of times.  You can also</span>
<span class="linecomment">;;  mix multi-completions and single-string completions, and you can</span>
<span class="linecomment">;;  mix multi-completions composed of different numbers of strings.</span>
<span class="linecomment">;;  For example, a set of completions might be:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  ((("cmd1" "description of cmd1"))</span>
<span class="linecomment">;;   (("cmd2" "description of cmd" "more"))</span>
<span class="linecomment">;;   (("cmd3")))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use multi-completions with `icicle-list-use-nth-parts' in</span>
<span class="linecomment">;;  your own commands, please make sure that their doc strings let</span>
<span class="linecomment">;;  users know what to expect, and remind them of the behavior of</span>
<span class="linecomment">;;  option `icicle-list-nth-parts-join-string'.  Let them know, in</span>
<span class="linecomment">;;  particular, that:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * They can match any part of a candidate as it is displayed in</span>
<span class="linecomment">;;    buffer `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The candidate choice they make will in fact have the form that</span>
<span class="linecomment">;;    you define in your command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * They can control how the parts are joined, using option</span>
<span class="linecomment">;;    `icicle-list-nth-parts-join-string'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Variable icicle-candidate-properties-alist")</span>
<span class="linecomment">;;  ** Variable icicle-candidate-properties-alist **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whereas variable `icicle-list-nth-parts-join-string' affects the</span>
<span class="linecomment">;;  appearance of multi-completions in the minibuffer, variable</span>
<span class="linecomment">;;  `icicle-candidate-properties-alist' affects their appearance in</span>
<span class="linecomment">;;  buffer `*Completions*'.  You use it to apply text properties to</span>
<span class="linecomment">;;  individual parts of a multi-completion, where the parts are</span>
<span class="linecomment">;;  defined in the same way as for `icicle-list-use-nth-parts'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This feature affects all candidates the same way.  See also</span>
<span class="linecomment">;;  (@&gt; "Candidates with Text Properties") for ways to apply text</span>
<span class="linecomment">;;  properties to individual candidates (which need not be</span>
<span class="linecomment">;;  multi-completions).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The value of `icicle-candidate-properties-alist' is an alist whose</span>
<span class="linecomment">;;  entries have either of these forms:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (NTH PROPERTIES) or (NTH PROPERTIES JOIN-TOO)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  NTH is the number of the target multi-completion part.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  PROPERTIES is a list of text properties to apply to the NTH part.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  JOIN-TOO is optional.  If it is present and non-nil, then the text</span>
<span class="linecomment">;;  properties are also applied to the join string that follows the</span>
<span class="linecomment">;;  target part.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use any text properties, including `invisible', `keymap',</span>
<span class="linecomment">;;  `display', and properties that you define yourself and that have</span>
<span class="linecomment">;;  meaning to only your code.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an example of its use, commands `icicle-fundoc',</span>
<span class="linecomment">;;  `icicle-vardoc', `icicle-doc', and `icicle-plist' bind</span>
<span class="linecomment">;;  `icicle-candidate-properties-alist' to</span>
<span class="linecomment">;;  ((1 (face 'icicle-candidate-part))), so that the first part of</span>
<span class="linecomment">;;  each multi-completion candidate is highlighted using face</span>
<span class="linecomment">;;  `icicle-candidate-part'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here is another example value of</span>
<span class="linecomment">;;  `icicle-candidate-properties-alist':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  ((3 (face 'underline))</span>
<span class="linecomment">;;   (2 (invisible t) t))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The first entry underlines the third multi-completion part.  The</span>
<span class="linecomment">;;  second entry makes both the second part and the join string that</span>
<span class="linecomment">;;  follows it invisible.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One use of making a completion part invisible is so that you can</span>
<span class="linecomment">;;  sort candidates using it, and let users match input against it,</span>
<span class="linecomment">;;  but not have it appear explicitly.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Recall that `completing-read' displays only the car of each</span>
<span class="linecomment">;;  element present in its COLLECTION (alist) argument.  For example,</span>
<span class="linecomment">;;  if you pass `completing-read' an alist such as (("foo" . 2) ("bar"</span>
<span class="linecomment">;;  . 3)), then only `foo' and `bar' are displayed as candidates.</span>
<span class="linecomment">;;  However, the PREDICATE argument to `completing-read' applies to</span>
<span class="linecomment">;;  the entire alist element, and your command that calls</span>
<span class="linecomment">;;  `completing-read' might well use the chosen candidate (e.g. `foo')</span>
<span class="linecomment">;;  to look up the entire element (e.g. ("foo" . 2)) for further</span>
<span class="linecomment">;;  processing.  Several Icicles commands, including `icicle-search'</span>
<span class="linecomment">;;  and `icicle-select-region', do that.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, sometimes you might want the user to be able to match</span>
<span class="linecomment">;;  against the additional information (e.g. 2 and 3), and you might</span>
<span class="linecomment">;;  want to use it to sort candidates.  In that case, you can use the</span>
<span class="linecomment">;;  alist (("foo 2") ("bar 3")).  In cases where the additional</span>
<span class="linecomment">;;  information can be distracting, you can use multi-completion with</span>
<span class="linecomment">;;  `icicle-candidate-properties-alist' to hide it: Pass the alist</span>
<span class="linecomment">;;  ((("foo "2")) (("bar" 3"))) and use ((2 (invisible t))) for</span>
<span class="linecomment">;;  `icicle-candidate-properties-alist'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Keep in mind that hiding completion parts can be confusing to</span>
<span class="linecomment">;;  users.  Do so with care, and let your users know what to expect.</span>
<span class="linecomment">;;  Inform them that there are invisible parts that are nevertheless</span>
<span class="linecomment">;;  taken into account for input matching and candidate sorting.  When</span>
<span class="linecomment">;;  you hide parts, you will often want to omit them from the</span>
<span class="linecomment">;;  minibuffer as well, using `icicle-list-use-nth-parts', to avoid</span>
<span class="linecomment">;;  confusion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Consider also the position of a hidden part: In some cases you</span>
<span class="linecomment">;;  might want to place it first among the multi-completion parts, but</span>
<span class="linecomment">;;  in many cases you will want to place it last, to minimize</span>
<span class="linecomment">;;  interference with prefix-completion matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Similar considerations apply to other text properties, such as</span>
<span class="linecomment">;;  `display' and `keymap', that change the appearance or behavior of</span>
<span class="linecomment">;;  a completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "What You See Is Not What You Get")</span>
<span class="linecomment">;;  ** What You See Is Not What You Get **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  While on the subject of confusing users, let me point out a</span>
<span class="linecomment">;;  general drawback that is common to both</span>
<span class="linecomment">;;  `icicle-list-use-nth-parts' and</span>
<span class="linecomment">;;  `icicle-candidate-properties-alist': *not* WYSIWYG.  Keep this in</span>
<span class="linecomment">;;  mind if you decide to take advantage of these variables.  Users</span>
<span class="linecomment">;;  see one thing, choose it, and they get something different as a</span>
<span class="linecomment">;;  result.  That promotes confusion that you will need to weigh</span>
<span class="linecomment">;;  against the possible benefits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Users are confused, because what they choose is not exactly what</span>
<span class="linecomment">;;  they get.  What's more, a user's completion choice is not</span>
<span class="linecomment">;;  reflected in the input history, leading to further confusion.  For</span>
<span class="linecomment">;;  example, Icicles highlighting of previously used inputs in buffer</span>
<span class="linecomment">;;  `*Completions*' does not apply to such a candidate, even though it</span>
<span class="linecomment">;;  was previously entered using `RET'.  It is the transformed</span>
<span class="linecomment">;;  candidate that was entered, not the candidate as it was proposed</span>
<span class="linecomment">;;  for choosing, so when that candidate is proposed again, it is not</span>
<span class="linecomment">;;  recognized as having been previously chosen.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The bottom line here is this: variables</span>
<span class="linecomment">;;  `icicle-list-use-nth-parts' and</span>
<span class="linecomment">;;  `icicle-candidate-properties-alist' are useful in certain</span>
<span class="linecomment">;;  contexts, but be aware of the downside: confusing your users.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Multi-Completions")</span>
<span class="linecomment">;;  * (@&gt; "Programming with Fancy Candidates")</span>
<span class="linecomment">;;  * (@&gt; "Candidates with Text Properties")</span>
 
<span class="linecomment">;;(@* "Candidates with Text Properties")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Candidates with Text Properties</span>
<span class="linecomment">;;  -------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Section (@&gt; "Programming Multi-Completions") explains how to apply</span>
<span class="linecomment">;;  text properties to specific parts of all multi-completion</span>
<span class="linecomment">;;  candidates in buffer `*Completions*' at the same time.  This</span>
<span class="linecomment">;;  section tells you how to apply text properties to specific</span>
<span class="linecomment">;;  candidates in `*Completions*'.  The candidates need not be</span>
<span class="linecomment">;;  multi-completions, but in some cases they can be.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you use candidates with text properties such as `face' that</span>
<span class="linecomment">;;  are visible, the display candidates in `*Completions*' show those</span>
<span class="linecomment">;;  properties.  In addition, the candidate string that the user</span>
<span class="linecomment">;;  finally chooses can also be propertized.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are four different methods for providing candidates with</span>
<span class="linecomment">;;  text properties, in addition to the way presented in section</span>
<span class="linecomment">;;  (@&gt; "Programming Multi-Completions"):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Apply face `icicle-special-candidate' to all candidates that</span>
<span class="linecomment">;;     match a given regexp.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Use a set of text properties as the `icicle-special-candidate'</span>
<span class="linecomment">;;     property of the symbol that represents the candidate.  The text</span>
<span class="linecomment">;;     properties are transferred to the string candidate that is</span>
<span class="linecomment">;;     displayed (and returned).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Use a propertized string as the `icicle-display-string'</span>
<span class="linecomment">;;     property of the symbol that represents the candidate.  That</span>
<span class="linecomment">;;     string replaces the candidate that would otherwise have been</span>
<span class="linecomment">;;     displayed, completed against, and returned.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. Start with a propertized string in the COLLECTION argument</span>
<span class="linecomment">;;     you pass to `completing-read'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  All four methods use fancy candidates, in the sense that they go</span>
<span class="linecomment">;;  beyond what vanilla Emacs offers.  For methods 1-3, you must turn</span>
<span class="linecomment">;;  on fancy-candidate handling.  See</span>
<span class="linecomment">;;  (@&gt; "Programming with Fancy Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But method 4 does not require any costly fancy-candidate encoding</span>
<span class="linecomment">;;  or decoding, because the Icicles implementation of</span>
<span class="linecomment">;;  `completing-read' handles propertized string candidates, and they</span>
<span class="linecomment">;;  are transparent to the Emacs primitive completion operations.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following sections explain methods 1-4 individually.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using Regexp `icicle-special-candidate-regexp'")</span>
<span class="linecomment">;;  ** Using Regexp `icicle-special-candidate-regexp' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you just want several candidates to have face</span>
<span class="linecomment">;;  `icicle-special-candidate' in `*Completions', you can simply</span>
<span class="linecomment">;;  define (e.g. bind) option `icicle-special-candidate-regexp' to a</span>
<span class="linecomment">;;  regexp that matches those candidates.  The original candidates can</span>
<span class="linecomment">;;  be strings or symbols.  Unlike the other methods described here,</span>
<span class="linecomment">;;  this one affects only the display in `*Completions'; the</span>
<span class="linecomment">;;  completion return string does not have face</span>
<span class="linecomment">;;  `icicle-special-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The highlighting applies only to the part of a candidate that</span>
<span class="linecomment">;;  matches the regexp.  This selectivity is particularly useful when</span>
<span class="linecomment">;;  dealing with multi-completions.  Function `icicle-read-file-name'</span>
<span class="linecomment">;;  provides an example: file names that match ".+/$", that is,</span>
<span class="linecomment">;;  directory names, are highlighted as special candidates.  Function</span>
<span class="linecomment">;;  `icicle-read-color' provides another example (using the similar,</span>
<span class="linecomment">;;  but internal, variable `icicle-proxy-candidate-regexp'): proxy</span>
<span class="linecomment">;;  color-name candidates such as `*point foreground*' and</span>
<span class="linecomment">;;  `'icicle-region-background'' are highlighted, but not their color</span>
<span class="linecomment">;;  swatches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using Property icicle-special-candidate")</span>
<span class="linecomment">;;  ** Using Property icicle-special-candidate **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In this approach, you use the desired list of text properties as</span>
<span class="linecomment">;;  the value of property `icicle-special-candidate' for the symbol</span>
<span class="linecomment">;;  that represents the candidate.  This method affects the candidates</span>
<span class="linecomment">;;  that are used during completion, as well as the completion return</span>
<span class="linecomment">;;  value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If the candidate is a string, not a symbol, then `intern' it and</span>
<span class="linecomment">;;  put the property on the resulting symbol.  If you want the effect</span>
<span class="linecomment">;;  to be temporary, then set property `icicle-special-candidate' for</span>
<span class="linecomment">;;  the candidate to nil when completion is finished.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a shortcut, if you use the value t instead of a property list</span>
<span class="linecomment">;;  for property `icicle-special-candidate', then face</span>
<span class="linecomment">;;  `icicle-special-candidate' will be used as the `face' property of</span>
<span class="linecomment">;;  the candidate.  Using a value of t is thus equivalent to using a</span>
<span class="linecomment">;;  value of (face icicle-special-candidate).  This approach is used,</span>
<span class="linecomment">;;  for instance, in the definition of command `icicle-complete-keys'</span>
<span class="linecomment">;;  (`S-TAB').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using Property `icicle-display-string'")</span>
<span class="linecomment">;;  ** Using Property `icicle-display-string' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This method is similar to that of using property</span>
<span class="linecomment">;;  `icicle-special-candidate'.  The use case for both is</span>
<span class="linecomment">;;  propertizing, in a general way, candidates that are symbols.  Both</span>
<span class="linecomment">;;  can be useful when you have an obarray as the COLLECTION argument</span>
<span class="linecomment">;;  for `completing-read'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In this method the symbol name is not used at all; the candidate</span>
<span class="linecomment">;;  is entirely replaced by another string, which is typically</span>
<span class="linecomment">;;  propertized.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You use a propertized string as the value of property</span>
<span class="linecomment">;;  `icicle-display-string' for the candidate symbol.  The propertized</span>
<span class="linecomment">;;  string is displayed in `*Completions*' and returned as the final</span>
<span class="linecomment">;;  completion choice.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that multi-completion is not available when you use an</span>
<span class="linecomment">;;  obarray.  Using property `icicle-special-candidate' or</span>
<span class="linecomment">;;  `icicle-display-string' you can propertize candidates and parts of</span>
<span class="linecomment">;;  candidates, but you cannot manipulate multi-completion parts and</span>
<span class="linecomment">;;  there are no join or end strings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Applying Text Properties to a Candidate String")</span>
<span class="linecomment">;;  ** Applying Text Properties to a Candidate String **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is the most flexible approach, and it is explained in a bit</span>
<span class="linecomment">;;  more detail.  It can be used with multi-completions, and it</span>
<span class="linecomment">;;  affects the `*Completions*' display and the completion return</span>
<span class="linecomment">;;  value.  However, it is limited to using an alist or list of</span>
<span class="linecomment">;;  strings, not an obarray, as the COLLECTION argument to</span>
<span class="linecomment">;;  `completing-read'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In this approach, you simply apply the text properties to the</span>
<span class="linecomment">;;  string(s) that represent the candidate, which you then pass to</span>
<span class="linecomment">;;  `completing-read' in its COLLECTION parameter.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As with the other methods, you can use any text properties you</span>
<span class="linecomment">;;  like, including these:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `face' - to make some completion candidates stand out in</span>
<span class="linecomment">;;    particular ways</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `help-echo' - for individualized candidate help</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `keymap' and `pointer' - for individualized mouse treatment of</span>
<span class="linecomment">;;    candidates</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `display' - to include images in candidates</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `invisible' - to hide part or all of particular candidates</span>
<span class="linecomment">;;    (which are nevertheless available for completion)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  How does this work?  Icicles redefines the standard Emacs function</span>
<span class="linecomment">;;  `display-completion-list' so that it retains text properties.</span>
<span class="linecomment">;;  Emacs should do the same, but it doesn't (yet).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles command `icicle-read-color' presents an illustration,</span>
<span class="linecomment">;;  using the `face' property.  In this case, a multi-completion is</span>
<span class="linecomment">;;  used, composed of an unpropertized string that names a color and a</span>
<span class="linecomment">;;  propertized string that names its RGB (red, green, blue) value.</span>
<span class="linecomment">;;  The RGB string, by default, has a background of the same color -</span>
<span class="linecomment">;;  each completion candidate is thus accompanied by its own color</span>
<span class="linecomment">;;  swatch.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The code that does this is function `icicle-make-color-candidate',</span>
<span class="linecomment">;;  which is used by `icicle-read-color':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   (defun icicle-make-color-candidate (color-name)</span>
<span class="linecomment">;;     "Return candidate of COLOR-NAME and its hex RGB string.</span>
<span class="linecomment">;;   If `icicle-WYSIWYG-Completions-flag' is non-nil, then the hex RGB</span>
<span class="linecomment">;;   string has the color as its background text property."</span>
<span class="linecomment">;;     (let ((rgb-string  (hexrgb-color-name-to-hex color-name)))</span>
<span class="linecomment">;;       (when icicle-WYSIWYG-Completions-flag</span>
<span class="linecomment">;;         (put-text-property</span>
<span class="linecomment">;;           0 (length rgb-string) 'face</span>
<span class="linecomment">;;           (cons 'background-color rgb-string) rgb-string))</span>
<span class="linecomment">;;       (list (list color-name rgb-string))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You'll notice that the face property is added only when option</span>
<span class="linecomment">;;  `icicle-WYSIWYG-Completions-flag' is non-nil.  You can toggle this</span>
<span class="linecomment">;;  option at any time during completion to change the behavior.  (The</span>
<span class="linecomment">;;  new value takes effect for the next act of completion.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can match any part of the multi-completion: color name or RGB</span>
<span class="linecomment">;;  value.  Command `icicle-read-color' defines a set of sort orders</span>
<span class="linecomment">;;  that are pertinent to the color candidates.  You can use `C-,' to</span>
<span class="linecomment">;;  sort by color name, RGB value, hue, saturation, value, or amount</span>
<span class="linecomment">;;  of red, blue, or green.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If option `icicle-add-proxy-candidates-flag' is non-nil, then</span>
<span class="linecomment">;;  command `icicle-read-color' includes proxy completion candidates</span>
<span class="linecomment">;;  that are not color-name-and-RGB pairs.  As always, you can toggle</span>
<span class="linecomment">;;  the use of proxy candidates using `C-M-_' in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The proxy candidates for colors include the single-quoted names of</span>
<span class="linecomment">;;  user options (variables) whose custom type is `color'.  So, for</span>
<span class="linecomment">;;  example, option `icicle-region-background' appears as proxy color</span>
<span class="linecomment">;;  candidate `'icicle-region-background''. Color proxies also include</span>
<span class="linecomment">;;  the following:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `*copied foreground*'  - last copied foreground, if available</span>
<span class="linecomment">;;  * `*copied background*'  - last copied background, if available</span>
<span class="linecomment">;;  * `*mouse-2 foreground*' - foreground where you click `mouse-2'</span>
<span class="linecomment">;;  * `*mouse-2 background*' - background where you click `mouse-2'</span>
<span class="linecomment">;;  * `*point foreground*'   - foreground under the text cursor</span>
<span class="linecomment">;;  * `*point background*'   - background under the text cursor</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you choose a proxy color candidates, the color referred to is</span>
<span class="linecomment">;;  used.  For example, `*point foreground*' means to use the</span>
<span class="linecomment">;;  foreground color at the cursor position (point), whatever it might</span>
<span class="linecomment">;;  be.  Choosing a `mouse-2' candidate lets you then click `mouse-2'</span>
<span class="linecomment">;;  to pick up a color somewhere.  If you use library `palette.el' or</span>
<span class="linecomment">;;  `eyedropper.el', and you have already copied a color, then you can</span>
<span class="linecomment">;;  choose `*copied foreground*' (or background) to use that color.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles treats reading face names similarly to reading colors, by</span>
<span class="linecomment">;;  redefining standard function `read-face-name' when you are in</span>
<span class="linecomment">;;  Icicle mode.  In this case, multi-completions are not used.  The</span>
<span class="linecomment">;;  pertinent function is `icicle-make-face-candidate', which provides</span>
<span class="linecomment">;;  a WYSIWYG face sample whenever `icicle-WYSIWYG-Completions-flag'</span>
<span class="linecomment">;;  is non-nil.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A string value for `icicle-WYSIWYG-Completions-flag' presents the</span>
<span class="linecomment">;;  face name accompanied by that string as a separate sample swatch.</span>
<span class="linecomment">;;  A value of t presents the face name itself in the face it names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   (defun icicle-make-face-candidate (face)</span>
<span class="linecomment">;;     "Return a completion candidate for FACE.</span>
<span class="linecomment">;;   The value of option `icicle-WYSIWYG-Completions-flag' determines</span>
<span class="linecomment">;;   the kind of candidate to use.</span>
<span class="linecomment">;;    If nil, then the face name is used (a string).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If a string, then a multi-completion candidate is used, with the</span>
<span class="linecomment">;;    face name followed by a sample swatch using FACE on the string's</span>
<span class="linecomment">;;    text.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If t, then the candidate is the face name itself, propertized</span>
<span class="linecomment">;;    with FACE."</span>
<span class="linecomment">;;     (if (stringp icicle-WYSIWYG-Completions-flag)</span>
<span class="linecomment">;;         (let ((swatch  (copy-sequence</span>
<span class="linecomment">;;                         icicle-WYSIWYG-Completions-flag)))</span>
<span class="linecomment">;;           (put-text-property</span>
<span class="linecomment">;;            0 (length icicle-WYSIWYG-Completions-flag)</span>
<span class="linecomment">;;            'face face swatch)</span>
<span class="linecomment">;;           (list (list (symbol-name face) swatch)))</span>
<span class="linecomment">;;       (let ((face-name  (copy-sequence (symbol-name face))))</span>
<span class="linecomment">;;         (when icicle-WYSIWYG-Completions-flag</span>
<span class="linecomment">;;           (put-text-property 0 (length face-name)</span>
<span class="linecomment">;;                              'face face face-name))</span>
<span class="linecomment">;;         (list face-name))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Programming with Fancy Candidates")</span>
<span class="linecomment">;;  * (@&gt; "Programming Multi-Completions")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Sorting Candidates and Removing Duplicates")</span>
<span class="linecomment">;;    for information about changing sort orders.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "*Completions* Display") for</span>
<span class="linecomment">;;    more about proxy candidates.</span>
 
<span class="linecomment">;;(@* "Defining Icicles Commands (Including Multi-Commands)")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining Icicles Commands (Including Multi-Commands)</span>
<span class="linecomment">;;  ----------------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Nothing To It!")</span>
<span class="linecomment">;;  ** Nothing To It! **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining a command that uses Icicles completion and cycling is</span>
<span class="linecomment">;;  simple: just call `completing-read' or `read-file-name' to read</span>
<span class="linecomment">;;  input, then act on that input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Nothing could be simpler - just use `completing-read'or</span>
<span class="linecomment">;;  `read-file-name'!  Icicles does the rest.  This is the most</span>
<span class="linecomment">;;  important thing to learn about defining Icicles commands: you</span>
<span class="linecomment">;;  don't need to do anything except call `completing-read' or</span>
<span class="linecomment">;;  `read-file-name' as you would normally anyway.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Or at least as I HOPE you would normally.  I fear that many</span>
<span class="linecomment">;;  Emacs-Lisp programmers don't take sufficient advantage of</span>
<span class="linecomment">;;  `completing-read' when they could, using instead a function such</span>
<span class="linecomment">;;  as (quel horreur !)  `read-string' to read user input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Multi-Commands Are Easy To Define Too")</span>
<span class="linecomment">;;  ** Multi-Commands Are Easy To Define Too **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If defining an Icicles command is trivial, so is defining an</span>
<span class="linecomment">;;  Icicles multi-command.  For the same effort it takes to define a</span>
<span class="linecomment">;;  command that acts on a single input choice, you can have a command</span>
<span class="linecomment">;;  that acts on any number of input choices.  A multi-command takes</span>
<span class="linecomment">;;  advantage of one or more action functions when cycling candidates,</span>
<span class="linecomment">;;  as described in sections</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands"),</span>
<span class="linecomment">;;  (@&gt; "More about Multi-Commands"), and</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Choose All Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In fact, there is no reason NOT to define your commands as</span>
<span class="linecomment">;;  multi-commands - you lose nothing, and you gain a lot.  Whenever</span>
<span class="linecomment">;;  it is appropriate for a user to possibly want to act on multiple</span>
<span class="linecomment">;;  objects, define a multi-command that does that.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Macros `icicle-define-command' and `icicle-define-file-command'</span>
<span class="linecomment">;;  make it easy to define a multi-command.  Without them, it is</span>
<span class="linecomment">;;  sometimes not so easy, depending on the complexity of your action</span>
<span class="linecomment">;;  functions.  See (@&gt; "Defining Multi-Commands the Hard Way") for a</span>
<span class="linecomment">;;  taste of what is involved.  If you read that section first, make</span>
<span class="linecomment">;;  sure you come back here to see how easy things can be.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here is how you might define a multi-command to delete one or more</span>
<span class="linecomment">;;  files or directories:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Define the multi-command, `my-delete-file':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (icicle-define-file-command</span>
<span class="linecomment">;;   my-delete-file                  ; Command name</span>
<span class="linecomment">;;   "Delete a file or directory."   ; Doc string</span>
<span class="linecomment">;;   my-delete-file-or-directory     ; Function to perform the action</span>
<span class="linecomment">;;   "Delete file or directory: "    ; `read-file-name' arguments...</span>
<span class="linecomment">;;   default-directory nil t)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Define the action function that deletes a single file:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defun my-delete-file-or-directory (file)</span>
<span class="linecomment">;;    "Delete file (or directory) FILE."</span>
<span class="linecomment">;;    (condition-case i-delete-file</span>
<span class="linecomment">;;        (if (eq t (car (file-attributes file)))</span>
<span class="linecomment">;;            (delete-directory file)</span>
<span class="linecomment">;;          (delete-file file))</span>
<span class="linecomment">;;      (error (message (error-message-string i-delete-file))</span>
<span class="linecomment">;;             (error (error-message-string i-delete-file)))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are two parts to the definition of `my-delete-file':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. The definition of the command itself, using</span>
<span class="linecomment">;;     `icicle-define-file-command'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. The definition of an action function,</span>
<span class="linecomment">;;     `my-delete-file-or-directory', which deletes a single file (or</span>
<span class="linecomment">;;     directory), given its name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is #1 that is of interest here, because that is essentially</span>
<span class="linecomment">;;  what you do to define any multi-command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The details of #2 are less interesting, even if more complex in</span>
<span class="linecomment">;;  this case: `my-delete-file-or-directory' checks whether its</span>
<span class="linecomment">;;  argument is a file or directory, and then tries to delete it.  If</span>
<span class="linecomment">;;  an error occurs, it prints the error message and then returns the</span>
<span class="linecomment">;;  message, so that the calling command can report on all deletion</span>
<span class="linecomment">;;  errors.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In #1, the arguments to `icicle-define-file-command' are</span>
<span class="linecomment">;;  straightforward:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The name of the command being defined `my-delete-file'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Its doc string.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The function that actually performs the action on the input file</span>
<span class="linecomment">;;    name - `my-delete-file-or-directory'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The arguments that you would supply anyway to `read-file-name'</span>
<span class="linecomment">;;    to read a single file name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These are the SAME things you would need if you were defining a</span>
<span class="linecomment">;;  simple command to delete a SINGLE file or directory.  The only</span>
<span class="linecomment">;;  differences here are that you:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Use `icicle-define-file-command' instead of `defun' with an</span>
<span class="linecomment">;;    `interactive' spec.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Separate the action code into a separate function (here,</span>
<span class="linecomment">;;    `my-delete-file-or-directory') that acts on a single object</span>
<span class="linecomment">;;    (here, a file).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you use `icicle-define-file-command', the action function is</span>
<span class="linecomment">;;  called on the result of `read-file-name', and it is also bound to</span>
<span class="linecomment">;;  `icicle-candidate-action-fn', so that it will be applied to the</span>
<span class="linecomment">;;  current candidate via `C-RET' or `C-mouse-2'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-all-candidates-action' (`C-!' -- see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Choose All Completion Candidates"))</span>
<span class="linecomment">;;  can report in buffer *Help* on the objects that it did not act</span>
<span class="linecomment">;;  upon successfully.  For this reporting to work, the function bound</span>
<span class="linecomment">;;  to `icicle-candidate-action-fn'</span>
<span class="linecomment">;;  (e.g. `my-delete-file-or-directory', above) should return `nil'</span>
<span class="linecomment">;;  for "success" and non-`nil' (for example, an error message) for</span>
<span class="linecomment">;;  "failure", whatever "success" and "failure" might mean in the</span>
<span class="linecomment">;;  particular context of use.  This is not a requirement, except if</span>
<span class="linecomment">;;  you want to take advantage of such reporting.  For a command that</span>
<span class="linecomment">;;  deletes files, it is important to let the user know which</span>
<span class="linecomment">;;  deletions failed when s?he tries to delete all matching candidates</span>
<span class="linecomment">;;  at once.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If the command you want to define acts on objects other than</span>
<span class="linecomment">;;  files, then use `icicle-define-command' instead of</span>
<span class="linecomment">;;  `icicle-define-file-command' - the only difference is that you</span>
<span class="linecomment">;;  then supply the arguments for `completing-read' instead of those</span>
<span class="linecomment">;;  for `read-file-name'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To let users know that a command is a multi-command, and how to</span>
<span class="linecomment">;;  use it as such, `icicle-define-command' and</span>
<span class="linecomment">;;  `icicle-define-file-command' automatically add this explanation to</span>
<span class="linecomment">;;  the doc string you provide for the multi-command:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  ---</span>
<span class="linecomment">;;  Read input, then call `&lt;your action function name&gt;' to act on it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Input-candidate completion and cycling are available.  While</span>
<span class="linecomment">;;  cycling, these keys with prefix `C-' are active:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-mouse-2', `C-RET' - Act on current completion candidate only</span>
<span class="linecomment">;;  `C-down' - Move to next prefix-completion candidate and act</span>
<span class="linecomment">;;  `C-up'   - Move to previous prefix-completion candidate and act</span>
<span class="linecomment">;;  `C-next' - Move to next apropos-completion candidate and act</span>
<span class="linecomment">;;  `C-prior'- Move to previous apropos-completion candidate and act</span>
<span class="linecomment">;;  `C-!'    - Act on *all* candidates, successively (careful!)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When candidate action and cycling are combined (e.g. `C-next'), user</span>
<span class="linecomment">;;  option `icicle-act-before-cycle-flag' determines which occurs first.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  With prefix `C-M-' instead of `C-', the same keys (`C-M-mouse-2',</span>
<span class="linecomment">;;  `C-M-RET', `C-M-down', and so on) provide help about candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Use `mouse-2', `RET' or `S-RET' to finally choose a candidate, or</span>
<span class="linecomment">;;  `C-g' to quit.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is an Icicles command - see `icicle-mode'.</span>
<span class="linecomment">;;  ---</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Notice that the doc string of your new multi-command references</span>
<span class="linecomment">;;  your action function (e.g. `my-delete-file-or-directory').  The</span>
<span class="linecomment">;;  doc string you provide for the multi-command can thus be a little</span>
<span class="linecomment">;;  more abstract, leaving any detailed explanation of the action to</span>
<span class="linecomment">;;  the doc string of your action function.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To provide more flexibility, `icicle-define-command' and</span>
<span class="linecomment">;;  `icicle-define-file-command' provide some predefined key bindings</span>
<span class="linecomment">;;  and allow for additional arguments.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here is a definition of a multi-command, `change-font', that reads</span>
<span class="linecomment">;;  a font name and changes the selected frame to use that font.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1  (icicle-define-command</span>
<span class="linecomment">;;  2   change-font "Change font of current frame."</span>
<span class="linecomment">;;  3   (lambda (font)</span>
<span class="linecomment">;;  4     (modify-frame-parameters orig-frame</span>
<span class="linecomment">;;  5                              (list (cons 'font font))))</span>
<span class="linecomment">;;  6   "Font: " (mapcar #'list (x-list-fonts "*"))</span>
<span class="linecomment">;;  7   nil t nil nil nil nil</span>
<span class="linecomment">;;  8   ((orig-frame  (selected-frame))</span>
<span class="linecomment">;;  9    (orig-font   (frame-parameter nil 'font)))</span>
<span class="linecomment">;;  10  nil</span>
<span class="linecomment">;;  11  (modify-frame-parameters orig-frame</span>
<span class="linecomment">;;  12                           (list (cons 'font orig-font)))</span>
<span class="linecomment">;;  13  nil)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The arguments to `icicle-define-command' here are as follows:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command name    (line 2)</span>
<span class="linecomment">;;  Doc string      (line 2)</span>
<span class="linecomment">;;  Action function (lines 3-5)</span>
<span class="linecomment">;;  Args passed to `completing-read' (lines 6-7)</span>
<span class="linecomment">;;  Additional bindings (lines 8-9)</span>
<span class="linecomment">;;  Additional initialization code (line 10)</span>
<span class="linecomment">;;  "Undo" code to run in case of error or user quit (lines 11-12)</span>
<span class="linecomment">;;  Additional code to run at the end (line 13)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following bindings are predefined - you can refer to them in</span>
<span class="linecomment">;;  the command body:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   `orig-buff'   is bound to (current-buffer)</span>
<span class="linecomment">;;   `orig-window' is bound to (selected-window)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Before running any "undo" code that you supply, the original</span>
<span class="linecomment">;;  buffer is restored, in case of error or user quit (`C-g').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Most of the arguments to `icicle-define-command' are optional.  In</span>
<span class="linecomment">;;  this case, optional arguments were provided to save (lines 8-9)</span>
<span class="linecomment">;;  and then restore (lines 11-12) the original font and frame.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Several top-level Icicles commands have been defined using</span>
<span class="linecomment">;;  `icicle-define-command' and `icicle-define-file-command'.  You can</span>
<span class="linecomment">;;  use their definitions as models for your own multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `clear-option' (alias) - Set value of binary option to nil</span>
<span class="linecomment">;;  `icicle-add-buffer-candidate' - Add buffer to those always shown</span>
<span class="linecomment">;;  `icicle-add-buffer-config' - Add to `icicle-buffer-configs'</span>
<span class="linecomment">;;  `icicle-bookmark'     - Jump to a bookmark</span>
<span class="linecomment">;;  `icicle-buffer'       - Switch to another buffer</span>
<span class="linecomment">;;  `icicle-buffer-config' - Choose a config for `icicle-buffer'</span>
<span class="linecomment">;;  `icicle-buffer-list'  - Choose a list of buffer names</span>
<span class="linecomment">;;  `icicle-clear-history' - Clear entries from minibuffer histories</span>
<span class="linecomment">;;  `icicle-clear-current-history' - Clear current history entries</span>
<span class="linecomment">;;  `icicle-color-theme'  - Change color theme</span>
<span class="linecomment">;;  `icicle-comint-command' - Reuse a previous command in comint mode</span>
<span class="linecomment">;;  `icicle-command-abbrev' - Execute command or command abbreviation</span>
<span class="linecomment">;;  `icicle-command-abbrev-command' - Execute command from abbrev</span>
<span class="linecomment">;;  `icicle-completing-yank' - Yank text using completion</span>
<span class="linecomment">;;  `icicle-delete-file'  - Delete a file or directory</span>
<span class="linecomment">;;  `icicle-delete-windows' - Delete windows showing a buffer anywhere</span>
<span class="linecomment">;;  `icicle-describe-option-of-type' - Describe option of a given type</span>
<span class="linecomment">;;  `icicle-directory-list' - Choose a list of directory names</span>
<span class="linecomment">;;  `icicle-doc'          - Display doc of function, variable, or face</span>
<span class="linecomment">;;  `icicle-execute-extended-command' -</span>
<span class="linecomment">;;                          A multi-command version of `M-x'</span>
<span class="linecomment">;;  `icicle-execute-named-keyboard-macro' - Execute named kbd macro</span>
<span class="linecomment">;;  `icicle-face-list'    - Choose a list of face names</span>
<span class="linecomment">;;  `icicle-file-list'    - Choose a list of file names</span>
<span class="linecomment">;;  `icicle-file'         - Visit a file or directory</span>
<span class="linecomment">;;  `icicle-find-file'    - Visit a file or directory (relative)</span>
<span class="linecomment">;;  `icicle-find-file-absolute' - Visit a file (absolute)</span>
<span class="linecomment">;;  `icicle-find-first-tag' - Visit source-code definition with tag</span>
<span class="linecomment">;;  `icicle-font'         - Change the frame font</span>
<span class="linecomment">;;  `icicle-frame-bg'     - Change the frame background color</span>
<span class="linecomment">;;  `icicle-frame-fg'     - Change the frame foreground color</span>
<span class="linecomment">;;  `icicle-fundoc'       - Display the doc of a function</span>
<span class="linecomment">;;  `icicle-Info-menu'    - Go to an Info menu node</span>
<span class="linecomment">;;  `icicle-insert-thesaurus-entry' - Insert thesaurus entry</span>
<span class="linecomment">;;  `icicle-keyword-list' - Choose a list of keywords (regexps)</span>
<span class="linecomment">;;  `icicle-kill-buffer'  - Kill a buffer</span>
<span class="linecomment">;;  `icicle-kmacro'       - Execute a keyboard macro (Emacs 22+)</span>
<span class="linecomment">;;  `icicle-locate-file'  - Open a file located anywhere</span>
<span class="linecomment">;;  `icicle-plist'        - Choose a symbol and its property list</span>
<span class="linecomment">;;  `icicle-recent-file'  - Open a recently used file</span>
<span class="linecomment">;;  `icicle-remove-all-regions-in-buffer' -</span>
<span class="linecomment">;;                          Remove all saved regions for a buffer</span>
<span class="linecomment">;;  `icicle-remove-buffer-candidate' -</span>
<span class="linecomment">;;                          Remove buffer from those always shown</span>
<span class="linecomment">;;  `icicle-remove-buffer-config' -</span>
<span class="linecomment">;;                          Remove from `icicle-buffer-configs'</span>
<span class="linecomment">;;  `icicle-remove-region' - Remove a region from saved regions list</span>
<span class="linecomment">;;  `icicle-remove-saved-completion-set' - Remove a set from</span>
<span class="linecomment">;;                          `icicle-saved-completion-sets'</span>
<span class="linecomment">;;  `icicle-reset-option-to-nil' -</span>
<span class="linecomment">;;                          Set value of binary option to nil</span>
<span class="linecomment">;;  `icicle-search-region' - Search a region in saved regions list</span>
<span class="linecomment">;;  `icicle-select-frame' - Select frame by name and raise it</span>
<span class="linecomment">;;  `icicle-select-region' - Select a region from saved regions list</span>
<span class="linecomment">;;  `icicle-select-window' - Select window by its buffer name</span>
<span class="linecomment">;;  `icicle-set-option-to-t' - Set the value of a binary option to t</span>
<span class="linecomment">;;  `icicle-toggle-option' - Toggle the value of a binary option</span>
<span class="linecomment">;;  `icicle-vardoc'       - Display the doc of a variable</span>
<span class="linecomment">;;  `icicle-where-is'     - Show key sequences that invoke a command</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For simplicity, the descriptions of these commands are singular</span>
<span class="linecomment">;;  actions (e.g. "kill a buffer"), but each of them can be used to</span>
<span class="linecomment">;;  act on any number of items any number of times (e.g. kill one or</span>
<span class="linecomment">;;  more buffers).  I recommend that you follow a similar naming</span>
<span class="linecomment">;;  convention - remember that the doc string will let users know that</span>
<span class="linecomment">;;  the command can be used on multiple objects.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Macros `icicle-define-command' and `icicle-define-file-command'</span>
<span class="linecomment">;;  define a multi-command in a simple way.  Sometimes you will need a</span>
<span class="linecomment">;;  little more flexibility.  In that case, you can use higher-order</span>
<span class="linecomment">;;  functions `icicle-explore' and `icicle-apply' to define a</span>
<span class="linecomment">;;  multi-command.  See (@&gt; "Defining Icicles Tripping Commands").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Are Users Dependent on Icicles To Use Multi-Commands?")</span>
<span class="linecomment">;;  ** Are Users Dependent on Icicles To Use Multi-Commands? **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For users to be able to take advantage of the Icicles features</span>
<span class="linecomment">;;  that your multi-command provides, they must load Icicles.  You can</span>
<span class="linecomment">;;  do this for them, by adding (require 'icicles nil t) to your code.</span>
<span class="linecomment">;;  The last two arguments mean that no error will be raised if for</span>
<span class="linecomment">;;  some reason Icicles cannot be found or successfully loaded.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But that brings up another question: What happens to your</span>
<span class="linecomment">;;  multi-command if Icicles is not available for a user, or s?he</span>
<span class="linecomment">;;  doesn't want to load it? No problem - your multi-command then</span>
<span class="linecomment">;;  automatically turns into a normal, single-choice command -</span>
<span class="linecomment">;;  graceful degradation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Similarly, users can always turn off `icicle-mode' at any time, to</span>
<span class="linecomment">;;  return to the standard Emacs behavior.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Users will, in any case, need to load Icicles at compile time, in</span>
<span class="linecomment">;;  order to byte-compile your library that calls macro</span>
<span class="linecomment">;;  `icicle-define-command' or `icicle-define-file-command' - either</span>
<span class="linecomment">;;  that, or you can duplicate the definition of the macro in your</span>
<span class="linecomment">;;  library.  To let users load Icicles at (only) compile time, add</span>
<span class="linecomment">;;  this to your library that defines multi-commands:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (eval-when-compile '(require icicles))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Defining Icicles Tripping Commands") for how to use</span>
<span class="linecomment">;;    `icicle-apply' and `icicle-explore' to define browsing commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Defining Multiple-Choice Menus").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Note to Programmers") for further programming guidelines.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Library `synonyms.el', which uses `icicle-define-command' to</span>
<span class="linecomment">;;    define command `synonyms'.  This command lets you use Icicles</span>
<span class="linecomment">;;    completion on input regexps when you search a thesaurus.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Library `palette.el', which uses `icicle-define-command' to</span>
<span class="linecomment">;;    define command `palette-pick-color-by-name-multi'.  This command</span>
<span class="linecomment">;;    lets you use Icicles completion on input regexps when you choose</span>
<span class="linecomment">;;    a palette color by name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Library `highlight.el', which uses `icicle-define-command' to</span>
<span class="linecomment">;;    defined commands `hlt-choose-faces', `hlt-choose-visible-faces',</span>
<span class="linecomment">;;    and `hlt-choose-invisible-faces'.  These commands let you choose</span>
<span class="linecomment">;;    a set of faces.</span>
 
<span class="linecomment">;;(@* "Defining Icicles Tripping Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining Icicles Tripping Commands</span>
<span class="linecomment">;;  ----------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Section (@file :file-name "icicles-doc1.el" :to "Icicles Tripping")</span>
<span class="linecomment">;;  describes the use of Icicles tripping (aka navigation or browsing)</span>
<span class="linecomment">;;  multi-commands.  This section tells you how to define your own</span>
<span class="linecomment">;;  such commands for custom trips - it is thus for Emacs-Lisp</span>
<span class="linecomment">;;  programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The best way to learn how to do this is to look at how the</span>
<span class="linecomment">;;  existing tripping commands are defined.  Some of them use macro</span>
<span class="linecomment">;;  `icicle-define-command'; others do not.  Some use the</span>
<span class="linecomment">;;  building-block functions `icicle-explore' or `icicle-apply';</span>
<span class="linecomment">;;  others do not.  Several use `icicle-search' as a building block.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Those that use `icicle-define-command' take advantage of some</span>
<span class="linecomment">;;  extraneous way to obtain trip location information from a display</span>
<span class="linecomment">;;  candidate, which is just a string.  For example, `icicle-bookmark'</span>
<span class="linecomment">;;  ultimately makes use of `bookmark-jump-noselect', which uses the</span>
<span class="linecomment">;;  display string to look up location information in a bookmarks</span>
<span class="linecomment">;;  file.  Those that use `icicle-explore' or `icicle-apply' make use</span>
<span class="linecomment">;;  of location information stored in the alist COLLECTION argument to</span>
<span class="linecomment">;;  `completing-read'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also use `icicle-define-command', `icicle-explore', and</span>
<span class="linecomment">;;  `icicle-apply' to define multi-commands other than browsing</span>
<span class="linecomment">;;  commands - the action function can do anything you like.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `icicle-explore' is a higher-order function that takes as</span>
<span class="linecomment">;;  arguments the following functions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * A function to build a candidates alist (COLLECTION) for</span>
<span class="linecomment">;;    completion.  It fills `icicle-candidates-alist' with the</span>
<span class="linecomment">;;    candidates, each of which is a cons with a display candidate</span>
<span class="linecomment">;;    string as car and (typically) location information as cdr.  For</span>
<span class="linecomment">;;    example, `icicle-find-tag' uses the tag text as display</span>
<span class="linecomment">;;    candidate and the standard tag-locating information as the cdr:</span>
<span class="linecomment">;;    tag info, file path, and goto function.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * A function that acts on the candidate finally chosen (`RET'),</span>
<span class="linecomment">;;    when completion is finished.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * A function to call if the user hits `C-g' during completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * A function to call if an error is raised during completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * A function to call after completion is finished, to clean things</span>
<span class="linecomment">;;    up.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you also bind `icicle-candidate-action-fn' to a function that</span>
<span class="linecomment">;;  takes a display candidate (string) as argument and navigates to</span>
<span class="linecomment">;;  the corresponding location, then `icicle-explore' does everything</span>
<span class="linecomment">;;  you need for an Icicles trip.  You can use function</span>
<span class="linecomment">;;  `icicle-get-alist-candidate' to get the location information for a</span>
<span class="linecomment">;;  given display candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `icicle-apply' binds `icicle-candidate-action-fn' appropriately</span>
<span class="linecomment">;;  and calls `icicle-explore'.  It applies its function argument to</span>
<span class="linecomment">;;  completion candidates the user acts on (using `C-RET' etc.).  It</span>
<span class="linecomment">;;  applies the function to the full alist entry, that is, the display</span>
<span class="linecomment">;;  candidate car plus any additional information in the cdr.  For a</span>
<span class="linecomment">;;  tripping command, the additional information provides a location</span>
<span class="linecomment">;;  and the function applied takes you there.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This use of an alist that stores location information in the cdrs</span>
<span class="linecomment">;;  is what makes `icicle-apply' and `icicle-explore' particularly</span>
<span class="linecomment">;;  suitable for defining navigation multi-commands.  The Icicles</span>
<span class="linecomment">;;  macros `icicle-define-command' and `icicle-define-file-command'</span>
<span class="linecomment">;;  make no such provision, but with suitable arguments you can use</span>
<span class="linecomment">;;  them too to define tripping commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `icicle-search' is another high-level function for defining</span>
<span class="linecomment">;;  tripping commands.  Like `icicle-apply', it calls</span>
<span class="linecomment">;;  `icicle-explore', but it also provides features for searching</span>
<span class="linecomment">;;  regions, buffers, and files.  It takes as arguments the search</span>
<span class="linecomment">;;  limits (region), if any, and either a regexp or a function that</span>
<span class="linecomment">;;  determines the unfiltered search hits.  It does everything else</span>
<span class="linecomment">;;  needed to define a trip command that uses search hits as</span>
<span class="linecomment">;;  completion candidates.  Several predefined Icicles tripping</span>
<span class="linecomment">;;  commands were defined using `icicle-search'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: If you define commands at a lower level (that is, without</span>
<span class="linecomment">;;  using `icicle-explore', `icicle-apply', or `icicle-search') that</span>
<span class="linecomment">;;  need to make use of information in the cdr of a completion</span>
<span class="linecomment">;;  candidate, then bind `icicle-whole-candidate-as-text-prop-p'</span>
<span class="linecomment">;;  around the call to `completing-read'.  You can then use</span>
<span class="linecomment">;;  `icicle-get-alist-candidate' to retrieve the cdr information from</span>
<span class="linecomment">;;  the completion result.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Icicles Tripping")</span>
<span class="linecomment">;;    for information about using Icicles Trip commands</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Defining Icicles Commands (Including Multi-Commands)")</span>
<span class="linecomment">;;    for general information about defining multi-commands</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Programming with Fancy Candidates") for information about</span>
<span class="linecomment">;;    `icicle-whole-candidate-as-text-prop-p'</span>
 
<span class="linecomment">;;(@* "Defining Multiple-Choice Menus")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining Multiple-Choice Menus</span>
<span class="linecomment">;;  ------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles multi-commands (see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands")) can be</span>
<span class="linecomment">;;  used provide users with multiple-choice menus.  While the possible</span>
<span class="linecomment">;;  choices can be accessed by minibuffer completion or cycling, a</span>
<span class="linecomment">;;  user can also display them in buffer `*Completions*' using `TAB'</span>
<span class="linecomment">;;  or `S-TAB', and click them there to choose them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That is, buffer `*Completions*' can act as a multiple-choice menu.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Simple use case: Suppose that you use special characters (Greek</span>
<span class="linecomment">;;  letters, math symbols, accented letters in another language...),</span>
<span class="linecomment">;;  but only occasionally - you don't want to take the trouble to</span>
<span class="linecomment">;;  learn a special input method for them or flip to a different soft</span>
<span class="linecomment">;;  keyboard.  One simple way to handle this is to create a menu of</span>
<span class="linecomment">;;  such special characters - Greek letters, for instance.  You only</span>
<span class="linecomment">;;  need to create the menu once, providing the necessary completions</span>
<span class="linecomment">;;  as, say, Unicode characters.  When you need to input such a</span>
<span class="linecomment">;;  character, just use your command that pops up buffer</span>
<span class="linecomment">;;  `*Completions*' with the available special characters.  Even if</span>
<span class="linecomment">;;  you don't know how to type them on your keyboard, you can cycle</span>
<span class="linecomment">;;  through them or use `mouse-2' to choose them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here's a simple example of defining a command that uses a</span>
<span class="linecomment">;;  multiple-choice menu.  (Other examples given above, such as</span>
<span class="linecomment">;;  `my-delete-file-or-directory' are also examples, but this one uses</span>
<span class="linecomment">;;  menu items that look more like menu items.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (icicle-define-command my-menu-command</span>
<span class="linecomment">;;      "Display menu and act on choice(s)."</span>
<span class="linecomment">;;      my-menu-action</span>
<span class="linecomment">;;      "`TAB' for menu.  `C-mouse-2' to choose. "</span>
<span class="linecomment">;;      my-menu-items nil t)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defvar my-menu-items</span>
<span class="linecomment">;;    '(("Foobar" . foobar-fn) ("Toto" . toto-fn) ("Titi" . titi-fn))</span>
<span class="linecomment">;;    "Alist of menu items and their associated commands.")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defun my-menu-action (item)</span>
<span class="linecomment">;;    "Call function associated with menu-item ITEM."</span>
<span class="linecomment">;;    (funcall (cdr (assoc item my-menu-items))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defun foobar-fn () (message "Foobar chosen"))</span>
<span class="linecomment">;;  (defun toto-fn () (message "Toto chosen"))</span>
<span class="linecomment">;;  (defun titi-fn () (message "Titi chosen"))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A user does `M-x my-menu-command' and hits `TAB' to display this</span>
<span class="linecomment">;;  menu in the `*Completions*' buffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Click mouse-2 on a completion to select it.  (C-h: help)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Possible completions are:</span>
<span class="linecomment">;;  Foobar          Titi</span>
<span class="linecomment">;;  Toto</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The user presses and holds the Control key.  S?he clicks `Foobar'</span>
<span class="linecomment">;;  - message "Foobar chosen" appears.  S?he clicks `Toto - message</span>
<span class="linecomment">;;  "Toto chosen" appears.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And so on - all while holding Control pressed.  Any number of menu</span>
<span class="linecomment">;;  items can be chosen, any number of times.  The command is finally</span>
<span class="linecomment">;;  exited with `RET' or `C-g'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The COLLECTION argument passed to `completing-read' here is</span>
<span class="linecomment">;;  `my-menu-items', an alist of key-value pairs, where the key is a</span>
<span class="linecomment">;;  menu-item name and the value is the function that implements the</span>
<span class="linecomment">;;  menu item.  For example, menu item `Foobar' is implemented by</span>
<span class="linecomment">;;  function `foobar-fn', and the alist element is therefore ("Foobar"</span>
<span class="linecomment">;;  . foobar-fn).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Function `my-menu-action' is executed when a user clicks</span>
<span class="linecomment">;;  `C-mouse-2' on a menu item.  It just looks up the menu item's</span>
<span class="linecomment">;;  function in alist `my-menu-items', and then calls that function.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What?  You think it's odd that the user must hit `TAB' to display</span>
<span class="linecomment">;;  the menu?  Then just use this code instead:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (icicle-define-command</span>
<span class="linecomment">;;   my-menu-command</span>
<span class="linecomment">;;   "Display menu and act on choice(s)."</span>
<span class="linecomment">;;   my-menu-action</span>
<span class="linecomment">;;   "`C-mouse-2' or `C-RET' to choose menu items"</span>
<span class="linecomment">;;   my-menu-items nil t nil nil nil nil</span>
<span class="linecomment">;;   ((icicle-show-*Completions*-initially-flag t)))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This just adds a binding for</span>
<span class="linecomment">;;  `icicle-show-*Completions*-initially-flag', so that</span>
<span class="linecomment">;;  `*Completions*' is displayed initially.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Granted, the `*Completions*' display doesn't exactly look like</span>
<span class="linecomment">;;  your average menu.  And the header line doesn't mention the</span>
<span class="linecomment">;;  multiple-choice possibility (holding Control while clicking).  But</span>
<span class="linecomment">;;  the header does say to use `C-h' for help, and that help does</span>
<span class="linecomment">;;  mention `C-mouse-2' (as does the prompt).  And the menu does act</span>
<span class="linecomment">;;  like a menu.  And the doc string of `my-menu-command' can provide</span>
<span class="linecomment">;;  more help, as needed.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are also some freebie advantages of using such menus,</span>
<span class="linecomment">;;  besides the feature of multiple-choice.  These include choosing</span>
<span class="linecomment">;;  menu items from the keyboard, with completion, and cycling among</span>
<span class="linecomment">;;  menu items.  The additional features are all explained when the</span>
<span class="linecomment">;;  user hits `C-?'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One common use of a multiple-choice menu is letting the user</span>
<span class="linecomment">;;  select a list of items from a larger list of candidates.  The list</span>
<span class="linecomment">;;  is returned, with the items in the order selected.  Examples of</span>
<span class="linecomment">;;  this include these multi-commands:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-buffer-list' - buffer names, selected from `buffer-list'</span>
<span class="linecomment">;;    (possibly after filtering)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-directory-list' - directory names, selected from</span>
<span class="linecomment">;;    subdirectories in the current directory and any directories you</span>
<span class="linecomment">;;    navigate to</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-face-list' - face names, selected from `face-list'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-file-list' - file names, selected from files in the</span>
<span class="linecomment">;;    current directory and any directories you navigate to</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-keyword-list' - keywords (regexps), selected from those</span>
<span class="linecomment">;;    you have previously entered</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `hlt-choose-faces', `hlt-choose-visible-faces',</span>
<span class="linecomment">;;    `hlt-choose-invisible-faces' - face names, selected from the</span>
<span class="linecomment">;;    (visible/invisible) highlighting faces in the buffer</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Such commands can be used on their own, or they can be used in the</span>
<span class="linecomment">;;  `interactive' specs of other commands that act on an entire list</span>
<span class="linecomment">;;  of selected items.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here, for example, is the definition of `icicle-file-list':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   (icicle-define-command icicle-file-list</span>
<span class="linecomment">;;     "Choose a list of file names.</span>
<span class="linecomment">;;   The list of names (strings) is returned."</span>
<span class="linecomment">;;     (lambda (name) (push name file-names))</span>
<span class="linecomment">;;     "Choose file (`RET' when done): "</span>
<span class="linecomment">;;     (mapcar #'list (directory-files default-directory nil</span>
<span class="linecomment">;;                                     icicle-re-no-dot))</span>
<span class="linecomment">;;     nil nil nil 'file-name-history nil nil</span>
<span class="linecomment">;;     ((file-names  ()))                    ; Additional bindings</span>
<span class="linecomment">;;     nil nil</span>
<span class="linecomment">;;     (prog1 (setq file-names (delete "" file-names)) ; Return list</span>
<span class="linecomment">;;       (when (interactive-p) (message "Files: %S" file-names))))</span>
 
<span class="linecomment">;;(@* "Defining Icicles Multi `M-x'")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining Icicles Multi `M-x'</span>
<span class="linecomment">;;  ----------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.  It explains how the</span>
<span class="linecomment">;;  Icicles Multi `M-x' feature is implemented, providing an advanced</span>
<span class="linecomment">;;  illustration of using macro `icicle-define-command'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "How Multi `M-x' is Defined")</span>
<span class="linecomment">;;  ** How Multi `M-x' is Defined **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The definition of `icicle-execute-extended-command' provides an</span>
<span class="linecomment">;;  interesting illustration of using `icicle-define-command'.  The</span>
<span class="linecomment">;;  candidate action function itself binds a candidate action</span>
<span class="linecomment">;;  function, in case the candidate is a command that reads input with</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (icicle-define-command</span>
<span class="linecomment">;;    icicle-execute-extended-command   ; `M-x' in Icicle mode.</span>
<span class="linecomment">;;    "Read command name, then read its arguments and call it."</span>
<span class="linecomment">;;    icicle-execute-extended-command-1 ; Action function</span>
<span class="linecomment">;;    (format "Execute command%s: "     ; `completing-read' args</span>
<span class="linecomment">;;            (if current-prefix-arg</span>
<span class="linecomment">;;                (format " (prefix %d)"</span>
<span class="linecomment">;;                        (prefix-numeric-value current-prefix-arg))</span>
<span class="linecomment">;;               ""))</span>
<span class="linecomment">;;    obarray 'commandp t nil 'extended-command-history nil nil</span>
<span class="linecomment">;;    ((last-cmd last-command))        ; Save the last command.</span>
<span class="linecomment">;;    nil (setq last-command last-cmd) ; Undo: restore last command.</span>
<span class="linecomment">;;    (setq last-command last-cmd))    ; Last: restore last command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defun icicle-execute-extended-command-1 (cmd-name)</span>
<span class="linecomment">;;    "Action function for `icicle-execute-extended-command'."</span>
<span class="linecomment">;;     (set-buffer orig-buff) ; bound by `icicle-define-command'.</span>
<span class="linecomment">;;     (select-window orig-window)</span>
<span class="linecomment">;;     (let ((icicle-candidate-action-fn</span>
<span class="linecomment">;;            (lambda (x) (funcall (intern cmd-name) x))))</span>
<span class="linecomment">;;       (run-hooks 'post-command-hook)</span>
<span class="linecomment">;;       (setq this-command cmd)</span>
<span class="linecomment">;;       (run-hooks 'pre-command-hook)</span>
<span class="linecomment">;;       (let ((enable-recursive-minibuffers  t))</span>
<span class="linecomment">;;         (call-interactively (intern cmd-name) 'record-it))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The last seven lines of this action function rebind</span>
<span class="linecomment">;;  `icicle-candidate-action-fn' to a function that calls the</span>
<span class="linecomment">;;  candidate `cmd-name' on a single argument that it reads.  This is</span>
<span class="linecomment">;;  useful if `cmd-name' is a command that, itself, reads an input</span>
<span class="linecomment">;;  argument with completion.  When that is the case, you can use</span>
<span class="linecomment">;;  completion on that input, and if you do that, you can use `C-RET'</span>
<span class="linecomment">;;  to use command `cmd-name' as a multi-command.  In other words,</span>
<span class="linecomment">;;  this binding allows for two levels of multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are a few things wrong with this definition, however.  In</span>
<span class="linecomment">;;  the action function, the candidate command is applied to a</span>
<span class="linecomment">;;  candidate that is a string.  What if it is a command, such as</span>
<span class="linecomment">;;  `describe-variable', that expects a symbol argument?  Or a number</span>
<span class="linecomment">;;  argument?  There is no way to know what kind of command will be</span>
<span class="linecomment">;;  used, and what kind of argument it will need.  The solution is to</span>
<span class="linecomment">;;  first try a string candidate argument, then convert the string to</span>
<span class="linecomment">;;  a symbol or number.  That is, bind this to</span>
<span class="linecomment">;;  `icicle-candidate-action-fn':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (lambda (x)</span>
<span class="linecomment">;;    (condition-case nil</span>
<span class="linecomment">;;        (funcall cmd x)    ; Try to use a string candidate.  If that</span>
<span class="linecomment">;;      (wrong-type-argument ; didn't work, use a symbol or number.</span>
<span class="linecomment">;;       (funcall cmd (car (read-from-string x))))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A similar problem occurs if the action function called doesn't</span>
<span class="linecomment">;;  accept a (single) argument.  The best thing to do in this case is</span>
<span class="linecomment">;;  punt - call `icicle-help-on-candidate' to display help on the</span>
<span class="linecomment">;;  candidate. To the code above, we add another error handler:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (wrong-number-of-arguments (funcall #'icicle-help-on-candidate))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And what if the command `cmd' does something that changes the</span>
<span class="linecomment">;;  focus away from the minibuffer's frame?  That's the case for</span>
<span class="linecomment">;;  `describe-variable', for instance: it selects buffer `*Help*'.  To</span>
<span class="linecomment">;;  fix this potential problem, the action function needs to reset the</span>
<span class="linecomment">;;  focus back to the minibuffer frame:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (lambda (x)</span>
<span class="linecomment">;;    (condition-case nil</span>
<span class="linecomment">;;        (funcall cmd x)</span>
<span class="linecomment">;;      (wrong-type-argument (funcall cmd (car (read-from-string x))))</span>
<span class="linecomment">;;      (wrong-number-of-arguments</span>
<span class="linecomment">;;       (funcall #'icicle-help-on-candidate)))</span>
<span class="linecomment">;;    (select-frame-set-input-focus</span>
<span class="linecomment">;;      (window-frame (minibuffer-window))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The actual definitions of the action function and the main command</span>
<span class="linecomment">;;  are even more complex.  They need to take into account various</span>
<span class="linecomment">;;  subtleties, including those associated with recursive minibuffers</span>
<span class="linecomment">;;  and multiple invocations of `completing-read'.  Evaluate, for</span>
<span class="linecomment">;;  example, (symbol-function 'icicle-execute-extended-command) to see</span>
<span class="linecomment">;;  the real definition.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Icicles Multi `M-x'").</span>
 
<span class="linecomment">;;(@* "Defining Multi-Commands the Hard Way")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining Multi-Commands the Hard Way</span>
<span class="linecomment">;;  ------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.  It gives you a taste</span>
<span class="linecomment">;;  of what is involved behind the scene when you effortlessly use</span>
<span class="linecomment">;;  `icicle-define-command' or `icicle-define-file-command' to define</span>
<span class="linecomment">;;  a multi-command.</span>
<span class="linecomment">;;  See (@&gt; "Defining Icicles Commands (Including Multi-Commands)").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It can be good to know this, if only for the case where you need</span>
<span class="linecomment">;;  to define a multi-command that has special behavior not provided</span>
<span class="linecomment">;;  by `icicle-define(-file)-command' out of the box.  For example, if</span>
<span class="linecomment">;;  you want the normal, single-choice `RET' behavior to be different</span>
<span class="linecomment">;;  from the multiple-choice `C-RET' behavior, then you might want to</span>
<span class="linecomment">;;  roll your own.  Likewise, if you want to define your own help on</span>
<span class="linecomment">;;  individual candidates, to be invoked when users use `C-M-RET' and</span>
<span class="linecomment">;;  so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To write your own multi-command, you must make the command do</span>
<span class="linecomment">;;  this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Call `completing-read' or `read-file-name', and perform some</span>
<span class="linecomment">;;     action on the completed input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Bind one or more of these variables to action functions, which</span>
<span class="linecomment">;;     each take a completion candidate as argument:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     a. `icicle-candidate-action-fn' - a function that performs an</span>
<span class="linecomment">;;        action on a completion candidate - often the same action as</span>
<span class="linecomment">;;        #1.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     b. `icicle-candidates-list-action-fn' - a function that</span>
<span class="linecomment">;;        performs an action on the list of all completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     c. `icicle-candidate-alt-action-fn' - a function that performs</span>
<span class="linecomment">;;        an alternative action on a completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     d. `icicle-candidates-list-alt-action-fn' - a function that</span>
<span class="linecomment">;;        performs an alternative action on the list of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     e. `icicle-candidate-help-fn' - a function that displays</span>
<span class="linecomment">;;        specialized help for a completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     f. `icicle-delete-candidate-object' - a function that deletes</span>
<span class="linecomment">;;        an object associated with (e.g. named by) a completion</span>
<span class="linecomment">;;        candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  #1 just lets people use the command normally, to perform the #1</span>
<span class="linecomment">;;  action on a completion candidate entered with `RET'.  Because of</span>
<span class="linecomment">;;  #2, people can perform the #2 action(s) on any completion</span>
<span class="linecomment">;;  candidates, while still continuing to cycle or complete</span>
<span class="linecomment">;;  candidates.  `icicle-candidate-action-fn' is often the same as the</span>
<span class="linecomment">;;  action for #1, but nothing prevents you from using different</span>
<span class="linecomment">;;  actions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When internal variable `icicle-candidate-action-fn' is not bound,</span>
<span class="linecomment">;;  the default action is performed: display help on the current</span>
<span class="linecomment">;;  completion candidate.  When `icicle-candidate-help-fn' is not</span>
<span class="linecomment">;;  bound, the default help display is used.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Instead of binding `icicle-delete-candidate-object' to a deletion</span>
<span class="linecomment">;;  action function, you can bind it to a symbol (variable) whose</span>
<span class="linecomment">;;  value is a list of completion-candidate objects.</span>
<span class="linecomment">;;  See (@&gt; "More about Multi-Commands") for more information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here is a definition of a simple (not multi-) command that reads a</span>
<span class="linecomment">;;  font name and then changes the selected frame to use that font.</span>
<span class="linecomment">;;  By virtue of calling `completing-read', Icicles completion and</span>
<span class="linecomment">;;  cycling are available, using all available font names as the pool</span>
<span class="linecomment">;;  of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defun change-font ()</span>
<span class="linecomment">;;    "Change font of selected frame."</span>
<span class="linecomment">;;    (modify-frame-parameters</span>
<span class="linecomment">;;     (selected-frame)</span>
<span class="linecomment">;;     (list (cons 'font (completing-read</span>
<span class="linecomment">;;                        "Font: " (mapcar #'list (x-list-fonts "*"))</span>
<span class="linecomment">;;                        nil t)))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here's a definition of a multi-command `change-font' that takes</span>
<span class="linecomment">;;  advantage of an action function when cycling candidates:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1  (defun change-font ()</span>
<span class="linecomment">;;  2    "Change font of current frame."</span>
<span class="linecomment">;;  3    (interactive)</span>
<span class="linecomment">;;  4   (let* ((orig-frame  (selected-frame))</span>
<span class="linecomment">;;  5          (orig-font   (frame-parameter nil 'font))</span>
<span class="linecomment">;;  6          (icicle-candidate-action-fn</span>
<span class="linecomment">;;  7           ;; Perform the action on a candidate, without leaving</span>
<span class="linecomment">;;  8           ;; `completing-read'.  You can do this over and over.</span>
<span class="linecomment">;;  9           (lambda (font)</span>
<span class="linecomment">;;  10             (modify-frame-parameters orig-frame</span>
<span class="linecomment">;;  11                                      (list (cons 'font font))))))</span>
<span class="linecomment">;;  12     (condition-case nil</span>
<span class="linecomment">;;  13         (modify-frame-parameters</span>
<span class="linecomment">;;  14          orig-frame</span>
<span class="linecomment">;;  15          (list</span>
<span class="linecomment">;;  16           (cons 'font</span>
<span class="linecomment">;;  17                 ;; Perform the action on your final choice.</span>
<span class="linecomment">;;  18                 (completing-read</span>
<span class="linecomment">;;  19                  "Font: "</span>
<span class="linecomment">;;  20                  (mapcar #'list (x-list-fonts "*")) nil t))))</span>
<span class="linecomment">;;  21       ((quit error)</span>
<span class="linecomment">;;  22        (modify-frame-parameters</span>
<span class="linecomment">;;  23         orig-frame</span>
<span class="linecomment">;;  24         (list (cons 'font orig-font)))))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As you can see, there is a lot more going on here than in the</span>
<span class="linecomment">;;  simple-command version.  These are the points to keep in mind,</span>
<span class="linecomment">;;  when defining a multi-command by hand:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Save anything you need to restore, so you can, in effect, undo</span>
<span class="linecomment">;;     the action in case of `C-g' (lines 4-5).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Bind `icicle-candidate-action-fn' to the action to perform</span>
<span class="linecomment">;;     (lines 6-11).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Perform the action, using `completing-read' to provide the</span>
<span class="linecomment">;;     target candidate (lines 13-20).  Do this in the body of a</span>
<span class="linecomment">;;     `condition-case' (lines 12-24).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. Restore the original context in the error-handling part of the</span>
<span class="linecomment">;;     `condition-case' (lines 22-24).  Include `quit' in the</span>
<span class="linecomment">;;     error-type list.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The above definition is not quite complete, in fact.  To let</span>
<span class="linecomment">;;  `icicle-all-candidates' be able to report on failures, the</span>
<span class="linecomment">;;  `icicle-candidate-action-fn' code should also trap errors and</span>
<span class="linecomment">;;  return nil as a success indicator.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In fact, things can get even hairier (much hairier) still, if the</span>
<span class="linecomment">;;  function at the core of your command does things like create a new</span>
<span class="linecomment">;;  frame - especially on MS Windows, with its click-to-focus window</span>
<span class="linecomment">;;  manager.  The action of `change-font' doesn't do that, but if it</span>
<span class="linecomment">;;  did, you would need to redirect the focus back to the minibuffer</span>
<span class="linecomment">;;  frame, using `select-frame-set-input-focus'.  As an illustration</span>
<span class="linecomment">;;  of what's involved, here's a definition that would deal with such</span>
<span class="linecomment">;;  problems.  It also traps `icicle-candidate-action-fn' errors,</span>
<span class="linecomment">;;  returning nil to report success and the error message to report</span>
<span class="linecomment">;;  failure.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defun change-font ()</span>
<span class="linecomment">;;    "Change font of current frame."</span>
<span class="linecomment">;;    (interactive)</span>
<span class="linecomment">;;    (let* ((orig-buff    (current-buffer))</span>
<span class="linecomment">;;           (orig-window  (selected-window))</span>
<span class="linecomment">;;           (orig-frame   (selected-frame))</span>
<span class="linecomment">;;           (orig-font    (frame-parameter nil 'font))</span>
<span class="linecomment">;;           (icicle-candidate-action-fn</span>
<span class="linecomment">;;            (lambda (candidate)</span>
<span class="linecomment">;;              (condition-case action-fn-return</span>
<span class="linecomment">;;                  (progn</span>
<span class="linecomment">;;                    (modify-frame-parameters</span>
<span class="linecomment">;;                     orig-frame (list (cons 'font candidate)))</span>
<span class="linecomment">;;                    (select-frame-set-input-focus</span>
<span class="linecomment">;;                     (window-frame (minibuffer-window)))</span>
<span class="linecomment">;;                    nil) ; Return nil to report success.</span>
<span class="linecomment">;;                ;; Return error message to report error.</span>
<span class="linecomment">;;                (error (error-message-string action-fn-return))))))</span>
<span class="linecomment">;;      (condition-case act-on-choice</span>
<span class="linecomment">;;          (modify-frame-parameters</span>
<span class="linecomment">;;           orig-frame</span>
<span class="linecomment">;;           (list (cons 'font</span>
<span class="linecomment">;;                       (completing-read</span>
<span class="linecomment">;;                        "Font: " (mapcar #'list (x-list-fonts "*"))</span>
<span class="linecomment">;;                        nil t nil nil nil nil))))</span>
<span class="linecomment">;;        (quit (switch-to-buffer orig-buff)</span>
<span class="linecomment">;;              (modify-frame-parameters</span>
<span class="linecomment">;;               orig-frame (list (cons 'font orig-font))))</span>
<span class="linecomment">;;        (error (switch-to-buffer orig-buff)</span>
<span class="linecomment">;;               (modify-frame-parameters</span>
<span class="linecomment">;;                orig-frame (list (cons 'font orig-font)))</span>
<span class="linecomment">;;               (error (error-message-string act-on-choice))))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That's a lot of (error-prone) work!  You obviously don't want to</span>
<span class="linecomment">;;  be doing that a lot.  Whenever you can, you should use macro</span>
<span class="linecomment">;;  `icicle-define-command' or `icicle-define-file-command' to define</span>
<span class="linecomment">;;  your multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Defining Icicles Commands (Including Multi-Commands)") for</span>
<span class="linecomment">;;  the easy way to define `change-font'.</span>
 
<span class="linecomment">;;(@* "Global Filters")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Global Filters</span>
<span class="linecomment">;;  --------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Which completion candidates get displayed?  To review:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. The domain of discourse, that is, all possible candidates, is</span>
<span class="linecomment">;;     determined by the arguments to `completing-read',</span>
<span class="linecomment">;;     `read-file-name', or `M-x'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. A user types something in the minibuffer.  This narrows the</span>
<span class="linecomment">;;     possible candidates to those that match the input.  Matching</span>
<span class="linecomment">;;     can be prefix-matching or apropos-matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Wouldn't it sometimes be useful to filter #1 in a global way,</span>
<span class="linecomment">;;  before filtering it with the user input (#2)?  Functions</span>
<span class="linecomment">;;  `completing-read' and `read-file-name' take a predicate argument,</span>
<span class="linecomment">;;  so that can be used for global filtering.  However, those</span>
<span class="linecomment">;;  functions are usually called from some command, and it would also</span>
<span class="linecomment">;;  be useful to give end users, not just programmers, some way to</span>
<span class="linecomment">;;  globally filter candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, if you have a command, such as `icicle-buffer', that</span>
<span class="linecomment">;;  reads a buffer name and displays the buffer, some users might</span>
<span class="linecomment">;;  always be interested only in buffers that are associated with</span>
<span class="linecomment">;;  files.  They don't want to see possible candidates like</span>
<span class="linecomment">;;  `*scratch*' and `*Messages*'.  What they need is a way to apply a</span>
<span class="linecomment">;;  global predicate that limits candidates to file-buffer names - but</span>
<span class="linecomment">;;  they don't have access to the call to `completing-read' that is</span>
<span class="linecomment">;;  inside the command definition.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For this reason, some global filtering variables are provided by</span>
<span class="linecomment">;;  Icicles:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `icicle-must-match-regexp', `icicle-must-not-match-regexp',</span>
<span class="linecomment">;;    `icicle-must-pass-predicate', `icicle-extra-candidates'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The first and second of these are regexps that candidates must</span>
<span class="linecomment">;;  match and must not match, respectively, in order for them to be</span>
<span class="linecomment">;;  displayed.  The third is a predicate that candidates must satisfy.</span>
<span class="linecomment">;;  The fourth is a list of extra candidates to display.  Any of the</span>
<span class="linecomment">;;  filters can be nil, in which case it has no effect.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Variable `icicle-must-match-regexp' is similar to the standard</span>
<span class="linecomment">;;  variable `completion-regexp-list', except:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `completion-regexp-list' is a list of regexps, not just one.</span>
<span class="linecomment">;;  * `icicle-must-match-regexp' is used after filtering using option</span>
<span class="linecomment">;;    `icicle-transform-function'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Variable `icicle-extra-candidates' is not really a "filter".  It</span>
<span class="linecomment">;;  does not restrict the set of possible candidates - rather, it</span>
<span class="linecomment">;;  extends that set.  The other filters do not act on the candidates</span>
<span class="linecomment">;;  in `icicle-extra-candidates' - they are always added.  Extra</span>
<span class="linecomment">;;  candidates are displayed in buffer `*Completions*' using face</span>
<span class="linecomment">;;  `icicle-extra-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that an extra candidate need not have anything in common with</span>
<span class="linecomment">;;  the normal (non-extra) candidates.  In particular, because it is</span>
<span class="linecomment">;;  provided explicitly, it does not follow the restrictions implied</span>
<span class="linecomment">;;  by the current candidate-generation method.  For example, when</span>
<span class="linecomment">;;  option `icicle-guess-cmds-in-path-flag' is non-nil, the extra</span>
<span class="linecomment">;;  shell-command candidates provided have no connection with the</span>
<span class="linecomment">;;  file-name completion that is used to generate the other candidates</span>
<span class="linecomment">;;  (see (@* "Icicles Shell-Command Enhancements")).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note too that if an extra candidate is already a candidate anyway</span>
<span class="linecomment">;;  then it will be present twice in the list of all candidates (that</span>
<span class="linecomment">;;  is, unless `icicle-transform-function' removes duplicate</span>
<span class="linecomment">;;  candidates).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These global variables are internal variables, even though they</span>
<span class="linecomment">;;  are defined as user options - they are not really meant to be</span>
<span class="linecomment">;;  customized.  If you are not an Emacs-Lisp programmer, you will not</span>
<span class="linecomment">;;  use these variables, but some commands that you use might provide</span>
<span class="linecomment">;;  corresponding global-filter user options.  Icicles provides</span>
<span class="linecomment">;;  customizable user options for command `icicle-buffer', for</span>
<span class="linecomment">;;  example:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `icicle-buffer-match-regexp'    - Regexp buffer names must match</span>
<span class="linecomment">;;    `icicle-buffer-no-match-regexp' - Regexp buffers must not match</span>
<span class="linecomment">;;    `icicle-buffer-predicate'       - Predicate buffers must satisfy</span>
<span class="linecomment">;;    `icicle-buffer-extras'          - Extra buffer names to display</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You might, for instance, customize `icicle-buffer-no-match-regexp'</span>
<span class="linecomment">;;  to not display file-buffers whose names end in `.elc', and</span>
<span class="linecomment">;;  customize `icicle-buffer-predicate' to show only buffers that are</span>
<span class="linecomment">;;  associated with files.  The former would use a value of "\\.elc$",</span>
<span class="linecomment">;;  and the latter would use a value such as this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     (lambda (bufname) (buffer-file-name (get-buffer bufname)))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Similarly, Icicles provides user options for filtering and sorting</span>
<span class="linecomment">;;  file names during completion:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `icicle-file-match-regexp'    - Regexp file names must match</span>
<span class="linecomment">;;    `icicle-file-no-match-regexp' - Regexp file names must not match</span>
<span class="linecomment">;;    `icicle-file-predicate'       - Predicate files must satisfy</span>
<span class="linecomment">;;    `icicle-file-extras'          - Extra file names to display</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you, as a programmer, write a command, and you want to expose</span>
<span class="linecomment">;;  global filters to users of the command, you should:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Create corresponding user options that can be customized.</span>
<span class="linecomment">;;  2. Bind the user options to the corresponding filtering variables.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `icicle-define-command' or `icicle-define-file-command'</span>
<span class="linecomment">;;  to define a command (recommended), then you can simply pass the</span>
<span class="linecomment">;;  filter-variable bindings as part of the BINDINGS argument.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, here is the core definition of `icicle-buffer':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   (icicle-define-command</span>
<span class="linecomment">;;    icicle-buffer                          ; Command name</span>
<span class="linecomment">;;    "Switch to a different buffer."        ; Doc string</span>
<span class="linecomment">;;    switch-to-buffer                       ; Action function</span>
<span class="linecomment">;;    "Switch to buffer: "                   ; completing-read args</span>
<span class="linecomment">;;    (mapcar (lambda (buf) (list (buffer-name buf)))</span>
<span class="linecomment">;;            (buffer-list))</span>
<span class="linecomment">;;    nil nil (buffer-name (if (fboundp 'another-buffer)</span>
<span class="linecomment">;;                             (another-buffer nil t)</span>
<span class="linecomment">;;                           (other-buffer (current-buffer))))</span>
<span class="linecomment">;;    nil nil nil</span>
<span class="linecomment">;;    ;; Filter bindings</span>
<span class="linecomment">;;    ((icicle-must-match-regexp      icicle-buffer-match-regexp)</span>
<span class="linecomment">;;     (icicle-must-not-match-regexp  icicle-buffer-no-match-regexp)</span>
<span class="linecomment">;;     (icicle-must-pass-predicate    icicle-buffer-predicate)</span>
<span class="linecomment">;;     (icicle-extra-candidates       icicle-buffer-extras)</span>
<span class="linecomment">;;     (icicle-sort-function          icicle-buffer-sort)))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you define a command that uses completion, but you don't use</span>
<span class="linecomment">;;  `icicle-define-command' or `icicle-define-file-command', then you</span>
<span class="linecomment">;;  can just bind such variables around a call to `completing-read' or</span>
<span class="linecomment">;;  `read-file-name'.  Command `icicle-complete-keys' presents an</span>
<span class="linecomment">;;  example of this, binding `icicle-buffer-no-match-regexp'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another way that users can apply predicates to completion</span>
<span class="linecomment">;;  candidates is to use `M-&' while completing.  These predicates</span>
<span class="linecomment">;;  apply to the full alist-entry candidates that are supplied to</span>
<span class="linecomment">;;  `completing-read' or `read-file-name', not just to the textual</span>
<span class="linecomment">;;  candidates that are displayed in buffer `*Completions*'.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc1.el" :to "Progressive Completion").</span>
 
<span class="linecomment">;;(@* "Specifying Match Functions for Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining Commands that Use Specific Match Functions</span>
<span class="linecomment">;;  ---------------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, Icicles lets users use prefix completion (with `TAB')</span>
<span class="linecomment">;;  or apropos completion (with `S-TAB'). They can alternatively use</span>
<span class="linecomment">;;  fuzzy completion with `TAB' or scatter-match completion with</span>
<span class="linecomment">;;  `S-TAB':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * They can use `C-(' during completion to toggle between prefix</span>
<span class="linecomment">;;    completion and fuzzy completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * They can use `M-(' to cycle among apropos completion and</span>
<span class="linecomment">;;    scatter-match completion. (Actually, they can customize the</span>
<span class="linecomment">;;    match types among which `M-(' cycles.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you define an Icicles command, you can specify which</span>
<span class="linecomment">;;  string-matching functions the command uses during completion:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If you want the command to use fuzzy completion for `TAB' by</span>
<span class="linecomment">;;    default, then bind `icicle-fuzzy-completion-flag' to</span>
<span class="linecomment">;;    non-`nil'. Users can still use `C-(' to toggle fuzzy completion</span>
<span class="linecomment">;;    off.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If you want the command to use a particular string-matching</span>
<span class="linecomment">;;    function for `S-TAB' completion by default, then bind variable</span>
<span class="linecomment">;;    `icicle-apropos-complete-match-fn' to that function. Users can</span>
<span class="linecomment">;;    still use `M-(' to cycle among the other matching functions for</span>
<span class="linecomment">;;    `S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can bind `icicle-apropos-complete-match-fn' to any function</span>
<span class="linecomment">;;  that matches strings. You will probably also want to ensure that</span>
<span class="linecomment">;;  it is available for `M-(' cycling, by adding it to</span>
<span class="linecomment">;;  `icicle-apropos-match-fns-alist' in a `let' binding. For example,</span>
<span class="linecomment">;;  to use matching function `my-match' in `my-cmd', you might do</span>
<span class="linecomment">;;  this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defun my-cmd ()</span>
<span class="linecomment">;;    "..."</span>
<span class="linecomment">;;    (interactive)</span>
<span class="linecomment">;;    (let ((icicle-apropos-complete-match-fn  'my-match)</span>
<span class="linecomment">;;          (icicle-apropos-match-fns-alist</span>
<span class="linecomment">;;           (cons (cons "mine" 'my-match)</span>
<span class="linecomment">;;                 icicle-apropos-match-fns-alist)))</span>
<span class="linecomment">;;        (do-something (completing-read "Choose: " ...) ...)))</span>
 
<span class="linecomment">;;(@* "Defining Buffer-Text Completion for Comint Modes")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining Buffer-Text Completion for Comint Modes</span>
<span class="linecomment">;;  ------------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Out of the box, Icicles provides completion for buffer text in</span>
<span class="linecomment">;;  some contexts.  This includes Shell mode, for example.  Whenever</span>
<span class="linecomment">;;  there are two or more candidate completions, you can use Icicles</span>
<span class="linecomment">;;  completion, with all of its features (cycling, progressive</span>
<span class="linecomment">;;  completion, apropos completion, and so on).</span>
<span class="linecomment">;;  See (@&gt; "Completion in Comint Modes").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Shell mode is an example of a mode that inherits from Comint mode.</span>
<span class="linecomment">;;  Other libraries sometimes define modes that also extend Comint</span>
<span class="linecomment">;;  mode in different ways.  Library ESS does so, for example.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In such modes, the top-level completion command used is typically</span>
<span class="linecomment">;;  `comint-dynamic-complete', and it is typically bound to `TAB'.  In</span>
<span class="linecomment">;;  Icicle mode, `TAB' in such a buffer is instead bound to the</span>
<span class="linecomment">;;  Icicles version of this command, `icicle-comint-dynamic-complete'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles provides the infrastructure for you to take advantage of</span>
<span class="linecomment">;;  Icicles completion with your own modes that inherit from Comint</span>
<span class="linecomment">;;  mode.  For that, just do the following:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Define replacement functions for the functions that perform the</span>
<span class="linecomment">;;     completion.  The functions to be replaced themselves typically</span>
<span class="linecomment">;;     call a Comint completion function, such as</span>
<span class="linecomment">;;     `comint-dynamic-complete-filename'.  You can typically use the</span>
<span class="linecomment">;;     same definitions as the original functions, except replace the</span>
<span class="linecomment">;;     call to a function that displays multiple matching candidates</span>
<span class="linecomment">;;     by a call to a corresponding Icicles function that performs</span>
<span class="linecomment">;;     completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Customize option `icicle-comint-dynamic-complete-replacements',</span>
<span class="linecomment">;;     adding the mappings that specify which standard functions to</span>
<span class="linecomment">;;     replace with your completion functions (from #1).  Take a look</span>
<span class="linecomment">;;     at the default value of this option to see what I mean.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Use `eval-after-load' to toggle Icicle mode when the vanilla</span>
<span class="linecomment">;;     code for your mode is loaded, to ensure that the original</span>
<span class="linecomment">;;     definitions are picked up.  See the end of `icicles-mode.el'</span>
<span class="linecomment">;;     for an example of this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you are interested in trying this, take a look at the Icicles</span>
<span class="linecomment">;;  code for, say, `icicle-shell-dynamic-complete-command', comparing</span>
<span class="linecomment">;;  it with the original code for `shell-dynamic-complete-command'.</span>
<span class="linecomment">;;  You will see that the only change is to substitute a call to</span>
<span class="linecomment">;;  `icicle-shell-dynamic-complete-as-command' for a call to</span>
<span class="linecomment">;;  `shell-dynamic-complete-as-command'.  Likewise,</span>
<span class="linecomment">;;  `icicle-shell-dynamic-complete-as-command' is a trivial alteration</span>
<span class="linecomment">;;  of `shell-dynamic-complete-as-command'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The key is to ultimately call an Icicles completion command, such</span>
<span class="linecomment">;;  as `icicle-comint-dynamic-simple-complete', whenever there are</span>
<span class="linecomment">;;  multiple completion candidates.  This has the effect of using</span>
<span class="linecomment">;;  Icicles minibuffer completion instead of simply displaying the</span>
<span class="linecomment">;;  alternatives in buffer `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles uses this same technique, of substituting Icicles</span>
<span class="linecomment">;;  completion for simple display of alternatives, for all buffer-text</span>
<span class="linecomment">;;  completion that it supports out of the box, even when there is no</span>
<span class="linecomment">;;  relation with Comint mode.</span>
 
<span class="linecomment">;;(@* "Note to Programmers")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note to Programmers</span>
<span class="linecomment">;;  -------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here are some simple guidelines for using Icicles in Emacs-Lisp</span>
<span class="linecomment">;;  programming:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. *Use it*!  Even if you don't do anything else, include this in</span>
<span class="linecomment">;;     your library:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     (require 'icicles nil t)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     That has absolutely no consequences if Icicles is not present</span>
<span class="linecomment">;;     in the user's `load-path' (there is no load error).  If Icicles</span>
<span class="linecomment">;;     is present, however, then users can take advantage of each use</span>
<span class="linecomment">;;     you make of `completing-read' and `read-file-name' in your</span>
<span class="linecomment">;;     code.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Use an input-completion read function, such as</span>
<span class="linecomment">;;     `completing-read' or `read-file-name', when you read input!</span>
<span class="linecomment">;;     There is almost never a reason not to use an input-completion</span>
<span class="linecomment">;;     function when reading user input - especially considering that</span>
<span class="linecomment">;;     you need not always provide a REQUIRE-MATCH argument.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     Try also to find an appropriate PREDICATE argument, and a good</span>
<span class="linecomment">;;     set of default values to pass to `completing-read' as its</span>
<span class="linecomment">;;     COLLECTION argument.  Too often, I think, we use an overly</span>
<span class="linecomment">;;     general COLLECTION argument, such as the `obarray', and we</span>
<span class="linecomment">;;     don't provide a (good) PREDICATE.  Using an input-completion</span>
<span class="linecomment">;;     function with an appropriate candidate completion list and</span>
<span class="linecomment">;;     predicate can help users considerably.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     If you want to also give users a way to customize a (different)</span>
<span class="linecomment">;;     predicate that applies only to the textual candidates that are</span>
<span class="linecomment">;;     displayed in buffer `*Completions*', as opposed to the full</span>
<span class="linecomment">;;     alist-entry candidates that are supplied to `completing-read'</span>
<span class="linecomment">;;     or `read-file-name', then you can define a new user option and</span>
<span class="linecomment">;;     then bind internal variable `icicle-must-pass-predicate' to the</span>
<span class="linecomment">;;     value of that option. See (@&gt; "Global Filters").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Avoid using a literal-string `interactive' spec (e.g.</span>
<span class="linecomment">;;     (interactive "fFile: ")) that reads input with completion.</span>
<span class="linecomment">;;     Instead, call `completing-read' or `read-file-name' within the</span>
<span class="linecomment">;;     `interactive' spec.  This saves Icicles users of progressive</span>
<span class="linecomment">;;     completion the need to hit `RET' multiple times to pass their</span>
<span class="linecomment">;;     input up through multiple levels of recursive minibuffers to</span>
<span class="linecomment">;;     the top level.  See</span>
<span class="linecomment">;;     (@file :file-name "icicles-doc1.el" :to "Progressive Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. In many cases, it makes sense to define a multi-command, rather</span>
<span class="linecomment">;;     than a simple command.  People can always use a multi-command</span>
<span class="linecomment">;;     as a simple command, but not vice versa.</span>
<span class="linecomment">;;     See (@file :file-name "icicles-doc1.el" :to "Multi-Commands"),</span>
<span class="linecomment">;;     (@&gt; "Defining Icicles Commands (Including Multi-Commands)"),</span>
<span class="linecomment">;;     and (@&gt; "Defining Multi-Commands the Hard Way").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  5. Consider using `icicle-completing-read-history' instead of</span>
<span class="linecomment">;;     `read-from-minibuffer' or `read-string' for most purposes.</span>
<span class="linecomment">;;     This lets users complete their input against previously entered</span>
<span class="linecomment">;;     input.  Completion is lax, so they can also enter new input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  6. You can bind `icicle-sort-function' temporarily to any sort</span>
<span class="linecomment">;;     function you need.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  7. Function `icicle-next-candidate' is a general framework for</span>
<span class="linecomment">;;     letting users cycle completions of partial input strings.  I</span>
<span class="linecomment">;;     use it to define the cycling behavior for both prefix and</span>
<span class="linecomment">;;     apropos completions.  You can use it to easily define other,</span>
<span class="linecomment">;;     application-specific input matching/completion/cycling</span>
<span class="linecomment">;;     behavior.  Just supply it with a function that takes the</span>
<span class="linecomment">;;     current partial user input (a string) and returns a list of</span>
<span class="linecomment">;;     candidate completions, however those might be defined.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  8. If the potential number of completion candidates is enormous,</span>
<span class="linecomment">;;     then icompletion display in `*Completions*' can be slow.  In</span>
<span class="linecomment">;;     that case, consider turning it off for the duration of the</span>
<span class="linecomment">;;     command, by binding `icicle-incremental-completion-flag' to</span>
<span class="linecomment">;;     nil.  An alternative to turning it off is the approach taken in</span>
<span class="linecomment">;;     Icicles (e.g. `icicle-vardoc' and</span>
<span class="linecomment">;;     `icicle-insert-thesaurus-entry'): Just add a reminder to the</span>
<span class="linecomment">;;     doc string to tell users that they can toggle</span>
<span class="linecomment">;;     `icicle-incremental-completion-flag' with `C-#'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  9. Another of my libraries that can help programmers provide</span>
<span class="linecomment">;;     default values is `thingatpt+.el'.  It provides functions for</span>
<span class="linecomment">;;     picking up symbols, sexps, numbers, words, and other sorts of</span>
<span class="linecomment">;;     thing near the text cursor (`point').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Multi-Commands")</span>
<span class="linecomment">;;  * (@&gt; "Defining Icicles Commands (Including Multi-Commands)")</span>
<span class="linecomment">;;  * (@&gt; "Defining Multi-Commands the Hard Way")</span>
<span class="linecomment">;;  * (@&gt; "Defining Multiple-Choice Menus")</span>
<span class="linecomment">;;  * (@&gt; "Global Filters")</span>
<span class="linecomment">;;  * (@&gt; "Specifying Match Functions for Commands")</span>
<span class="linecomment">;;  * (@&gt; "Multi-Completions")</span>
 
<span class="linecomment">;;(@* "La Petite Histoire")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  La Petite Histoire</span>
<span class="linecomment">;;  ------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. This library started life as `elect-mbuf.el', by Hans Koomen.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Original posting:</span>
<span class="linecomment">;;    From koomen@cs.rochester.edu Mon Jun 19 19:27:58 1989</span>
<span class="linecomment">;;    To: info-gnu-emacs@prep.ai.mit.edu</span>
<span class="linecomment">;;    Cc: Hans &lt;Koomen@cs.rochester.edu&gt;</span>
<span class="linecomment">;;    Subject: elect-mbuf.el</span>
<span class="linecomment">;;    Date: Tue, 13 Jun 89 15:17:07 -0400</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. I hacked and enhanced the library in various relatively minor</span>
<span class="linecomment">;;  ways over the years, maintaining it as `elect-mbuf.el' - see</span>
<span class="linecomment">;;  details in file `icicles-chg.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I did not change the main functionality of the library during this</span>
<span class="linecomment">;;  period: it always cycled the COMPLETE list of (prefix) completion</span>
<span class="linecomment">;;  candidates passed to `completing-read'; it did not update the</span>
<span class="linecomment">;;  candidate list based on the current minibuffer contents.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So, for instance, if you had `M-x for' in the minibuffer, `down'</span>
<span class="linecomment">;;  would cycle among ALL Emacs commands, not just those that start</span>
<span class="linecomment">;;  with "for".  I used the library this way for fifteen years without</span>
<span class="linecomment">;;  thinking much about this behavior or the code behind it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. In July 2005, Lennart Borgman gave `elect-mbuf.el' a quick try,</span>
<span class="linecomment">;;  and intuitively expected to see behavior along the lines that you</span>
<span class="linecomment">;;  see now for Icicles prefix completion:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  a. `down' should cycle completions relative to the current input,</span>
<span class="linecomment">;;     not all completions supplied to `completing-read'.</span>
<span class="linecomment">;;  b. If buffer `*Completions*' is displayed, `down' should highlight</span>
<span class="linecomment">;;     the current candidate there.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Good idea Lennart (&lt;lennart.borgman.073@student.lu.se&gt;).  So I</span>
<span class="linecomment">;;  implemented that behavior, and renamed the library "Icicles" (for,</span>
<span class="linecomment">;;  I suppose, "input cycles" or some such - or because it's "cool").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. The code changes I made to implement #3 (completion cycling</span>
<span class="linecomment">;;  relative to current input) made me realize that other completion</span>
<span class="linecomment">;;  matchings could be implemented in a similar way.  Prefix</span>
<span class="linecomment">;;  completion (the completion provided by Emacs) is handy, but it is</span>
<span class="linecomment">;;  also sometimes a bit limited.  The idea of apropos completion</span>
<span class="linecomment">;;  occurred to me, and I implemented that as well.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  5. I extended the library quite a bit more, in terms of</span>
<span class="linecomment">;;  convenience (highlighting, treatment of buffer</span>
<span class="linecomment">;;  `*Completions*',..., but also in terms of functionality.  In</span>
<span class="linecomment">;;  particular, it now treats file names too.  And, because Emacs 21</span>
<span class="linecomment">;;  and later versions use `read-file-name' for `find-file' and so on,</span>
<span class="linecomment">;;  Icicles now treats `read-file-name' the same as `completing-read'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  6. On another suggestion from LennartBorgman, I made Icicles take</span>
<span class="linecomment">;;  advantage of Delete Selection mode.  And I implemented it as a</span>
<span class="linecomment">;;  minor mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  7, 8, 9,...  One thing has led to another, and I've just kept</span>
<span class="linecomment">;;  adding features.  Feature creep, I guess.  But the more I play</span>
<span class="linecomment">;;  with Icicles, the more I imagine new ways it might be made more</span>
<span class="linecomment">;;  useful.</span>
 
<span class="linecomment">;;(@* "Note on Non-nil `pop-up-frames' on MS Windows")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note on Non-nil `pop-up-frames' on MS Windows</span>
<span class="linecomment">;;  ---------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `pop-up-frames' = t, like I do, you might have noticed</span>
<span class="linecomment">;;  that Emacs completion does not play well with using separate</span>
<span class="linecomment">;;  frames for each buffer.  In particular, it does not play well with</span>
<span class="linecomment">;;  having a separate frame for buffer `*Completions*'.  When you try</span>
<span class="linecomment">;;  to complete input using `TAB', a new frame is created for buffer</span>
<span class="linecomment">;;  `*Completions*', and, at least on MS Windows, it is selected,</span>
<span class="linecomment">;;  taking the input focus away from the original frame's minibuffer!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This means that, once the `*Completions*' buffer has been</span>
<span class="linecomment">;;  displayed in a separate frame, you cannot, for instance, cycle</span>
<span class="linecomment">;;  completion candidates, without first reselecting the original</span>
<span class="linecomment">;;  frame manually.  You cannot even use normal completion - you</span>
<span class="linecomment">;;  cannot add text in the minibuffer, or delete text there, because</span>
<span class="linecomment">;;  the minibuffer in the original frame no longer has the input</span>
<span class="linecomment">;;  focus.  Bummer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In general, Emacs does not play too well with one-buffer-per-frame</span>
<span class="linecomment">;;  (`pop-up-frames' = t), and this is a good example of that general</span>
<span class="linecomment">;;  problem.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I reported this Emacs bug.  I've been hoping it will be corrected</span>
<span class="linecomment">;;  since Emacs 21...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I don't have this problem of loss of frame input focus in my own</span>
<span class="linecomment">;;  setup, even though I use `pop-up-frames' = t, because I use my</span>
<span class="linecomment">;;  library `oneonone.el'.  (Try it!)  If you need a solution while</span>
<span class="linecomment">;;  waiting for the Emacs fix, you can try doing something similar to</span>
<span class="linecomment">;;  what I do in `oneonone.el':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Use dedicated frames for both `*Completions*' and the</span>
<span class="linecomment">;;     minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Display buffer `*Completions*' using a special-display function</span>
<span class="linecomment">;;     that explicitly redirects the input focus from the</span>
<span class="linecomment">;;     `*Completions*' frame back to the minibuffer frame.</span>
 
<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; This program is free software; you can redistribute it and/or</span>
<span class="linecomment">;; modify it under the terms of the GNU General Public License as</span>
<span class="linecomment">;; published by the Free Software Foundation; either version 2, or (at</span>
<span class="linecomment">;; your option) any later version.</span>

<span class="linecomment">;; This program is distributed in the hope that it will be useful,</span>
<span class="linecomment">;; but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="linecomment">;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="linecomment">;; GNU General Public License for more details.</span>

<span class="linecomment">;; You should have received a copy of the GNU General Public License</span>
<span class="linecomment">;; along with this program; see the file COPYING.  If not, write to</span>
<span class="linecomment">;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth</span>
<span class="linecomment">;; Floor, Boston, MA 02110-1301, USA.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;; Code:</span>

<span class="linecomment">;; You need not load this file.  It contains only documentation.</span>

(provide 'icicles-doc2)

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;; icicles-doc2.el ends here</span></span></pre></div><div class="wrapper close"></div></div><div class="footer"><hr /><span class="gotobar bar"><a class="local" href="http://www.emacswiki.org/emacs/SiteMap">SiteMap</a> <a class="local" href="http://www.emacswiki.org/emacs/Search">Search</a> <a class="local" href="http://www.emacswiki.org/emacs/ElispArea">ElispArea</a> <a class="local" href="http://www.emacswiki.org/emacs/HowTo">HowTo</a> <a class="local" href="http://www.emacswiki.org/emacs/RecentChanges">RecentChanges</a> <a class="local" href="http://www.emacswiki.org/emacs/News">News</a> <a class="local" href="http://www.emacswiki.org/emacs/Problems">Problems</a> <a class="local" href="http://www.emacswiki.org/emacs/Suggestions">Suggestions</a> </span><span class="translation bar"><br />  <a class="translation new" rel="nofollow" href="http://www.emacswiki.org/emacs?action=translate;id=icicles-doc2.el;missing=de_es_fr_it_ja_ko_pt_ru_se_zh">Add Translation</a></span><span class="edit bar"><br /> <a class="edit" accesskey="e" title="Click to edit this page" rel="nofollow" href="http://www.emacswiki.org/emacs?action=edit;id=icicles-doc2.el">Edit this page</a> <a class="history" rel="nofollow" href="http://www.emacswiki.org/emacs?action=history;id=icicles-doc2.el">View other revisions</a> <a class="admin" rel="nofollow" href="http://www.emacswiki.org/emacs?action=admin;id=icicles-doc2.el">Administration</a></span><span class="time"><br /> Last edited 2009-02-28 20:40 UTC by <a class="author" title="from inet-bc01-o.oracle.com" href="http://www.emacswiki.org/emacs/DrewAdams">DrewAdams</a> <a class="diff" rel="nofollow" href="http://www.emacswiki.org/emacs?action=browse;diff=2;id=icicles-doc2.el">(diff)</a></span><div style="float:right; margin-left:1ex;">
<!-- Creative Commons License -->
<a href="http://creativecommons.org/licenses/GPL/2.0/"><img alt="CC-GNU GPL" style="border:none" src="/pics/cc-GPL-a.png" /></a>
<!-- /Creative Commons License -->
</div>

<!--
<rdf:RDF xmlns="http://web.resource.org/cc/"
 xmlns:dc="http://purl.org/dc/elements/1.1/"
 xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="">
   <license rdf:resource="http://creativecommons.org/licenses/GPL/2.0/" />
  <dc:type rdf:resource="http://purl.org/dc/dcmitype/Software" />
</Work>

<License rdf:about="http://creativecommons.org/licenses/GPL/2.0/">
   <permits rdf:resource="http://web.resource.org/cc/Reproduction" />
   <permits rdf:resource="http://web.resource.org/cc/Distribution" />
   <requires rdf:resource="http://web.resource.org/cc/Notice" />
   <permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
   <requires rdf:resource="http://web.resource.org/cc/ShareAlike" />
   <requires rdf:resource="http://web.resource.org/cc/SourceCode" />
</License>
</rdf:RDF>
-->

<p class="legal">
This work is licensed to you under version 2 of the
<a href="http://www.gnu.org/">GNU</a> <a href="/GPL">General Public License</a>.
Alternatively, you may choose to receive this work under any other
license that grants the right to use, copy, modify, and/or distribute
the work, as long as that license imposes the restriction that
derivative works have to grant the same rights and impose the same
restriction. For example, you may choose to receive this work under
the
<a href="http://www.gnu.org/">GNU</a>
<a href="/FDL">Free Documentation License</a>, the
<a href="http://creativecommons.org/">CreativeCommons</a>
<a href="http://creativecommons.org/licenses/sa/1.0/">ShareAlike</a>
License, the XEmacs manual license, or
<a href="/OLD">similar licenses</a>.
</p>
</div>
</body>
</html>
